
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>geotecha.piecewise.piecewise_linear_1d &#8212; geotecha 0.2.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../../index.html"><img src="../../../_static/logo.png" border="0" alt="py4sci"/></a>
</div>



      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for geotecha.piecewise.piecewise_linear_1d</h1><div class="highlight"><pre>
<span></span><span class="c1"># geotecha - A software suite for geotechncial engineering</span>
<span class="c1"># Copyright (C) 2018  Rohan T. Walker (rtrwalker@gmail.com)</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see http://www.gnu.org/licenses/gpl.html.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">One dimensional piecwise linear relationships and manipulations</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">operator</span>


<div class="viewcode-block" id="has_steps"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.has_steps">[docs]</a><span class="k">def</span> <span class="nf">has_steps</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check if data points have any step changes</span>

<span class="sd">    True if any two consecutive x values are equal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        x-coordinates</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : boolean</span>
<span class="sd">        Returns True if any two consecutive x values are equal.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#TODO: maybe check for bad segments such as x=[2,2] y=[10,10]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="is_initially_increasing"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.is_initially_increasing">[docs]</a><span class="k">def</span> <span class="nf">is_initially_increasing</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Are first two values increasing?</span>

<span class="sd">    Finds 1st instance where x[i+1] != x[i] and checks if x[i+1] &gt; x[i].</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        1 dimensional data to check</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ``int``</span>
<span class="sd">        Returns True if 2nd value is greater than the 1st value.</span>
<span class="sd">        Returns False if 2nd value is less than the 1st value.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This might be slow for long lists, perhaps just loop through</span>
    <span class="c1"># until x[i+1]!=x[i]</span>
    <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span></div>


<span class="c1">#used info from http://stackoverflow.com/questions/4983258/python-how-to-check-list-monotonicity</span>
<div class="viewcode-block" id="strictly_increasing"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.strictly_increasing">[docs]</a><span class="k">def</span> <span class="nf">strictly_increasing</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks all x[i+1] &gt; x[i]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1d array</span>
<span class="sd">        Series of x values</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : True/False</span>
<span class="sd">        True if each x value is greater than the preceeding value.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    strictly_decreasing : Check for decreasing values, no equality allowed.</span>
<span class="sd">    non_increasing : Less stringent decreasing check, allows equal values.</span>
<span class="sd">    non_decreasing : Less stringent increasing check, allows equal values.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="strictly_decreasing"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.strictly_decreasing">[docs]</a><span class="k">def</span> <span class="nf">strictly_decreasing</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks all x[i+1] &lt; x[i]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1d array</span>
<span class="sd">        Series of x values</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : True/False</span>
<span class="sd">        True if each x value is less than the preceeding value.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    strictly_increasing : Check for increasing values, no equality allowed.</span>
<span class="sd">    non_increasing : Less stringent decreasing check, allows equal values.</span>
<span class="sd">    non_decreasing : Less stringent increasing check, allows equal values.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="non_increasing"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.non_increasing">[docs]</a><span class="k">def</span> <span class="nf">non_increasing</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks all x[i+1] &lt;= x[i]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1d array</span>
<span class="sd">        Series of x values</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : True/False</span>
<span class="sd">        True if each x value is less than or equal to the preceeding value.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    strictly_increasing : Check for increasing values, no equality allowed.</span>
<span class="sd">    strictly_decreasing : Check for decreasing values, no equality allowed.</span>
<span class="sd">    non_decreasing : Less stringent increasing check, allows equal values.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="non_decreasing"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.non_decreasing">[docs]</a><span class="k">def</span> <span class="nf">non_decreasing</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks all x[i+1] &gt;= x[i]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1d array</span>
<span class="sd">        Series of x values</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : True/False</span>
<span class="sd">        True if each x value is greater than or equal to the preceeding value.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    strictly_increasing : Check for increasing values, no equality allowed</span>
<span class="sd">    strictly_decreasing : Check for decreasing values, no equality allowed</span>
<span class="sd">    non_increasing : Less stringent decreasing check, allows equal values</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="non_increasing_and_non_decreasing_parts"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.non_increasing_and_non_decreasing_parts">[docs]</a><span class="k">def</span> <span class="nf">non_increasing_and_non_decreasing_parts</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">include_end_point</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Indexes of each non-increasing and non-decreasing section of a list</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : list or 1d array</span>
<span class="sd">        List of values.</span>
<span class="sd">    include_end_point : True/False, optional</span>
<span class="sd">        If True then the index of the last point in a non-increasing or</span>
<span class="sd">        non-decreasing run is included.  Default include_end_point=False, i.e.</span>
<span class="sd">        only the start index of each line segment is given.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    A : list of list</span>
<span class="sd">        Each element of A is a list of the start indices of each line</span>
<span class="sd">        segment that is part of a particular non-increasing or non-decreasing</span>
<span class="sd">        run.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This funciton only returns start indices for each line segment.</span>
<span class="sd">    Lets say x is [0, 4 , 5.5] then A will be [[0,1]].  If you do x[A[0]] then</span>
<span class="sd">    you will get [0, 4] i.e. no end point. To get the whole increasing or</span>
<span class="sd">    decreasing portion including the end point you need to do something like</span>
<span class="sd">    x[A[0].append[A[0][-1]+1]].</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#TODO: maybe return slice object rather than a list of all the indexes as they will be contiguous anyway</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">sign_changes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="n">current_sign</span> <span class="o">=</span> <span class="n">sign_changes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sign_changes</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sgn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sign_changes</span><span class="o">.</span><span class="n">tolist</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">sgn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">sgn</span> <span class="o">!=</span> <span class="n">current_sign</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">include_end_point</span><span class="p">:</span>
                <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="n">current_sign</span> <span class="o">=</span> <span class="n">sgn</span>
        <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_end_point</span><span class="p">:</span> <span class="c1">#append final end point</span>
        <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">A</span></div>


<div class="viewcode-block" id="force_strictly_increasing"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.force_strictly_increasing">[docs]</a><span class="k">def</span> <span class="nf">force_strictly_increasing</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">keep_end_points</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-15</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Force a non-decreasing or non-increasing list to be strictly increasing</span>

<span class="sd">    Adds or subtracts tiny amounts (multiples of `eps`) from the x values in</span>
<span class="sd">    step changes to ensure no two consecutive x values are equal (i.e. make x</span>
<span class="sd">    strictly increasing).  The adjustments are small enough that for all</span>
<span class="sd">    intents and purposes the data behaves as before; it can now however be</span>
<span class="sd">    easily used in straightforward interpolation functions that require</span>
<span class="sd">    strictly increasing x data.</span>

<span class="sd">    Any data where x is non-increasing will be reversed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        List of x coordinates.</span>
<span class="sd">    y : array_like, optional</span>
<span class="sd">        List of y coordinates, (Default y=None, if known that x is</span>
<span class="sd">        non-decreasing then y will not be affected).</span>
<span class="sd">    keep_end_points : ``boolean``, optional</span>
<span class="sd">        Determines which x value of the step change is adjusted.</span>
<span class="sd">        Consider x=[1,1] and y=[20,40]. If keep_end_points==True then new</span>
<span class="sd">        data will be x=[0.9999,1], y=[20,40].  If keep_end_points==False then</span>
<span class="sd">        data will be x=[1, 1.0001], y=[20,40]</span>
<span class="sd">    eps : float, optional</span>
<span class="sd">        Amount to add/subtract from x (default is 1e-15).  To ensure</span>
<span class="sd">        consecutive step changes are handled correctly multipes of `eps`</span>
<span class="sd">        will be added and subtracted. e.g. if there are a total of five</span>
<span class="sd">        steps in the data then the first step would get 5*`eps` adjustment,</span>
<span class="sd">        the second step 4*`eps` adjustment and so on.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">strictly_increasing</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

    <span class="k">if</span> <span class="n">strictly_decreasing</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">non_increasing</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">non_decreasing</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x data is neither non-increasing, nor non-decreasing, therefore cannot force to strictly increasing&quot;</span><span class="p">)</span>


    <span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">keep_end_points</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">eps</span>
        <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">steps</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">eps</span>
        <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span>

    <span class="n">x</span><span class="p">[</span><span class="n">steps</span> <span class="o">+</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">steps</span> <span class="o">+</span> <span class="n">d</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span></div>


<div class="viewcode-block" id="force_non_decreasing"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.force_non_decreasing">[docs]</a><span class="k">def</span> <span class="nf">force_non_decreasing</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Force non-increasing x, y data to non_decreasing by reversing the data</span>

<span class="sd">    Leaves already non-decreasing data alone.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y: array_like</span>
<span class="sd">        x and y coordinates</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x, y : 1d ndarray, 1d ndarray</span>
<span class="sd">        Non-decreasing version of x, y</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">non_decreasing</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">non_increasing</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x data is neither non-increasing, nor non-decreasing, therefore cannot force to non-decreasing&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="start_index_of_ramps"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.start_index_of_ramps">[docs]</a><span class="k">def</span> <span class="nf">start_index_of_ramps</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the start indices of the ramp line segments in x, y data.</span>

<span class="sd">    An example of a &#39;ramp&#39; x=[0,2], y=[10,15]. i.e. not a vertical line and</span>
<span class="sd">    not a horizontal line.</span>

<span class="sd">    Assumes data is non_decreasing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y : array_like</span>
<span class="sd">        x and y coords (must be non-decreasing).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : 1d ndarray</span>
<span class="sd">        Start indices of all ramps.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>


    <span class="k">return</span>  <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="start_index_of_constants"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.start_index_of_constants">[docs]</a><span class="k">def</span> <span class="nf">start_index_of_constants</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the start indices of the constant line-segments in x, y data.</span>

<span class="sd">    An example of a &#39;constant&#39; x=[0,2], y=[15,15]. i.e. a horizontal line</span>

<span class="sd">    Assumes data is non_decreasing.</span>

<span class="sd">    Segments such as x=[1,1], y=[2,2] are ignored.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y : array_like</span>
<span class="sd">        x and y coords (must be non-decreasing).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : 1d ndarray</span>
<span class="sd">        Start indices of all constant segments.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>


    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="start_index_of_steps"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.start_index_of_steps">[docs]</a><span class="k">def</span> <span class="nf">start_index_of_steps</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the start indices of the step line-segments in x, y data.</span>

<span class="sd">    An example of a &#39;step&#39; x=[0, 0], y=[10, 15]. i.e. a vertical line.</span>

<span class="sd">    Assumes data is non_decreasing.</span>

<span class="sd">    Segments such as x=[1, 1], y=[2, 2] are ignored.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y : array_like</span>
<span class="sd">        x and y coords (must be non-decreasing)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : 1d ndarray</span>
<span class="sd">        Start indices of all step segments.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>


    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="segment_containing_xi"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.segment_containing_xi">[docs]</a><span class="k">def</span> <span class="nf">segment_containing_xi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">choose_max</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find start index of line segment in which xi falls</span>

<span class="sd">    Find index where x[i] &lt;= xi &lt;= x[i+1] ignoring steps. `choose_max`</span>
<span class="sd">    determines what happens when more than one segment satisfies the</span>
<span class="sd">    condition e.g. the boundary between two segments; taking either the</span>
<span class="sd">    maximum index (`choose_max` True), or the minimum index (`choose_max`=</span>
<span class="sd">    False).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like, float</span>
<span class="sd">        x coordinates.</span>
<span class="sd">    xi : array_like, float</span>
<span class="sd">        Values to place in segments.</span>
<span class="sd">    subset : array_like, optional</span>
<span class="sd">        Restrict search to segments starting with indices in `subset`.</span>
<span class="sd">        Default subset=None i.e.  search all segments.</span>
<span class="sd">    choose_max : boolean, optional</span>
<span class="sd">        When False (default), the minumum index that satisfies the condition</span>
<span class="sd">        is returned. When True the maximum index that satisfies the condition</span>
<span class="sd">        is returned. Default choose_max=False. See Notes below</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : list of single element lists</span>
<span class="sd">        Each sub-list is the start index of the segment that contains xi.</span>
<span class="sd">        Returning each value in a list allows &quot;for i in A[0]&quot; type constructs</span>
<span class="sd">        which for an empty list will do nothing.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If x data has switch backs (i.e. not non-decreasing and not non-increasing)</span>
<span class="sd">    then if `choose_max` = True then the index returned will be in the last</span>
<span class="sd">    group of segments.  This can be useful as when determining when something</span>
<span class="sd">    ends. e.g. say x are strictly incresing time values and y zig zags up and</span>
<span class="sd">    down for a time then decays to zero.  A regular interpolation will give</span>
<span class="sd">    you any y value at a given x value.  But you might want to answer a</span>
<span class="sd">    question such as &#39;at what time does y finally fall below 10&#39;.  You want</span>
<span class="sd">    to search only the last decaying section.  By plugging the y values in as</span>
<span class="sd">    `x` and using `choose_max` = True, you will get the segment where this</span>
<span class="sd">    happens.</span>

<span class="sd">    This function is somewhat similar to the `numpy.digitize` function that</span>
<span class="sd">    places x values into bins. `segment_containing_xi` however, does not insist</span>
<span class="sd">    on monotonic data and won&#39;t break down if steps are included; it is also</span>
<span class="sd">    possible to put both bounds in the same segement. Say for x = [0,1,2,3] and</span>
<span class="sd">    xi1 = 1 and xi2 = 2.  If `choose_max` is False for both points then xi1</span>
<span class="sd">    will be in segment 0, and xi2 in segment 1.  But if you use `choose_max` =</span>
<span class="sd">    True for xi1 then it be in segment 1 (the same as xi2).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
<span class="c1">#    if isinstance(xi, numbers.Number):</span>
<span class="c1">#        xi = np.array([xi])</span>
<span class="c1">#    xi = np.asarray(xi)</span>

    <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#subset isempty</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">xi</span><span class="p">]</span>

    <span class="n">subset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span>
    <span class="c1">#this commented one doesn&#39;t work for descending</span>
    <span class="c1">#A = [subset[(v&gt;=x[subset]) &amp; (v&lt;=x[subset+1]) &amp; (x[subset]!=x[subset+1])] for v in xi]</span>

    <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="n">subset</span><span class="p">[(</span><span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">subset</span><span class="p">])</span><span class="o">&lt;=</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">subset</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">subset</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">subset</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">&lt;=</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">subset</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">subset</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">subset</span><span class="p">]</span><span class="o">!=</span><span class="n">x</span><span class="p">[</span><span class="n">subset</span><span class="o">+</span><span class="mi">1</span><span class="p">])]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">xi</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">choose_max</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">size</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="n">f</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">return</span> <span class="n">A</span></div>


<div class="viewcode-block" id="segments_less_than_xi"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.segments_less_than_xi">[docs]</a><span class="k">def</span> <span class="nf">segments_less_than_xi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">or_equal_to</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find start index of line segments that end before xi</span>

<span class="sd">    Finds all segments where end point of segment is less than xi.</span>

<span class="sd">    Assumes non-decreasing `x` data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like, float</span>
<span class="sd">        x coordinates.</span>
<span class="sd">    xi : array_like, float</span>
<span class="sd">        Values to check if segments start after.</span>
<span class="sd">    subset : array_like, optional</span>
<span class="sd">        Restrict search to segments starting with indices in `subset`.</span>
<span class="sd">        Default subset=None, which searches all segments.</span>
<span class="sd">    or_equal_to : ``boolean``, optional</span>
<span class="sd">        If False (default) then conditon is formulated with &#39;&lt;&#39;.  If True</span>
<span class="sd">        then condition is formulated with &#39;&lt;=&#39;. Generally only used to</span>
<span class="sd">        include/exclude step loads.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : list of 1d numpy.ndarray</span>
<span class="sd">        List contains len(xi) 1d numpy.ndarray corresponding to xi.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>





    <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>


    <span class="n">subset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">or_equal_to</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">subset</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">subset</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">xi</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">subset</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">subset</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">xi</span><span class="p">]</span></div>


<div class="viewcode-block" id="ramps_constants_steps"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.ramps_constants_steps">[docs]</a><span class="k">def</span> <span class="nf">ramps_constants_steps</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the ramp, constant, and step line segments in x, y data</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ramps : 1d ndarray</span>
<span class="sd">        `start_index_of_ramps`</span>
<span class="sd">    constants : 1d ndarray</span>
<span class="sd">        `start_index_of_constants`</span>
<span class="sd">    steps : 1d ndarray</span>
<span class="sd">        `start_index_of_constants`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    start_index_of_ramps : Find ramps.</span>
<span class="sd">    start_index_of_steps : Find steps.</span>
<span class="sd">    start_index_of_constants : Find constants.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="n">ramps</span> <span class="o">=</span> <span class="n">start_index_of_ramps</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
    <span class="n">constants</span> <span class="o">=</span> <span class="n">start_index_of_constants</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
    <span class="n">steps</span> <span class="o">=</span> <span class="n">start_index_of_steps</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">ramps</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span></div>


<div class="viewcode-block" id="segment_containing_also_segments_less_than_xi"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.segment_containing_also_segments_less_than_xi">[docs]</a><span class="k">def</span> <span class="nf">segment_containing_also_segments_less_than_xi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span>
                                                  <span class="n">steps_or_equal_to</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">ramp_const_or_equal_to</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                  <span class="n">choose_max</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine ramp, constant and step segments containing xi as well as</span>
<span class="sd">    segments less than xi.</span>

<span class="sd">    Function does minimal calculations itself, essentially calling other</span>
<span class="sd">    functions and returning a tuple.  Useful for piecewise linear loading</span>
<span class="sd">    functions when you segements after a certain time are irrelevant.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y : array_like</span>
<span class="sd">        x and y coords (must be non-decreasing).</span>
<span class="sd">    xi : array_like, float</span>
<span class="sd">        Values to check check segments against.</span>
<span class="sd">    steps_or_equal_to : ``boolean``, optional</span>
<span class="sd">        If True (default) then any step segment that xi falls on/in will be</span>
<span class="sd">        included in the steps &#39;less than&#39; list.</span>
<span class="sd">    ramp_const_or_equal_to : ``boolean``, optional</span>
<span class="sd">        If False (default) then any ramp or constant segment that xi falls</span>
<span class="sd">        on the start will not be included in the ramps and constants</span>
<span class="sd">        &#39;less than&#39; list.</span>
<span class="sd">    choose_max : ``boolean``, optional</span>
<span class="sd">        If False (default), then the minimum segment of multiple ramp segments</span>
<span class="sd">        that contain xi falls will be included in the &#39;contains&#39; lists.</span>
<span class="sd">        If True then the maximum segment will be included.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ramps_less_than_xi : ndarray</span>
<span class="sd">        `segments_less_than_xi` for ramps.</span>
<span class="sd">    constants_less_than_xi : ndarray</span>
<span class="sd">        `segments_less_than_xi` for constants.</span>
<span class="sd">    steps_less_than_xi : ndarray</span>
<span class="sd">        `segments_less_than_xi` for steps.</span>
<span class="sd">    ramps_containing_xi : ndarray</span>
<span class="sd">        Start index of ramp segment containing xi.</span>
<span class="sd">    constants_containing_xi : ndarray</span>
<span class="sd">        Start index of constant segment containing xi.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ramps_constants_steps : find ramp, constant, and step segments</span>
<span class="sd">    segments_less_than_xi : find segments after xi</span>
<span class="sd">    segment_containing_xi : find segments that contain xi</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>


    <span class="n">ramps</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">steps</span> <span class="o">=</span> <span class="n">ramps_constants_steps</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>

    <span class="n">ramps_less_than_xi</span> <span class="o">=</span> <span class="n">segments_less_than_xi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span>
                                           <span class="n">subset</span><span class="o">=</span><span class="n">ramps</span><span class="p">,</span>
                                           <span class="n">or_equal_to</span><span class="o">=</span><span class="n">ramp_const_or_equal_to</span><span class="p">)</span>
    <span class="n">constants_less_than_xi</span> <span class="o">=</span> <span class="n">segments_less_than_xi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span>
                                           <span class="n">subset</span><span class="o">=</span><span class="n">constants</span><span class="p">,</span>
                                           <span class="n">or_equal_to</span><span class="o">=</span><span class="n">ramp_const_or_equal_to</span><span class="p">)</span>
    <span class="n">steps_less_than_xi</span> <span class="o">=</span> <span class="n">segments_less_than_xi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span>
                                           <span class="n">subset</span><span class="o">=</span><span class="n">steps</span><span class="p">,</span>
                                           <span class="n">or_equal_to</span><span class="o">=</span><span class="n">steps_or_equal_to</span><span class="p">)</span>

    <span class="c1"># the temptation to call segment_containing_xi here with subset=ramps and then subset=constants might lead to xi being in both a ramp or a constant</span>
    <span class="n">contains</span> <span class="o">=</span> <span class="n">segment_containing_xi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">choose_max</span><span class="o">=</span><span class="n">choose_max</span><span class="p">)</span>
    <span class="n">ramps_containing_xi</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
    <span class="n">constants_containing_xi</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">contains</span><span class="p">):</span> <span class="c1">#decide when xi falls on edge of segment wether it is in a ramp or a constant segment</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span> <span class="c1">#this will skip empty arrays</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ramps</span><span class="p">:</span>
                <span class="n">ramps_containing_xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">constants_containing_xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">ramps_less_than_xi</span><span class="p">,</span> <span class="n">constants_less_than_xi</span><span class="p">,</span> <span class="n">steps_less_than_xi</span><span class="p">,</span>
            <span class="n">ramps_containing_xi</span><span class="p">,</span> <span class="n">constants_containing_xi</span><span class="p">)</span></div>


<div class="viewcode-block" id="segment_containing_xi_also_containing_xj"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.segment_containing_xi_also_containing_xj">[docs]</a><span class="k">def</span> <span class="nf">segment_containing_xi_also_containing_xj</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find start index of segments that xi and xj fall in trying to have</span>
<span class="sd">    them in the same section.</span>

<span class="sd">    Find highest i where x[i] &lt;= xi &lt;= x[i+1] ignoring steps.</span>
<span class="sd">    Find lowest j where  x[j] &lt;= xj &lt;= x[j+1] ignoring steps.</span>
<span class="sd">    This will minimise the number of segments between xi and xj.</span>
<span class="sd">    Usually xj should be greater than xi.</span>

<span class="sd">    Function does no calculations itself, rather calling segment_containing_xi</span>
<span class="sd">    twice and returning a tuple.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like, float</span>
<span class="sd">        x coordinates.</span>
<span class="sd">    xi, xj : array_like, float</span>
<span class="sd">        x values to from which to determin containing segment.</span>
<span class="sd">    subset : array_like, optional</span>
<span class="sd">        Restrict search to segments starting with indices in `subset`.</span>
<span class="sd">        Default subset=None which searches all segments.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    seg_xi, seg_xj : list of single element lists</span>
<span class="sd">        Each sub-list is the start index of the segement that contains</span>
<span class="sd">        xi or xj.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    segments_containing_xi : Function called for `xi` and `xj`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="c1">#commented code may provide minimal speed up</span>
<span class="c1">#    x = np.asarray(x)</span>
<span class="c1">#</span>
<span class="c1">#    if isinstance(xi, numbers.Number):</span>
<span class="c1">#        xi = np.array([xi])</span>
<span class="c1">#    xi = np.asarray(xi)</span>
<span class="c1">#</span>
<span class="c1">#    if isinstance(xj, numbers.Number):</span>
<span class="c1">#        xj = np.array([xj])</span>
<span class="c1">#    xj = np.asarray(xj)</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#    if subset is None:</span>
<span class="c1">#        subset = np.arange(len(x)-1)</span>
<span class="c1">#    if len(subset)==0: #subset isempty</span>
<span class="c1">#        return ([np.array([],dtype = int) for v in xi], [np.array([],dtype = int) for v in xi])</span>
<span class="c1">#</span>
<span class="c1">#    subset = np.asarray(subset)</span>


    <span class="k">return</span> <span class="p">(</span><span class="n">segment_containing_xi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">subset</span><span class="p">,</span> <span class="n">choose_max</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">segment_containing_xi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xj</span><span class="p">,</span> <span class="n">subset</span><span class="p">,</span> <span class="n">choose_max</span> <span class="o">=</span> <span class="kc">False</span><span class="p">))</span></div>


<div class="viewcode-block" id="segments_between_xi_and_xj"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.segments_between_xi_and_xj">[docs]</a><span class="k">def</span> <span class="nf">segments_between_xi_and_xj</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find line segments that exclusively contain both, only one of, and</span>
<span class="sd">    in between xi and xj.</span>

<span class="sd">    Determine if xi and xj are both in the same segment.</span>
<span class="sd">    When xi and xj are in different segments find the segment that contains xi</span>
<span class="sd">    and the segment that contains xj and any segments in between them.</span>
<span class="sd">    Results are only obvious when x is strictly increasing and xi&lt;xj.</span>

<span class="sd">    This is useful when integrating between two points; the integration limits</span>
<span class="sd">    in each relevant segment are different.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like, float</span>
<span class="sd">        x coordinates</span>
<span class="sd">    xi, xj : array_like, float</span>
<span class="sd">        x values to from which to determine segments.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    segment_both : list of single element lists</span>
<span class="sd">        Each sub-list is the start index of the segment that contains</span>
<span class="sd">        xi or xj.</span>
<span class="sd">    segment_xi_only : list of single element lists</span>
<span class="sd">        When xi and xj not in the same segment, segment_xi_only will be the</span>
<span class="sd">        segment that contains xi.</span>
<span class="sd">    segment_xj_only : list of single element lists</span>
<span class="sd">        When xi and xj not in the same segment, segment_xj_only will be the</span>
<span class="sd">        segment that contains xj.</span>
<span class="sd">    segments_between : list of single element lists</span>
<span class="sd">        When xi and xj not in the same segment, segments_between will be the</span>
<span class="sd">        segments in between xi and xj but not containing xi or xj.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    segment_containing_xi_also_containing_xj : Find segment of xi and xj.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ix1</span><span class="p">,</span> <span class="n">ix2</span> <span class="o">=</span> <span class="n">segment_containing_xi_also_containing_xj</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">xj</span><span class="p">)</span>

    <span class="n">segment_both</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ix1</span><span class="p">]</span>
    <span class="n">segment_xi_only</span> <span class="o">=</span> <span class="n">segment_both</span><span class="p">[:]</span>
    <span class="n">segment_xj_only</span> <span class="o">=</span> <span class="n">segment_both</span><span class="p">[:]</span>
    <span class="n">segments_between</span> <span class="o">=</span> <span class="n">segment_both</span><span class="p">[:]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ix1</span><span class="p">,</span><span class="n">ix2</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">i2</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">i2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">segment_both</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">segment_both</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="c1">#            np.insert(segment_both[i],0,i1[0])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">segment_xi_only</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">segment_xi_only</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">segment_xj_only</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">segment_xj_only</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="n">i2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">segments_between</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i2</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="c1">#            np.insert(segment_xi_only[i],0,i1[0])</span>
<span class="c1">#            np.insert(segment_xj_only[i],0,i2[0])</span>
<span class="c1">#            segments_between[i]=np.r_[i1[0]+1:i2[0]]</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">segment_both</span><span class="p">,</span> <span class="n">segment_xi_only</span><span class="p">,</span> <span class="n">segment_xj_only</span><span class="p">,</span> <span class="n">segments_between</span><span class="p">)</span></div>


<div class="viewcode-block" id="convert_x1_x2_y1_y2_to_x_y"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.convert_x1_x2_y1_y2_to_x_y">[docs]</a><span class="k">def</span> <span class="nf">convert_x1_x2_y1_y2_to_x_y</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert data defined at start and end of each segment to a line of data</span>

<span class="sd">    x1_x2_y1_y2 data is defined by x1[1:]==x2[:-1]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, y1 : array_like, float</span>
<span class="sd">        x and y values at start of each segment.</span>
<span class="sd">    x2, y2 : array_like, float</span>
<span class="sd">        x and y values at end of each segment (note x1[1:]==x2[:-1]).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x, y : 1d ndarray, float</span>
<span class="sd">        x and y data of continuous line that matches the x1_x2_y1_y2 data.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    convert_x_y_to_x1_x2_y1_y2 : Reverse of this function.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Graphs showing x1_x2_y1_y2 data and x_y data are shown below.</span>

<span class="sd">    ::</span>

<span class="sd">        x1_x2_y1_y2 type data</span>
<span class="sd">        y                                              y2[2]</span>
<span class="sd">        ^                                             /|</span>
<span class="sd">        |                                            / |</span>
<span class="sd">        |                           y2[0]           /  |</span>
<span class="sd">        |                          /|              /   |</span>
<span class="sd">        |                         / |       y1[2] /    |</span>
<span class="sd">        |                        /  |            |     |</span>
<span class="sd">        |                       /   |y1[1]  y2[1]|     |</span>
<span class="sd">        |                 y1[0]/    |------------|     |</span>
<span class="sd">        |                     | (0) |     (1)    | (2) |</span>
<span class="sd">        |                     |     |            |     |</span>
<span class="sd">        |-----------------------------------------------------------&gt;x</span>
<span class="sd">                            x1[0] x1[1]        x1[2]</span>
<span class="sd">                                  x2[0]        x2[1] x2[2]</span>

<span class="sd">        e.g. x1 = [0.0, 0.3, 0.7], y1 = [1, 1, 2]</span>
<span class="sd">             x2 = [0.3, 0.7, 1.0], y2 = [3, 1, 4]</span>

<span class="sd">        x_y_data</span>
<span class="sd">        y                                              y[5]</span>
<span class="sd">        ^                                             /|</span>
<span class="sd">        |                                            / |</span>
<span class="sd">        |                           y[1]            /  |</span>
<span class="sd">        |                          /|              /   |</span>
<span class="sd">        |                         / |         y[4]/    |</span>
<span class="sd">        |                        /  |            |     |</span>
<span class="sd">        |                       /   |y[2]    y[3]|     |</span>
<span class="sd">        |                  y[0]/    |------------|     |</span>
<span class="sd">        |                     |     |            |     |</span>
<span class="sd">        |                     |     |            |     |</span>
<span class="sd">        |-----------------------------------------------------------&gt;x</span>
<span class="sd">                            x[0]   x[1]         x[3]  x[5]</span>
<span class="sd">                                   x[2]         x[4]</span>

<span class="sd">        e.g. x = [0.0, 0.3, 0.3, 0.7, 0.7, 1.0]</span>
<span class="sd">             y = [1.0, 3.0, 1.0, 1.0, 2.0, 4.0]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#TODO: include an option to collapse segments where step changes are tiny</span>
    <span class="c1">#and where consecutive segments lie on a straight line see np.allclose with</span>
    <span class="c1">#atol and rtol.  Maybe collapse close steps first and then check for #</span>
    <span class="c1">#straight lines. probably better to do it in a separate function e.g.</span>
    <span class="c1">#def tidy_up_x1_x2_y1_y2() and tidy_up_x_y().</span>


    <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x2</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x1, x2, y1, y2 must be of same length&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">x2</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;data is not x1_x2_y1_y2, i.e. x1[1:] != x2[:-1]&quot;</span><span class="p">)</span>





    <span class="n">x</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[:]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y1</span><span class="p">[:]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>


    <span class="n">insert_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y2</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="n">y1</span><span class="p">[</span><span class="mi">1</span><span class="p">:])[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">insert_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x2</span><span class="p">[</span><span class="n">insert_index</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">insert_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y2</span><span class="p">[</span><span class="n">insert_index</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span></div>


<div class="viewcode-block" id="convert_x_y_to_x1_x2_y1_y2"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.convert_x_y_to_x1_x2_y1_y2">[docs]</a><span class="k">def</span> <span class="nf">convert_x_y_to_x1_x2_y1_y2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a line of data to data defined at start and end of each segment</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, y1 : array_like, float</span>
<span class="sd">        x and y values at start of each segment.</span>
<span class="sd">    x2, y2 : array_like, float</span>
<span class="sd">        x and y values at end of each segment (note x1[1:]==x2[:-1]).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x1, y1 : 1d array, float</span>
<span class="sd">        x and y values at start of each segment.</span>
<span class="sd">    x2, y2 : 1d array, float</span>
<span class="sd">        x and y values at end of each segment (note x1[1:]==x2[:-1]).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    convert_x1_x2_y1_y2_to_x_y : Reverse of this function.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Graphs showing x1_x2_y1_y2 data and x_y data are shown below.</span>

<span class="sd">    ::</span>



<span class="sd">        x_y_data</span>
<span class="sd">        y                                              y[5]</span>
<span class="sd">        ^                                             /|</span>
<span class="sd">        |                                            / |</span>
<span class="sd">        |                           y[1]            /  |</span>
<span class="sd">        |                          /|              /   |</span>
<span class="sd">        |                         / |         y[4]/    |</span>
<span class="sd">        |                        /  |            |     |</span>
<span class="sd">        |                       /   |y[2]    y[3]|     |</span>
<span class="sd">        |                  y[0]/    |------------|     |</span>
<span class="sd">        |                     |     |            |     |</span>
<span class="sd">        |                     |     |            |     |</span>
<span class="sd">        |-----------------------------------------------------------&gt;x</span>
<span class="sd">                            x[0]   x[1]         x[3]  x[5]</span>
<span class="sd">                                   x[2]         x[4]</span>

<span class="sd">        e.g. x = [0.0, 0.3, 0.3, 0.7, 0.7, 1.0]</span>
<span class="sd">             y = [1.0, 3.0, 1.0, 1.0, 2.0, 4.0]</span>

<span class="sd">        x1_x2_y1_y2 type data</span>
<span class="sd">        y                                              y2[2]</span>
<span class="sd">        ^                                             /|</span>
<span class="sd">        |                                            / |</span>
<span class="sd">        |                           y2[0]           /  |</span>
<span class="sd">        |                          /|              /   |</span>
<span class="sd">        |                         / |       y1[2] /    |</span>
<span class="sd">        |                        /  |            |     |</span>
<span class="sd">        |                       /   |y1[1]  y2[1]|     |</span>
<span class="sd">        |                 y1[0]/    |------------|     |</span>
<span class="sd">        |                     | (0) |     (1)    | (2) |</span>
<span class="sd">        |                     |     |            |     |</span>
<span class="sd">        |-----------------------------------------------------------&gt;x</span>
<span class="sd">                            x1[0] x1[1]        x1[2]</span>
<span class="sd">                                  x2[0]        x2[1] x2[2]</span>

<span class="sd">        e.g. x1 = [0.0, 0.3, 0.7], y1 = [1, 1, 2]</span>
<span class="sd">             x2 = [0.3, 0.7, 1.0], y2 = [3, 1, 4]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#TODO: include an option to collapse segments where step changes are tiny</span>
    <span class="c1">#and where consecutive segments lie on a straight line see np.allclose with</span>
    <span class="c1">#atol and rtol.  Maybe collapse close steps first and then check for #</span>
    <span class="c1">#straight lines. probably better to do it in a separate function e.g.</span>
    <span class="c1">#def tidy_up_x1_x2_y1_y2() and tidy_up_x_y().</span>


    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and y must be of same length&quot;</span><span class="p">)</span>

    <span class="n">segs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:])[</span><span class="mi">0</span><span class="p">]</span>



    <span class="n">x1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">segs</span><span class="p">]</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">segs</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">segs</span><span class="p">]</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">segs</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span></div>


<div class="viewcode-block" id="pinterp_x1_x2_y1_y2"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.pinterp_x1_x2_y1_y2">[docs]</a><span class="k">def</span> <span class="nf">pinterp_x1_x2_y1_y2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Linear interpolation using PolyLine; wrapper for interp_x1_x2_y1_y2.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : PolyLine object</span>
<span class="sd">        PolyLine to interpolate from.</span>
<span class="sd">    xi : float, 1d array of float</span>
<span class="sd">        Values to interpolate at.</span>
<span class="sd">    **kwargs : keyword arguments</span>
<span class="sd">        Keyword arguments will be passed through `interp_x1_x2_y1_y2`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : 1d ndarray, float</span>
<span class="sd">        Interpolated y value corresponding to xi</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    interp_x1_x2_y1_y2 : Wrapped function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">interp_x1_x2_y1_y2</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y2</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="interp_x1_x2_y1_y2"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.interp_x1_x2_y1_y2">[docs]</a><span class="k">def</span> <span class="nf">interp_x1_x2_y1_y2</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">choose_max</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Linear interpolation of x1_x2_y1_y2 data</span>

<span class="sd">    x1_x2_y1_y2 data is defined by x1[1:]==x2[:-1]</span>
<span class="sd">    if xi is beyond bounds of x then the first or last value of y will be</span>
<span class="sd">    returned as appropriate</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, y1 : array_like, float</span>
<span class="sd">        x and y values at start of each segment</span>
<span class="sd">    x2, y2 : array_like, float</span>
<span class="sd">        x and y values at end of each segment (note x1[1:]==x2[:-1])</span>
<span class="sd">    xi : array_like, float</span>
<span class="sd">        x values to interpolate at</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : 1d ndarray, float</span>
<span class="sd">        Interpolated y value corresponding to xi.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x2</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x1, x2, y1, y2 must be of same length&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">x2</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;data is not x1_x2_y1_y2, i.e. x1[1:] != x2[:-1]&quot;</span><span class="p">)</span>

    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
<span class="c1">#    if isinstance(xi, numbers.Number):</span>
<span class="c1">#        xi = np.array([xi])</span>
<span class="c1">#    xi = np.asarray(xi)</span>

    <span class="n">segs</span> <span class="o">=</span> <span class="n">segment_containing_xi</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">xi</span><span class="p">,</span> <span class="n">subset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">choose_max</span> <span class="o">=</span> <span class="n">choose_max</span><span class="p">)</span>


    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">))</span>
    <span class="c1">#mask = np.logical_not(map(len,segs))</span>


    <span class="c1">#A = [[] for v in segs]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segs</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">y2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">y1</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span><span class="nb">abs</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span> <span class="c1">#xi[i] beyond 1st value</span>
                <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">y1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#xi[i] is beyond last value</span>
                <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">y2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">A</span></div>


<div class="viewcode-block" id="pinterp_x_y"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.pinterp_x_y">[docs]</a><span class="k">def</span> <span class="nf">pinterp_x_y</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Linear interpolation using PolyLine; wrapper for interp_x_y.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : PolyLine object</span>
<span class="sd">        PolyLine to interpolate from.</span>
<span class="sd">    xi : float, 1d array of float</span>
<span class="sd">        Values to interpolate at.</span>
<span class="sd">    **kwargs : keyword arguments</span>
<span class="sd">        Keyword arguments will be passed through `interp_x_y`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : 1d ndarray, float</span>
<span class="sd">        Interpolated y value corresponding to xi</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    interp_x_y : Wrapped function.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">interp_x_y</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="interp_x_y"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.interp_x_y">[docs]</a><span class="k">def</span> <span class="nf">interp_x_y</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span> <span class="n">choose_max</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Linear interpolation of x_y data</span>


<span class="sd">    If xi is beyond bounds of x then the first or last value of y will be</span>
<span class="sd">    returned as appropriate.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y : array_like, float</span>
<span class="sd">        x and y values.</span>
<span class="sd">    xi : array_like, float</span>
<span class="sd">        x values to interpolate at.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : 1d ndarray, float</span>
<span class="sd">        Interpolated y value corresponding to xi.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>



    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and y must be of same length&quot;</span><span class="p">)</span>



    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
<span class="c1">#    if isinstance(xi, numbers.Number):</span>
<span class="c1">#        xi = np.array([xi])</span>
<span class="c1">#    xi = np.asarray(xi)</span>

    <span class="n">segs</span> <span class="o">=</span> <span class="n">segment_containing_xi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">choose_max</span><span class="o">=</span><span class="n">choose_max</span><span class="p">)</span>


    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">))</span>
    <span class="c1">#mask = np.logical_not(map(len,segs))</span>


    <span class="c1">#A = [[] for v in segs]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segs</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span> <span class="c1">#xi[i] beyond 1st value</span>
                <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#xi[i] is beyond last value</span>
                <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">A</span></div>


<div class="viewcode-block" id="remove_superfluous_from_x_y"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.remove_superfluous_from_x_y">[docs]</a><span class="k">def</span> <span class="nf">remove_superfluous_from_x_y</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Remove points that are on a line between other points</span>

<span class="sd">    Intermediate points are judged to be &#39;on a line&#39; and therefore superfluous</span>
<span class="sd">    when the distance of the point from the line is below `atol`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y : 1d array_like, float</span>
<span class="sd">        x and y values.</span>
<span class="sd">    atol : float, optional</span>
<span class="sd">        atol is the threshold. Default atol=1e-8.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xnew, ynew : 1d ndarray, float</span>
<span class="sd">        Cleaned up x and y values.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    #TODO: put in equation for distance of point to a line from wolfram http://mathworld.wolfram.com/Point-LineDistance2-Dimensional.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and y must be of sam length, &quot;</span>
                         <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> vs </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

    <span class="n">ikeep</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>


    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
        <span class="n">x1</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">y1</span><span class="o">=</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">x1</span><span class="o">-</span><span class="n">x0</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">y1</span><span class="o">-</span><span class="n">y0</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">dy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">ikeep</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">di</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">dx</span><span class="o">*</span><span class="p">(</span><span class="n">y0</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">])</span><span class="o">-</span><span class="n">dy</span><span class="o">*</span><span class="p">(</span><span class="n">x0</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">]))</span><span class="o">/</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">di</span><span class="o">&gt;</span><span class="n">atol</span><span class="p">):</span> <span class="c1">#points not on line anymore</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1">#points on line</span>
            <span class="n">ikeep</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">ikeep</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">ikeep</span><span class="p">]</span></div>


<div class="viewcode-block" id="pinterp_xa_ya_multipy_x1b_x2b_y1b_y2b"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.pinterp_xa_ya_multipy_x1b_x2b_y1b_y2b">[docs]</a><span class="k">def</span> <span class="nf">pinterp_xa_ya_multipy_x1b_x2b_y1b_y2b</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">xai</span><span class="p">,</span> <span class="n">xbi</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interpolate a composite function made of two PolyLines; wrapper for</span>
<span class="sd">    interp_xa_ya_multipy_x1b_x2b_y1b_y2b.</span>

<span class="sd">    Evaluate f(xai)*g(xbi) where f(xa) and f(xb) are defined by PolyLine</span>
<span class="sd">    objects.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : PolyLine objects</span>
<span class="sd">        PolyLine objects that make up the separable interpolation function</span>
<span class="sd">        a(xa) * b(xb)</span>
<span class="sd">        x and y values of x_y part of interpolation function.</span>
<span class="sd">    xai : array_like, float</span>
<span class="sd">        x values to interpolate at for a part</span>
<span class="sd">    xbi : array_like, float</span>
<span class="sd">        x values to interpolate at for b part</span>
<span class="sd">    achoose_max : ``boolean``, optional</span>
<span class="sd">        If False (default), if xai falls on boundary of segments choose the</span>
<span class="sd">        minimum segment to interpolate within.</span>
<span class="sd">    bchoose_max : ``boolean``, optional</span>
<span class="sd">        If True (default), if xbi falls on boundary of segments choose the</span>
<span class="sd">        maximum segment to interpolate within.</span>
<span class="sd">    **kwargs : keyword arguments</span>
<span class="sd">        Keyword arguments such as achoose_max and bchoose_max that will be</span>
<span class="sd">        passed through to interp_xa_ya_multipy_x1b_x2b_y1b_y2b.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    interp_xa_ya_multipy_x1b_x2b_y1b_y2b : Wrapped Function.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">interp_xa_ya_multipy_x1b_x2b_y1b_y2b</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">y2</span><span class="p">,</span> <span class="n">xai</span><span class="p">,</span> <span class="n">xbi</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="interp_xa_ya_multipy_x1b_x2b_y1b_y2b"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.interp_xa_ya_multipy_x1b_x2b_y1b_y2b">[docs]</a><span class="k">def</span> <span class="nf">interp_xa_ya_multipy_x1b_x2b_y1b_y2b</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">ya</span><span class="p">,</span>
                                         <span class="n">x1b</span><span class="p">,</span> <span class="n">x2b</span><span class="p">,</span> <span class="n">y1b</span><span class="p">,</span> <span class="n">y2b</span><span class="p">,</span>
                                         <span class="n">xai</span><span class="p">,</span> <span class="n">xbi</span><span class="p">,</span>
                                         <span class="n">achoose_max</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="n">bchoose_max</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interpolate a composite function made of x_y and x1b_x2b_y1b_y2b</span>
<span class="sd">    piecewise-linear representations.</span>

<span class="sd">    Evaluate f(xai)*g(xbi) where f(xa) is defined</span>
<span class="sd">    with x_y data and g(xb) is defined by x1_x2_y1_y2 data.</span>

<span class="sd">    Does little calculation, mostly calls other functions.</span>
<span class="sd">    Calculates array A[len(xbi),len(xai)]</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xa, ya : 1d array_like, float</span>
<span class="sd">        x and y values of x_y part of interpolation function.</span>
<span class="sd">    x1b, y1b : array_like, float</span>
<span class="sd">        x and y values at start of each segment for x1_x2_y1_y2 part of</span>
<span class="sd">        interpolation function</span>
<span class="sd">    x2b, y2b : array_like, float</span>
<span class="sd">        x and y values at end of each segment for x1_x2_y1_y2 part of</span>
<span class="sd">        interpolation function  (note x1[1:]==x2[:-1])</span>
<span class="sd">    xai : array_like, float</span>
<span class="sd">        x values to interpolate at for x_y part</span>
<span class="sd">    xbi : array_like, float</span>
<span class="sd">        x values to interpolate at for x1_x2_y1_y2 part</span>
<span class="sd">    achoose_max : ``boolean``, optional</span>
<span class="sd">        If False (default), if xai falls on boundary of segments choose the</span>
<span class="sd">        minimum segment to interpolate within.</span>
<span class="sd">    bchoose_max : ``boolean``, optional</span>
<span class="sd">        If True (default), if xbi falls on boundary of segments choose the</span>
<span class="sd">        maximum segment to interpolate within.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    interp_x_y : Interpolate the x_y part.</span>
<span class="sd">    interp_x1_x2_y1_y2 : Interpolate the x1_x2_y1_y2 part.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">yai</span> <span class="o">=</span> <span class="n">interp_x_y</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">ya</span><span class="p">,</span> <span class="n">xai</span><span class="p">,</span> <span class="n">choose_max</span><span class="o">=</span><span class="n">achoose_max</span><span class="p">)</span>
    <span class="n">ybi</span> <span class="o">=</span> <span class="n">interp_x1_x2_y1_y2</span><span class="p">(</span><span class="n">x1b</span><span class="p">,</span> <span class="n">x2b</span><span class="p">,</span> <span class="n">y1b</span><span class="p">,</span> <span class="n">y2b</span><span class="p">,</span> <span class="n">xbi</span><span class="p">,</span> <span class="n">choose_max</span><span class="o">=</span><span class="n">bchoose_max</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ybi</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">yai</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span></div>

<div class="viewcode-block" id="pavg_x_y_between_xi_xj"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.pavg_x_y_between_xi_xj">[docs]</a><span class="k">def</span> <span class="nf">pavg_x_y_between_xi_xj</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Average between xi and xj for PolyLine data; wrapper for</span>
<span class="sd">    avg_x_y_between_xi_xj.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : PolyLine object</span>
<span class="sd">        PolyLine containing data for averaging.</span>
<span class="sd">    xi, xj : array_like, float</span>
<span class="sd">        x values to interpolate between.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : 1d array of float</span>
<span class="sd">        Interpolated values. len(A)=len(xi)</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    avg_x_y_between_xi_xj : Wrapped function.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">avg_x_y_between_xi_xj</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="avg_x_y_between_xi_xj"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.avg_x_y_between_xi_xj">[docs]</a><span class="k">def</span> <span class="nf">avg_x_y_between_xi_xj</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Average between xi and xj piecewise-linear x_y data</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y : 1d array_like, float</span>
<span class="sd">        x and y values of x_y part of interpolation function.</span>

<span class="sd">    xi, xj : array_like, float</span>
<span class="sd">        x values to interpolate between.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : 1d array of float</span>
<span class="sd">        Interpolated values. len(A)=len(xi)</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    integrate_x_y_between_xi_xj : Integration is intemediate step in</span>
<span class="sd">        average calculation.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
    <span class="n">xj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">xj</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">integrate_x_y_between_xi_xj</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">xj</span> <span class="o">-</span> <span class="n">xi</span><span class="p">)</span></div>


<div class="viewcode-block" id="pintegrate_x_y_between_xi_xj"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.pintegrate_x_y_between_xi_xj">[docs]</a><span class="k">def</span> <span class="nf">pintegrate_x_y_between_xi_xj</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Integrate PolyLine data between xi and xj; wrapper for</span>
<span class="sd">    integrate_x_y_between_xi_xj.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : PolyLine object</span>
<span class="sd">        PolyLine containing data for integrating.</span>
<span class="sd">    xi, xj : array_like, float</span>
<span class="sd">        x values to interpolate between.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : 1d array of float</span>
<span class="sd">        Interpolated values. len(A) == len(xi).</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    integrate_x_y_between_xi_xj : Wrapped function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">integrate_x_y_between_xi_xj</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="integrate_x_y_between_xi_xj"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.integrate_x_y_between_xi_xj">[docs]</a><span class="k">def</span> <span class="nf">integrate_x_y_between_xi_xj</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Integrate piecewise-linear x_y data between xi and xj</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y : 1d array_like, float</span>
<span class="sd">        x and y values for piecewise linear integration.</span>
<span class="sd">    xi, xj : array_like, float</span>
<span class="sd">        x values to interpolate between.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : 1d array of float</span>
<span class="sd">        Interpolated values. len(A) == len(xi)</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    interp_x_y : Interpolate the x_y part.</span>
<span class="sd">    segments_between_xi_and_xj : Line segments between xi and xj.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
    <span class="n">xj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">xj</span><span class="p">)</span>

    <span class="p">(</span><span class="n">segment_both</span><span class="p">,</span> <span class="n">segment_xi_only</span><span class="p">,</span> <span class="n">segment_xj_only</span><span class="p">,</span> <span class="n">segments_between</span><span class="p">)</span> <span class="o">=</span> <span class="n">segments_between_xi_and_xj</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">)</span>
    <span class="n">yi</span> <span class="o">=</span> <span class="n">interp_x_y</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">choose_max</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">yj</span> <span class="o">=</span> <span class="n">interp_x_y</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xj</span><span class="p">,</span> <span class="n">choose_max</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>


    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">segment_both</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">yi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">yj</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">xj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">segment_xi_only</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">yi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">layer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">layer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">segments_between</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">layer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">layer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">layer</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">segment_xj_only</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> <span class="o">+</span> <span class="n">yj</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">xj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">layer</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">A</span></div>


<div class="viewcode-block" id="pintegrate_x1_x2_y1_y2_between_xi_xj"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.pintegrate_x1_x2_y1_y2_between_xi_xj">[docs]</a><span class="k">def</span> <span class="nf">pintegrate_x1_x2_y1_y2_between_xi_xj</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Integrate PolyLine data between xi and xj; wrapper for</span>
<span class="sd">    integrate_x1_x2_y1_y2_between_xi_xj.</span>

<span class="sd">     Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : PolyLine object</span>
<span class="sd">        PolyLine containing data for integrating.</span>
<span class="sd">    xi, xj : array_like, float</span>
<span class="sd">        x values to integrate between.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : 1d array of float</span>
<span class="sd">        Results of integrations. len(A) == len(xi).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    integrate_x1_x2_y1_y2_between_xi_xj : Wrapped function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">integrate_x1_x2_y1_y2_between_xi_xj</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y2</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="integrate_x1_x2_y1_y2_between_xi_xj"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.integrate_x1_x2_y1_y2_between_xi_xj">[docs]</a><span class="k">def</span> <span class="nf">integrate_x1_x2_y1_y2_between_xi_xj</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Integrate layered x1_x2_y1_y2 data between xi and xj</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, y1 : array_like, float</span>
<span class="sd">        x and y values at start of each segment.</span>
<span class="sd">    x2, y2 : array_like, float</span>
<span class="sd">        x and y values at end of each segment (note x1[1:]==x2[:-1]).</span>
<span class="sd">    xi, xj : array_like, float</span>
<span class="sd">        x values to integrate between.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : 1d array of float</span>
<span class="sd">        Results of integrations. len(A) == len(xi).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    interp_x1_x2_y1_y2 : Interpolation of x1_x2_y1_y2 data.</span>
<span class="sd">    segments_between_xi_and_xj : Line segments between xi and xj.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
    <span class="n">xj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">xj</span><span class="p">)</span>

    <span class="n">x_for_interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x_for_interp</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[:]</span>
    <span class="n">x_for_interp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


    <span class="p">(</span><span class="n">segment_both</span><span class="p">,</span> <span class="n">segment_xi_only</span><span class="p">,</span> <span class="n">segment_xj_only</span><span class="p">,</span> <span class="n">segments_between</span><span class="p">)</span> <span class="o">=</span> <span class="n">segments_between_xi_and_xj</span><span class="p">(</span><span class="n">x_for_interp</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">)</span>

    <span class="n">yi</span> <span class="o">=</span> <span class="n">interp_x1_x2_y1_y2</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span> <span class="n">choose_max</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">yj</span> <span class="o">=</span> <span class="n">interp_x1_x2_y1_y2</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">xj</span><span class="p">,</span> <span class="n">choose_max</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>


    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">segment_both</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">yi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">yj</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">xj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">segment_xi_only</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">yi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y2</span><span class="p">[</span><span class="n">layer</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">segments_between</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">y1</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> <span class="o">+</span> <span class="n">y2</span><span class="p">[</span><span class="n">layer</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1</span><span class="p">[</span><span class="n">layer</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">segment_xj_only</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">y1</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> <span class="o">+</span> <span class="n">yj</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">xj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1</span><span class="p">[</span><span class="n">layer</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">A</span></div>


<div class="viewcode-block" id="pavg_x1_x2_y1_y2_between_xi_xj"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.pavg_x1_x2_y1_y2_between_xi_xj">[docs]</a><span class="k">def</span> <span class="nf">pavg_x1_x2_y1_y2_between_xi_xj</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Average of PolyLine data between xi and xj; wrapper for</span>
<span class="sd">    avg_x1_x2_y1_y2_between_xi_xj.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : PolyLine object</span>
<span class="sd">        PolyLine containing data for integrating.</span>
<span class="sd">    xi, xj : array_like, float</span>
<span class="sd">        x values to integrate between.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : 1d array of float</span>
<span class="sd">        Average for each xi, xj pair. len(A) == len(xi).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    avg_x1_x2_y1_y2_between_xi_xj : Wrapped function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">avg_x1_x2_y1_y2_between_xi_xj</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y2</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="avg_x1_x2_y1_y2_between_xi_xj"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.avg_x1_x2_y1_y2_between_xi_xj">[docs]</a><span class="k">def</span> <span class="nf">avg_x1_x2_y1_y2_between_xi_xj</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Average of x1_x2_y1_y2 data between xi and xj</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, y1 : array_like, float</span>
<span class="sd">        x and y values at start of each segment</span>
<span class="sd">    x2, y2 : array_like, float</span>
<span class="sd">        x and y values at end of each segment (note x1[1:]==x2[:-1])</span>
<span class="sd">    xi, xj : array_like, float</span>
<span class="sd">        x values to integrate between</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : 1d array of float</span>
<span class="sd">        Average for each xi, xj pair. len(A) == len(xi).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    integrate_x1_x2_y1_y2_between_xi_xj : Integration is intermediate</span>
<span class="sd">        step for average calculation.</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
    <span class="n">xj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">xj</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">integrate_x1_x2_y1_y2_between_xi_xj</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">xj</span> <span class="o">-</span> <span class="n">xi</span><span class="p">)</span></div>


<div class="viewcode-block" id="pxa_ya_multipy_avg_x1b_x2b_y1b_y2b_between"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.pxa_ya_multipy_avg_x1b_x2b_y1b_y2b_between">[docs]</a><span class="k">def</span> <span class="nf">pxa_ya_multipy_avg_x1b_x2b_y1b_y2b_between</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span>
                                               <span class="n">xai</span><span class="p">,</span> <span class="n">xbi</span><span class="p">,</span> <span class="n">xbj</span><span class="p">,</span>
                                               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Respectively interpolate at one point, and average between two points,</span>
<span class="sd">    the a composiute function of two PolyLine objects.</span>

<span class="sd">    Evaluate f(xai) * integrate[g(xb), (xbi, xbj)] / (xbi - xbj),</span>
<span class="sd">    where f(xa) and g(xb) are PolyLine objects; wrapper</span>
<span class="sd">    for xa_ya_multipy_avg_x1b_x2b_y1b_y2b_between.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : PolyLine object</span>
<span class="sd">        PolyLine object s containing data.  The `b` Polyline will be averaged</span>
<span class="sd">        between xbi, and xbj; the `a` PolyLine will be interpolated at xai.</span>
<span class="sd">    xai : array_like, float</span>
<span class="sd">        x values to interpolate at for x_y part.</span>
<span class="sd">    xbi, xbj : array_like, float</span>
<span class="sd">        x values to average between for the x1_x2_y1_y2 part.</span>
<span class="sd">    achoose_max : ``boolean``, optional</span>
<span class="sd">        If False (default), when xai falls on boundary of segments choose the</span>
<span class="sd">        minimum segment to interpolate within.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : 2d array of float</span>
<span class="sd">        Result of averageing and interpolating.</span>
<span class="sd">        shape(A) == (len(xbi), len(xai)).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    xa_ya_multipy_avg_x1b_x2b_y1b_y2b_between : Wrapped function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">xa_ya_multipy_avg_x1b_x2b_y1b_y2b_between</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">y2</span><span class="p">,</span> <span class="n">xai</span><span class="p">,</span> <span class="n">xbi</span><span class="p">,</span> <span class="n">xbj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="xa_ya_multipy_avg_x1b_x2b_y1b_y2b_between"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.xa_ya_multipy_avg_x1b_x2b_y1b_y2b_between">[docs]</a><span class="k">def</span> <span class="nf">xa_ya_multipy_avg_x1b_x2b_y1b_y2b_between</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">ya</span><span class="p">,</span>
                                              <span class="n">x1b</span><span class="p">,</span> <span class="n">x2b</span><span class="p">,</span> <span class="n">y1b</span><span class="p">,</span> <span class="n">y2b</span><span class="p">,</span>
                                              <span class="n">xai</span><span class="p">,</span> <span class="n">xbi</span><span class="p">,</span> <span class="n">xbj</span><span class="p">,</span>
                                              <span class="n">achoose_max</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Respectively interpolate at one point, and average between two points,</span>
<span class="sd">    the x_y and x1_x2_y1_y2 portions of a composite function of</span>
<span class="sd">    piecewise-linear representations.</span>

<span class="sd">    Evaluate f(xai) * integrate[g(xb), (xbi, xbj)] / (xbi - xbj),</span>
<span class="sd">    where f(xa) is defined with x_y data and g(xb) is defined with</span>
<span class="sd">    x1_x2_y1_y2 data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xa, ya : 1d array_like, float</span>
<span class="sd">        x and y values of x_y part of function.</span>
<span class="sd">    x1b, y1b : array_like, float</span>
<span class="sd">        x and y values at start of each segment for x1_x2_y1_y2 part of</span>
<span class="sd">        function.</span>
<span class="sd">    x2b, y2b : array_like, float</span>
<span class="sd">        x and y values at end of each segment for x1_x2_y1_y2 part of</span>
<span class="sd">        function  (note x1[1:]==x2[:-1])</span>
<span class="sd">    xai : array_like, float</span>
<span class="sd">        x values to interpolate at for x_y part.</span>
<span class="sd">    xbi, xbj : array_like, float</span>
<span class="sd">        x values to average between for the x1_x2_y1_y2 part.</span>
<span class="sd">    achoose_max : ``boolean``, optional</span>
<span class="sd">        If False (default), when xai falls on boundary of segments choose the</span>
<span class="sd">        minimum segment to interpolate within.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : 2d array of float</span>
<span class="sd">        Result. shape(A) == (len(xbi), len(xai)), i.e. rows represent</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    interp_x_y : Interpolate the x_y part.</span>
<span class="sd">    avg_x1_x2_y1_y2_between_xi_xj : Average the x1_x2_y1_y2 part between</span>
<span class="sd">        xbi, xbj.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">yai</span> <span class="o">=</span> <span class="n">interp_x_y</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">ya</span><span class="p">,</span> <span class="n">xai</span><span class="p">,</span> <span class="n">choose_max</span><span class="o">=</span><span class="n">achoose_max</span><span class="p">)</span>
    <span class="n">ybi</span> <span class="o">=</span> <span class="n">avg_x1_x2_y1_y2_between_xi_xj</span><span class="p">(</span><span class="n">x1b</span><span class="p">,</span> <span class="n">x2b</span><span class="p">,</span> <span class="n">y1b</span><span class="p">,</span> <span class="n">y2b</span><span class="p">,</span> <span class="n">xbi</span><span class="p">,</span> <span class="n">xbj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ybi</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">yai</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span></div>


<div class="viewcode-block" id="pintegrate_x1a_x2a_y1a_y2a_multiply_x1b_x2b_y1b_y2b_between"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.pintegrate_x1a_x2a_y1a_y2a_multiply_x1b_x2b_y1b_y2b_between">[docs]</a><span class="k">def</span> <span class="nf">pintegrate_x1a_x2a_y1a_y2a_multiply_x1b_x2b_y1b_y2b_between</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span>
                                                                <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">,</span>
                                                                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Integrate between two points a composite function made of two</span>
<span class="sd">    PolyLine objects; wrapper for</span>
<span class="sd">    integrate_x1a_x2a_y1a_y2a_multiply_x1b_x2b_y1b_y2b_between.</span>


<span class="sd">    Evaluate integrate[f(x)*g(x), (xi, xj)]</span>
<span class="sd">    where f(x) and g(x) are defined by PolyLine objects.</span>

<span class="sd">    The two PolyLines must have the same x values, i.e. the layers must</span>
<span class="sd">    match up, x1a==x1b, x2a==x2b.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : PolyLine object</span>
<span class="sd">        PolyLine objects multiplied together to define the composite function.</span>
<span class="sd">        x and y values at start of each segment for first x1_x2_y1_y2 part of</span>
<span class="sd">        composite function.</span>
<span class="sd">    xi, xj : array_like, float</span>
<span class="sd">        x values to integrate between.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : len(xi) 1d array of float</span>
<span class="sd">        Integrations for each xi, xj pair.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    integrate_x1a_x2a_y1a_y2a_multiply_x1b_x2b_y1b_y2b_between : Wrapped</span>
<span class="sd">        function.</span>
<span class="sd">    polyline_make_x_common : Ensure PolyLine object have same x values.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">polyline_make_x_common</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">integrate_x1a_x2a_y1a_y2a_multiply_x1b_x2b_y1b_y2b_between</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">y2</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">y2</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">xj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="integrate_x1a_x2a_y1a_y2a_multiply_x1b_x2b_y1b_y2b_between"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.integrate_x1a_x2a_y1a_y2a_multiply_x1b_x2b_y1b_y2b_between">[docs]</a><span class="k">def</span> <span class="nf">integrate_x1a_x2a_y1a_y2a_multiply_x1b_x2b_y1b_y2b_between</span><span class="p">(</span><span class="n">x1a</span><span class="p">,</span> <span class="n">x2a</span><span class="p">,</span>
                                                               <span class="n">y1a</span><span class="p">,</span> <span class="n">y2a</span><span class="p">,</span>
                                                               <span class="n">x1b</span><span class="p">,</span> <span class="n">x2b</span><span class="p">,</span>
                                                               <span class="n">y1b</span><span class="p">,</span> <span class="n">y2b</span><span class="p">,</span>
                                                               <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Integrate between two points a composite function made of two</span>
<span class="sd">    x1_x2_y1_y2 piecewise-linear data representations.</span>

<span class="sd">    Evaluate integrate[f(x)*g(x), (xi, xj)]</span>
<span class="sd">    where f(x) and g(x) are defined by x1_x2_y1_y2 data.</span>


<span class="sd">    The two data sets must have the same x values, i.e. the layers must</span>
<span class="sd">    match up, x1a==x1b, x2a==x2b.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1a, y1a : array_like, float</span>
<span class="sd">        x and y values at start of each segment for first x1_x2_y1_y2 part of</span>
<span class="sd">        composite function.</span>
<span class="sd">    x2a, y2a : array_like, float</span>
<span class="sd">        x and y values at end of each segment for first x1_x2_y1_y2 part of</span>
<span class="sd">        composite function  (note x1[1:]==x2[:-1]).</span>
<span class="sd">    x1b, y1b : array_like, float</span>
<span class="sd">        x and y values at start of each segment for second x1_x2_y1_y2 part of</span>
<span class="sd">        composite function.</span>
<span class="sd">    x2b, y2b : array_like, float</span>
<span class="sd">        x and y values at end of each segment for second x1_x2_y1_y2 part of</span>
<span class="sd">        composite function  (note x1[1:]==x2[:-1]).</span>
<span class="sd">    xi, xj : array_like, float</span>
<span class="sd">        x values to integrate between.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : len(xi) 1d array of float</span>
<span class="sd">        Results of integrations.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x1a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x1a</span><span class="p">)</span>
    <span class="n">x2a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x2a</span><span class="p">)</span>
    <span class="n">y1a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y1a</span><span class="p">)</span>
    <span class="n">y2a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y2a</span><span class="p">)</span>
    <span class="n">x1b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x1b</span><span class="p">)</span>
    <span class="n">x2b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x2b</span><span class="p">)</span>
    <span class="n">y1b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y1b</span><span class="p">)</span>
    <span class="n">y2b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y2b</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">x1a</span><span class="p">,</span> <span class="n">x1b</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">x2a</span><span class="p">,</span> <span class="n">x2b</span><span class="p">)):</span> <span class="c1">#they may be different sizes</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x values are different; they must be the same: </span><span class="se">\n</span><span class="s2">x1a = </span><span class="si">{0}</span><span class="se">\n</span><span class="s2">x1b = </span><span class="si">{1}</span><span class="se">\n</span><span class="s2">x2a = </span><span class="si">{2}</span><span class="se">\n</span><span class="s2">x2b = </span><span class="si">{3}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x1a</span><span class="p">,</span><span class="n">x1b</span><span class="p">,</span> <span class="n">x2a</span><span class="p">,</span> <span class="n">x2b</span><span class="p">))</span>
        <span class="c1">#sys.exit(0)</span>

    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
    <span class="n">xj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">xj</span><span class="p">)</span>

    <span class="n">x_for_interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x1a</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x_for_interp</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1a</span><span class="p">[:]</span>
    <span class="n">x_for_interp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x2a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


    <span class="p">(</span><span class="n">segment_both</span><span class="p">,</span>
     <span class="n">segment_xi_only</span><span class="p">,</span>
     <span class="n">segment_xj_only</span><span class="p">,</span>
     <span class="n">segments_between</span><span class="p">)</span> <span class="o">=</span> <span class="n">segments_between_xi_and_xj</span><span class="p">(</span><span class="n">x_for_interp</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">)</span>


    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segment_both</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">a_slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">y2a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">x2a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span>
            <span class="n">b_slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">y2b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">x2b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1b</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">3</span> <span class="o">+</span> <span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">xj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">3</span> <span class="o">-</span> <span class="p">(</span><span class="o">-</span><span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">+</span>
                <span class="n">a_slope</span><span class="o">*</span><span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b_slope</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">+</span>
                <span class="n">a_slope</span><span class="o">*</span><span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b_slope</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">xj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span>
                <span class="n">a_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">+</span> <span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span><span class="o">*</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span>
                <span class="p">(</span><span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span><span class="o">*</span><span class="n">xj</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segment_xi_only</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">a_slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">y2a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">x2a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span>
            <span class="n">b_slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">y2b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">x2b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1b</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">x2a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">3</span> <span class="o">-</span> <span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">3</span> <span class="o">-</span> <span class="p">(</span><span class="o">-</span><span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">+</span>
                <span class="n">a_slope</span><span class="o">*</span><span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b_slope</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span>
                <span class="n">a_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">+</span> <span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span><span class="o">*</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span>
                <span class="n">x2a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span>
                <span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">+</span> <span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span> <span class="o">+</span>
                <span class="n">x2a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">+</span> <span class="n">a_slope</span><span class="o">*</span><span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b_slope</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segments_between</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">a_slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">y2a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">x2a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span>
            <span class="n">b_slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">y2b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">x2b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1b</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">3</span> <span class="o">+</span> <span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">x2a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">3</span> <span class="o">-</span>
                <span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span>
                <span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">+</span> <span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span> <span class="o">-</span>
                <span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">+</span> <span class="n">a_slope</span><span class="o">*</span><span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b_slope</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
                <span class="n">x2a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span>
                <span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">+</span> <span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span> <span class="o">+</span>
                <span class="n">x2a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">+</span> <span class="n">a_slope</span><span class="o">*</span><span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b_slope</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segment_xj_only</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">a_slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">y2a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">x2a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span>
            <span class="n">b_slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">y2b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">x2b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1b</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">3</span> <span class="o">+</span> <span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">xj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">3</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">+</span>
                <span class="n">a_slope</span><span class="o">*</span><span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b_slope</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">xj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span>
                <span class="n">a_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">+</span> <span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span><span class="o">*</span><span class="n">xj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span>
                <span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">-</span>
                <span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">+</span> <span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span> <span class="o">-</span>
                <span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">a_slope</span><span class="o">*</span><span class="n">b_slope</span><span class="o">*</span><span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">+</span> <span class="n">a_slope</span><span class="o">*</span><span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b_slope</span><span class="o">*</span><span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">A</span></div>


<div class="viewcode-block" id="pxa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between_super"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.pxa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between_super">[docs]</a><span class="k">def</span> <span class="nf">pxa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between_super</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span> <span class="n">xai</span><span class="p">,</span><span class="n">xbi</span><span class="p">,</span><span class="n">xbj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Superpose results of respectively interpolate at one point, and</span>
<span class="sd">    integrate between two points, the first PolyLine and the multiplied second</span>
<span class="sd">    and third PolyLine portions of a composite function of piecewise-linear</span>
<span class="sd">    representations.</span>

<span class="sd">    For each f(xa), g(xb) pair sum f(xai) * integrate[g(xb) * h(xb), (xbi, xbj)],</span>
<span class="sd">    where f(xa), g(xb), and h(xb) are defined with PolyLine objects.</span>

<span class="sd">    The function is a bit specialised in that `a` and `b` can be lists of</span>
<span class="sd">    PolyLine objects.  The contribution of each composite function</span>
<span class="sd">    (a[0], b[0], c), (a[1], b[1], c), ... will be summed.</span>

<span class="sd">    The `b` and `c` PolyLine objects do NOT need to have the same x values,</span>
<span class="sd">    they will be forced to do so using `polyline_make_x_common`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b, c : PolyLine object, or list of PolyLine objects</span>
<span class="sd">        PolyLine obects making up the composite function. `a` and `b` can be</span>
<span class="sd">        lists of equal length.</span>
<span class="sd">    xai : array_like, float</span>
<span class="sd">        x values to interpolate the `a` part of the composite function.</span>
<span class="sd">    xbi, xbj : array_like, float</span>
<span class="sd">        x values to integrate the b * c  part of the composite function.</span>
<span class="sd">    achoose_max : ``boolean``, optional</span>
<span class="sd">        If False (default), when xai falls on boundary of segments choose the</span>
<span class="sd">        minimum segment to interpolate within.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : (len(xbi), len(xai)) 2d array</span>
<span class="sd">        Results for each xbi, xbj pair and xai value.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    xa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between :</span>
<span class="sd">        Wrapped function.</span>
<span class="sd">    pxa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between_super :</span>
<span class="sd">        Same function with additional cosine term.</span>
<span class="sd">    pxa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between :</span>
<span class="sd">        Similar function without superposition.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="c1">#    b, c = polyline_make_x_common(b, c)</span>
<span class="c1">#    return xa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between(a.x,a.y,b.x1,b.x2,b.y1,b.y2, c.x1, c.x2, c.y1, c.y2, xai,xbi,xbj, **kwargs)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;a and b must be lengths of equal length. len(a) = </span><span class="si">{0}</span><span class="s2">, len(b) = </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">xbi</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">xai</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">aa</span><span class="p">,</span> <span class="n">bb</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">bb</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">polyline_make_x_common</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="n">xa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between</span><span class="p">(</span><span class="n">aa</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="n">aa</span><span class="o">.</span><span class="n">y</span><span class="p">,</span><span class="n">bb</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">bb</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span><span class="n">bb</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span><span class="n">bb</span><span class="o">.</span><span class="n">y2</span><span class="p">,</span> <span class="n">cc</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">cc</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">cc</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span> <span class="n">cc</span><span class="o">.</span><span class="n">y2</span><span class="p">,</span> <span class="n">xai</span><span class="p">,</span><span class="n">xbi</span><span class="p">,</span><span class="n">xbj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="pxa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.pxa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between">[docs]</a><span class="k">def</span> <span class="nf">pxa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">xai</span><span class="p">,</span><span class="n">xbi</span><span class="p">,</span><span class="n">xbj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Respectively interpolate at one point, and integrate between two</span>
<span class="sd">    points, the first PolyLine and the multiplied second and third PolyLine</span>
<span class="sd">    portions of a composite function of piecewise-linear representations.</span>

<span class="sd">    Evaluate f(xai) * integrate[g(xb) * h(xb), (xbi, xbj)],</span>
<span class="sd">    where f(xa), g(xb), and h(xb) are defined with PolyLine objects.</span>

<span class="sd">    The `b` and `c` PolyLine objects do NOT need to have the same x values,</span>
<span class="sd">    they will be forced to do so using `polyline_make_x_common`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b, c : PolyLine object</span>
<span class="sd">        PolyLine obects making up the composite function.</span>
<span class="sd">    xai : array_like, float</span>
<span class="sd">        x values to interpolate the `a` part of the composite function.</span>
<span class="sd">    xbi, xbj : array_like, float</span>
<span class="sd">        x values to integrate the b * c  part of the composite function.</span>
<span class="sd">        between.</span>
<span class="sd">    achoose_max : ``boolean``, optional</span>
<span class="sd">        If False (default), when xai falls on boundary of segments choose the</span>
<span class="sd">        minimum segment to interpolate within.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : (len(xbi), len(xai)) 2d array</span>
<span class="sd">        Results for each xbi, xbj pair and xai value.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    xa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between : Wrapped</span>
<span class="sd">        Function.</span>
<span class="sd">    pxa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between : Similar</span>
<span class="sd">        function with additional cosine term.</span>
<span class="sd">    pxa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between_super : Same</span>
<span class="sd">        function with superposition.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">polyline_make_x_common</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">y2</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">y2</span><span class="p">,</span> <span class="n">xai</span><span class="p">,</span><span class="n">xbi</span><span class="p">,</span><span class="n">xbj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="xa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.xa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between">[docs]</a><span class="k">def</span> <span class="nf">xa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span><span class="n">ya</span><span class="p">,</span><span class="n">x1b</span><span class="p">,</span><span class="n">x2b</span><span class="p">,</span><span class="n">y1b</span><span class="p">,</span><span class="n">y2b</span><span class="p">,</span> <span class="n">x1c</span><span class="p">,</span> <span class="n">x2c</span><span class="p">,</span> <span class="n">y1c</span><span class="p">,</span> <span class="n">y2c</span><span class="p">,</span> <span class="n">xai</span><span class="p">,</span><span class="n">xbi</span><span class="p">,</span><span class="n">xbj</span><span class="p">,</span> <span class="n">achoose_max</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Respectively interpolate at one point, and integrate between two</span>
<span class="sd">    points, the x_y and two multipled x1_x2_y1_y2 portions of a composite</span>
<span class="sd">    function of piecewise-linear representations.</span>

<span class="sd">    Evaluate f(xai) * integrate[g(xb) * h(xb), (xbi, xbj)],</span>
<span class="sd">    where f(xa) is defined with x_y data and g(xb) and h(xb) are defined with</span>
<span class="sd">    x1_x2_y1_y2 data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xa, ya : 1d array_like, float</span>
<span class="sd">        x and y values of x_y part of the composite function.</span>
<span class="sd">    x1b, y1b : array_like, float</span>
<span class="sd">        x and y values at start of each segment for the first x1_x2_y1_y2</span>
<span class="sd">        part of the composite function.</span>
<span class="sd">    x2b, y2b : array_like, float</span>
<span class="sd">        x and y values at end of each segment for the first x1_x2_y1_y2 part of</span>
<span class="sd">        the composite function (note x1[1:]==x2[:-1]).</span>
<span class="sd">    x1c, y1c : array_like, float</span>
<span class="sd">        x and y values at start of each segment for the secondx1_x2_y1_y2</span>
<span class="sd">        part of the composite function.</span>
<span class="sd">    x2c, y2c : array_like, float</span>
<span class="sd">        x and y values at end of each segment for the second x1_x2_y1_y2</span>
<span class="sd">        part of the composite function  (note x1[1:]==x2[:-1]).</span>
<span class="sd">    xai : array_like, float</span>
<span class="sd">        x values to interpolate the x_y part at.</span>
<span class="sd">    xbi, xbj : array_like, float</span>
<span class="sd">        x values to integrate the x1b_x2b_y1b_y2b * x1c_x2c_y1c_y2c part</span>
<span class="sd">        between.</span>
<span class="sd">    achoose_max : ``boolean``, optional</span>
<span class="sd">        If False (default), when xai falls on boundary of segments choose the</span>
<span class="sd">        minimum segment to interpolate within.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : (len(xbi), len(xai)) 2d array</span>
<span class="sd">        Results for each xbi, xbj pair and xai value.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    pxa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between :</span>
<span class="sd">        Same function with PolyLine inputs.</span>
<span class="sd">    pxa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between_super :</span>
<span class="sd">        PolyLine inputs and superposition.</span>
<span class="sd">    xa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between :</span>
<span class="sd">        Similar function with additional cosine term.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">yai</span> <span class="o">=</span> <span class="n">interp_x_y</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">ya</span><span class="p">,</span> <span class="n">xai</span><span class="p">,</span> <span class="n">choose_max</span><span class="o">=</span><span class="n">achoose_max</span><span class="p">)</span>
    <span class="n">ybi</span> <span class="o">=</span> <span class="n">integrate_x1a_x2a_y1a_y2a_multiply_x1b_x2b_y1b_y2b_between</span><span class="p">(</span><span class="n">x1b</span><span class="p">,</span> <span class="n">x2b</span><span class="p">,</span> <span class="n">y1b</span><span class="p">,</span> <span class="n">y2b</span><span class="p">,</span> <span class="n">x1c</span><span class="p">,</span> <span class="n">x2c</span><span class="p">,</span> <span class="n">y1c</span><span class="p">,</span> <span class="n">y2c</span><span class="p">,</span> <span class="n">xbi</span><span class="p">,</span> <span class="n">xbj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ybi</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">yai</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span></div>


<span class="c1">#def pxa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between_super(a,omega_phase, b,c, xai,xbi,xbj, **kwargs):</span>
<span class="c1">#    &quot;&quot;&quot;wrapper for xa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between to allow PolyLine input.</span>
<span class="c1">#</span>
<span class="c1">#    Parameters</span>
<span class="c1">#    ----------</span>
<span class="c1">#    omega_phase: 2 element tuple</span>
<span class="c1">#        (omega, phase) for use in cos(omega * t + phase)</span>
<span class="c1">#</span>
<span class="c1">#    Notes</span>
<span class="c1">#    -----</span>
<span class="c1">#    `a` and `b` `omega_phase` can be lists that will be superposed.  This is not available in</span>
<span class="c1">#    the original function</span>
<span class="c1">#</span>
<span class="c1">#    See Also</span>
<span class="c1">#    --------</span>
<span class="c1">#    xa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between</span>
<span class="c1">#    pxa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between : similar polyline wrapper but no superposition</span>
<span class="c1">#</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">##    b, c = polyline_make_x_common(b, c)</span>
<span class="c1">##    return xa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between(a.x,a.y,b.x1,b.x2,b.y1,b.y2, c.x1, c.x2, c.y1, c.y2, xai,xbi,xbj, **kwargs)</span>
<span class="c1">#</span>
<span class="c1">#    if not isinstance(a,list):</span>
<span class="c1">#        a = [a]</span>
<span class="c1">#    if not isinstance(b, list):</span>
<span class="c1">#        b = [b]</span>
<span class="c1">#    if not isinstance(b, list):</span>
<span class="c1">#        omega_phase = [omega_phase]</span>
<span class="c1">#    if len(a)!=len(b):</span>
<span class="c1">#        raise ValueError(&quot;a and b must be lengths of equal length. len(a) = {0}, len(b) = {1}&quot;.format(len(a), len(b)))</span>
<span class="c1">#    if len(a)!=len(omega_phase):</span>
<span class="c1">#        raise ValueError(&quot;a and omega_phase must be lengths of equal length. len(a) = {0}, len(omega_phase) = {1}&quot;.format(len(a), len(omega_phase)))</span>
<span class="c1">#    out = np.zeros((len(xbi), len(xai)))</span>
<span class="c1">#    for aa, bb, (omega, phase) in zip(a, b, omega_phase):</span>
<span class="c1">#        bb, cc = polyline_make_x_common(bb, c)</span>
<span class="c1">#        out += xa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between(aa.x,aa.y,omega, phase, bb.x1,bb.x2,bb.y1,bb.y2, cc.x1, cc.x2, cc.y1, cc.y2, xai,xbi,xbj, **kwargs)</span>
<span class="c1">#    return out</span>

<div class="viewcode-block" id="pxa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between_super"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.pxa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between_super">[docs]</a><span class="k">def</span> <span class="nf">pxa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between_super</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span> <span class="n">xai</span><span class="p">,</span> <span class="n">xbi</span><span class="p">,</span> <span class="n">xbj</span><span class="p">,</span> <span class="n">omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Superpose results of  respectively interpolate at one point, and</span>
<span class="sd">    integrate between two points, the cosine multiplied by PolyLine, and two</span>
<span class="sd">    multipled PolyLine portions of a composite function of piecewise-linear</span>
<span class="sd">    representations.</span>

<span class="sd">    For each f(xa), g(xb) pair sum</span>
<span class="sd">    f(xai) * cos(omega*xai + phase) * integrate[g(xb) * h(xb), (xbi, xbj)],</span>
<span class="sd">    where f(xa), g(xb), and h(xb) are PolyLine objects.</span>

<span class="sd">    The function is a bit specialised in that `a` and `b` and `omega_phase`</span>
<span class="sd">    can be lists of PolyLine objects.  The contribution of each composite function</span>
<span class="sd">    (a[0], omega_phase[0], b[0], c), (a[1], b[1], omega_phase[1], c), ...</span>
<span class="sd">    will be summed.</span>

<span class="sd">    The `b` and `c` PolyLine objects do NOT need to have the same x values,</span>
<span class="sd">    they will be forced to do so using `polyline_make_x_common`.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b, c : PolyLine object</span>
<span class="sd">        PolyLine obects making up the composite function.</span>
<span class="sd">    xai :  array_like, float</span>
<span class="sd">        x values to interpolate the `a` part of the composite function.</span>
<span class="sd">    xbi, xbj : array_like, float</span>
<span class="sd">        x values to integrate the b * c  part of the composite function.</span>
<span class="sd">        between.</span>
<span class="sd">    omega_phase : 2 element tuple, optional</span>
<span class="sd">        (omega, phase) for use in cos(omega * t + phase), Default</span>
<span class="sd">        omega_phase=None i.e. no cosine term.</span>
<span class="sd">    achoose_max : ``boolean``, optional</span>
<span class="sd">        If False (default), when xai falls on boundary of segments choose the</span>
<span class="sd">        minimum segment to interpolate within.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : (len(xbi), len(xai)) 2d array</span>
<span class="sd">        Results for each xbi, xbj pair and xai value.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    xa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between :</span>
<span class="sd">        Wrapped function</span>
<span class="sd">    pxa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between_super :</span>
<span class="sd">        Same function without cosine term.</span>
<span class="sd">    pxa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between :</span>
<span class="sd">        Similar function without superposition.</span>


<span class="sd">    &quot;&quot;&quot;</span>

<span class="c1">#    b, c = polyline_make_x_common(b, c)</span>
<span class="c1">#    return xa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between(a.x,a.y,b.x1,b.x2,b.y1,b.y2, c.x1, c.x2, c.y1, c.y2, xai,xbi,xbj, **kwargs)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="n">omega_phase</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;a and b must be lengths of equal length. len(a) = </span><span class="si">{0}</span><span class="s2">, len(b) = </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">omega_phase</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;a and omega_phase must be lengths of equal length. len(a) = </span><span class="si">{0}</span><span class="s2">, len(omega_phase) = </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">omega_phase</span><span class="p">)))</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">xbi</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">xai</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">aa</span><span class="p">,</span> <span class="n">bb</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">omega_phase</span><span class="p">):</span>
        <span class="n">bb</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">polyline_make_x_common</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="n">xa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between</span><span class="p">(</span><span class="n">aa</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="n">aa</span><span class="o">.</span><span class="n">y</span><span class="p">,</span><span class="n">omega</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">bb</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">bb</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span><span class="n">bb</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span><span class="n">bb</span><span class="o">.</span><span class="n">y2</span><span class="p">,</span> <span class="n">cc</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">cc</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">cc</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span> <span class="n">cc</span><span class="o">.</span><span class="n">y2</span><span class="p">,</span> <span class="n">xai</span><span class="p">,</span><span class="n">xbi</span><span class="p">,</span><span class="n">xbj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="n">xa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between</span><span class="p">(</span><span class="n">aa</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">aa</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">bb</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">bb</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">bb</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span><span class="n">bb</span><span class="o">.</span><span class="n">y2</span><span class="p">,</span> <span class="n">cc</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">cc</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">cc</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span> <span class="n">cc</span><span class="o">.</span><span class="n">y2</span><span class="p">,</span> <span class="n">xai</span><span class="p">,</span><span class="n">xbi</span><span class="p">,</span><span class="n">xbj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="pxa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.pxa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between">[docs]</a><span class="k">def</span> <span class="nf">pxa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">xai</span><span class="p">,</span><span class="n">xbi</span><span class="p">,</span><span class="n">xbj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Respectively interpolate at one point, and integrate between two</span>
<span class="sd">    points, the cosine multiplied by PolyLine, and two multipled PolyLine</span>
<span class="sd">    portions of a composite function of piecewise-linear representations.</span>

<span class="sd">    Evaluate f(xai) * cos(omega*xai + phase) * integrate[g(xb) * h(xb), (xbi, xbj)],</span>
<span class="sd">    where f(xa), g(xb), and h(xb) are PolyLine objects.</span>

<span class="sd">    The `b` and `c` PolyLine objects do NOT need to have the same x values,</span>
<span class="sd">    they will be forced to do so using `polyline_make_x_common`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b, c : PolyLine object</span>
<span class="sd">        PolyLine obects making up the composite function.</span>
<span class="sd">    omega, phase : float</span>
<span class="sd">        Values for defining cos(omega * t + phase).</span>
<span class="sd">    xai : array_like, float</span>
<span class="sd">        x values to interpolate the `a` part of the composite function.</span>
<span class="sd">    xbi, xbj : array_like, float</span>
<span class="sd">        x values to integrate the b * c  part of the composite function.</span>
<span class="sd">        between.</span>
<span class="sd">    achoose_max : ``boolean``, optional</span>
<span class="sd">        If False (default), when xai falls on boundary of segments choose the</span>
<span class="sd">        minimum segment to interpolate within.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : (len(xbi), len(xai)) 2d array</span>
<span class="sd">        Results for each xbi, xbj pair and xai value.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    xa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between : Wrapped</span>
<span class="sd">        Function.</span>
<span class="sd">    pxa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between : Same</span>
<span class="sd">        function without the cosine part.</span>
<span class="sd">    pxa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between_super : Same</span>
<span class="sd">        function with superposition.</span>



<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">polyline_make_x_common</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span><span class="n">omega</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">y2</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">y2</span><span class="p">,</span> <span class="n">xai</span><span class="p">,</span><span class="n">xbi</span><span class="p">,</span><span class="n">xbj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="xa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.xa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between">[docs]</a><span class="k">def</span> <span class="nf">xa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">ya</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">x1b</span><span class="p">,</span><span class="n">x2b</span><span class="p">,</span><span class="n">y1b</span><span class="p">,</span><span class="n">y2b</span><span class="p">,</span> <span class="n">x1c</span><span class="p">,</span> <span class="n">x2c</span><span class="p">,</span> <span class="n">y1c</span><span class="p">,</span> <span class="n">y2c</span><span class="p">,</span> <span class="n">xai</span><span class="p">,</span><span class="n">xbi</span><span class="p">,</span><span class="n">xbj</span><span class="p">,</span> <span class="n">achoose_max</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Respectively interpolate at one point, and integrate between two</span>
<span class="sd">    points, the cosine multiplied by x_y, and two multipled x1_x2_y1_y2</span>
<span class="sd">    portions of a composite function of piecewise-linear representations.</span>

<span class="sd">    Evaluate f(xai) * cos(omega*xai + phase) * integrate[g(xb) * h(xb), (xbi, xbj)],</span>
<span class="sd">    where f(xa) is defined with x_y data and g(xb) and h(xb) are defined with</span>
<span class="sd">    x1_x2_y1_y2 data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xa, ya : 1d array_like, float</span>
<span class="sd">        x and y values of x_y part of interpolation function.</span>
<span class="sd">    omega, phase : float</span>
<span class="sd">        Values for defining cos(omega * t + phase).</span>
<span class="sd">    x1b, y1b : array_like, float</span>
<span class="sd">        x and y values at start of each segment for the first 1st x1_x2_y1_y2</span>
<span class="sd">        part of the composite function.</span>
<span class="sd">    x2b, y2b : array_like, float</span>
<span class="sd">        x and y values at end of each segment for the first 1st x1_x2_y1_y2</span>
<span class="sd">        part of the composite function  (note x1[1:]==x2[:-1])</span>
<span class="sd">    x1c, y1c : array_like, float</span>
<span class="sd">        x and y values at start of each segment for the second x1_x2_y1_y2</span>
<span class="sd">        part of the composite function.</span>
<span class="sd">    x2c, y2c : array_like, float</span>
<span class="sd">        x and y values at end of each segment for the second x1_x2_y1_y2</span>
<span class="sd">        part of the composite function  (note x1[1:]==x2[:-1]).</span>
<span class="sd">    xai : array_like, float</span>
<span class="sd">        x values to interpolate the xc_yc part at and evaluate the</span>
<span class="sd">        cos(omega*xai + phase) part.</span>
<span class="sd">    xbi, xbj : array_like, float</span>
<span class="sd">        x values to integrate the x1b_x2b_y1b_y2b * x1c_x2c_y1c_y2c part</span>
<span class="sd">        between.</span>
<span class="sd">    achoose_max : ``boolean``, optional</span>
<span class="sd">        If False (default), when xai falls on boundary of segments choose the</span>
<span class="sd">        minimum segment to interpolate within.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : (len(xbi), len(xai)) 2d array</span>
<span class="sd">        Results for each xbi, xbj pair and xai value.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    pxa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between :</span>
<span class="sd">        Same function with PolyLine inputs.</span>
<span class="sd">    pxa_ya_cos_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between_super :</span>
<span class="sd">        PolyLine inputs and superposition.</span>
<span class="sd">    xa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between :</span>
<span class="sd">        Similar function without cosine term.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">xai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xai</span><span class="p">)</span>
    <span class="n">yai</span> <span class="o">=</span> <span class="n">interp_x_y</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">ya</span><span class="p">,</span> <span class="n">xai</span><span class="p">,</span> <span class="n">choose_max</span><span class="o">=</span><span class="n">achoose_max</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span> <span class="o">*</span> <span class="n">xai</span> <span class="o">+</span> <span class="n">phase</span><span class="p">)</span>

    <span class="n">ybi</span> <span class="o">=</span> <span class="n">integrate_x1a_x2a_y1a_y2a_multiply_x1b_x2b_y1b_y2b_between</span><span class="p">(</span><span class="n">x1b</span><span class="p">,</span> <span class="n">x2b</span><span class="p">,</span> <span class="n">y1b</span><span class="p">,</span> <span class="n">y2b</span><span class="p">,</span> <span class="n">x1c</span><span class="p">,</span> <span class="n">x2c</span><span class="p">,</span> <span class="n">y1c</span><span class="p">,</span> <span class="n">y2c</span><span class="p">,</span> <span class="n">xbi</span><span class="p">,</span> <span class="n">xbj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ybi</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">yai</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span></div>

<div class="viewcode-block" id="PolyLine"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.PolyLine">[docs]</a><span class="k">class</span> <span class="nc">PolyLine</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A Polyline is a series of x y points joined by straight lines</span>

<span class="sd">    Provides some extra functionality beyond just using an x array and y array</span>
<span class="sd">    to represent a multi-point line.</span>

<span class="sd">    Functinality of PolyLines:</span>


<span class="sd">    - PolyLines can be intialized in different ways e.g. use a single array</span>
<span class="sd">      of x-y points; use separate x-arrays and y-arrays; use x values at the</span>
<span class="sd">      start and end of each interval and y values at the start and end of each</span>
<span class="sd">      interval.  This can be useful if you want to work with layer/interval</span>
<span class="sd">      data but to plot those intervals you want x-y points.</span>
<span class="sd">    - Multiply a PolyLine by a scalar and only the y values will be changed.</span>
<span class="sd">    - Add to/from a PolyLine with a scalar and only the y values will be</span>
<span class="sd">      changed.</span>
<span class="sd">    - PolyLines can be added together to create a new PolyLine; the x values</span>
<span class="sd">      of each PolyLine will be maintained.  Any x values that are not common</span>
<span class="sd">      to both PolyLines will have their y values interpolated and then added.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    *args : array like</span>
<span class="sd">        A PolyLine object can be initialized with 1, 2, or 4 positional</span>
<span class="sd">        arguments (a different number of arguments will raise an error):</span>

<span class="sd">         - A single n-by-2 two-dimensional array of n (x, y) points.  i.e.</span>
<span class="sd">           first column is x values, second column is y values.</span>
<span class="sd">         - Two one-dimensional arrays of equal length.  The first array is the</span>
<span class="sd">           x values.  The second array is the corresponding y values.</span>
<span class="sd">         - Four one-dimensional arrays of equal length. First array x1 is x</span>
<span class="sd">           values at the start of a interval.  The second array x2 is x values</span>
<span class="sd">           at the end of a interval (note x1[1:] must equal x2[0:-1]).  The</span>
<span class="sd">           third array y1 is the y values at the start of each interval.  The</span>
<span class="sd">           fourth array y2 is the y values at the end of each interval.</span>


<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    xy : 2d numpy array</span>
<span class="sd">        n by 2 array containing x and y values for each of the n points i.e.</span>
<span class="sd">        [[x0, y0], [x1, y1], ..., [xn, yn]].</span>
<span class="sd">    x, y : 1d numpy array</span>
<span class="sd">        Arrays containing all the x values and all the y values in the</span>
<span class="sd">        PolyLine.</span>
<span class="sd">    x1, x2, y1, y2 : 1d numpy array</span>
<span class="sd">        When you want the start and end values of each of the intervals/layers</span>
<span class="sd">        in the PolyLine.  x1 is the x values at the start of each interval,</span>
<span class="sd">        x2 is the x values at the end of each interval. y1 is the y values at</span>
<span class="sd">        the start of each interval, y2 is the y values at the end of each</span>
<span class="sd">        interval.  Note that when dealing with intervals any vertical intervals</span>
<span class="sd">        will be lost e.g. say our x-y values are defined by joining the dots:</span>
<span class="sd">        PolyLine([0,1,1,2], [4,4,5,5])  is defined by 4 points but  it will</span>
<span class="sd">        have only 2 layers/intervals i.e. x1 will be [0,1], x2 will be [1,0],</span>
<span class="sd">        y1 will be [4,5], y2 will be [4,5].  Just be careful when initialising</span>
<span class="sd">        PolyLines using x1_x2_y1_y2 values, any initial or final vertical</span>
<span class="sd">        section  cannot be defined.</span>
<span class="sd">    x1_x2_y1_y2 : tuple of 4 1d arrays</span>
<span class="sd">        The x1, x2, y1, y2 arrays returned in a tuple.</span>
<span class="sd">    atol, rtol : float</span>
<span class="sd">        Absolute and relative tolerance when comparing equality of points in a</span>
<span class="sd">        PolyLine using numpy.allclose</span>
<span class="sd">    _prefix_for_numpy_array_repr : string</span>
<span class="sd">        When using the repr function on Numpy arrays the default output will</span>
<span class="sd">        print array([...]).  Because PolyLines use numpy arrays to store data</span>
<span class="sd">        when using repr on PolyLines you would get PolyLine(array([...])).</span>
<span class="sd">        Now if in your code you have done import numpy.array as array&quot; or some</span>
<span class="sd">        such import then you can just copy the repr of a PolylIne into you code</span>
<span class="sd">        .  However I usually use &quot;import numpy as np&quot;  so ideally I want</span>
<span class="sd">        &#39;np.&#39; prepended to all my numpy array reprs.</span>
<span class="sd">        _prefix_for_numpy_array_repr does just this with the default prefix</span>
<span class="sd">        = &quot;np.&quot;  (if you wish to change the prefix for all numpy arrays not</span>
<span class="sd">        just the PolyLine repr then see numpy.`set_string_function` )</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]:</span>
            <span class="c1">#For the following error consider subclassing exception as per http://stackoverflow.com/a/1964247/2530083</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1"> args given; Line can only be initialized with &#39;</span>
                <span class="s1">&#39;1, 2, or 4 args: 1 (x-y coords), 2 (x-coords, y-coords), or &#39;</span>
                <span class="s1">&#39;4 (x1-coords, x2-coords, y1-coords, y2-coords)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-8</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prefix_for_numpy_array_repr</span> <span class="o">=</span> <span class="s2">&quot;np.&quot;</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1">#args[0] is an 2d array of n xy data points; shape=(n,2)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_xy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;x_y data must be 2d array_like with shape &#39;</span>
                    <span class="s1">&#39;(n, 2) with n &gt;= 2.  Yours has shape &#39;</span>
                    <span class="s1">&#39;(</span><span class="si">{:d}</span><span class="s1">, </span><span class="si">{:d}</span><span class="s1">).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_xy</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="c1">#args[0] and args[1] are 1d arrays of n x and y data points</span>
            <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;x and y must be of same length with at &#39;</span>
                    <span class="s1">&#39;least two values. len(x)=</span><span class="si">{:d}</span><span class="s1">, &#39;</span>
                    <span class="s1">&#39;len(y)=</span><span class="si">{:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">][:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
            <span class="c1">#data is in segments with</span>
            <span class="c1">#args[0] and args[1] are 1d arrays of n x values at start and end of the n segments</span>
            <span class="c1">#args[2] and args[3] are 1d arrays of n y values at start and end of the n segments</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">args</span><span class="p">)))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;x1, x2, y1, y2 must have same length. &#39;</span>
                    <span class="s1">&#39;You have lengths &#39;</span>
                    <span class="s1">&#39;[</span><span class="si">{:d}</span><span class="s1">, </span><span class="si">{:d}</span><span class="s1">, </span><span class="si">{:d}</span><span class="s1">, </span><span class="si">{:d}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">args</span><span class="p">))))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">return</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the xy values.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">convert_x1_x2_y1_y2_to_x_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x1_x2_y1_y2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the x1_x2_y1_y2 values&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y2</span> <span class="o">=</span> <span class="n">convert_x_y_to_x1_x2_y1_y2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y2</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the x values of xy data.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the y values of xy data.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the x1 values of x1_x2_y1_y2 data.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x1_x2_y1_y2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the x2 values of x1_x2_y1_y2 data.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x1_x2_y1_y2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the y1 values of x1_x2_y1_y2 data.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x1_x2_y1_y2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the y2 values of x1_x2_y1_y2 data.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x1_x2_y1_y2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a string representation of the xy data&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;PolyLine(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">))</span>

<span class="c1">#    def __repr__(self):</span>
<span class="c1">#        &quot;&quot;&quot;A string repr of the PolyLine that will recreate the PolyLine&quot;&quot;&quot;</span>
<span class="c1">#        return &quot;PolyLine({}{})&quot;.format(self._prefix_for_numpy_array_repr,</span>
<span class="c1">#                                    repr(self.xy))</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A string repr of the PolyLine that will recreate the PolyLine&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;PolyLine(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_substract</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_substract</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_substract</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_substract</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">)</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PolyLine</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Cannot multiply two PolyLines together.  &#39;</span>
                <span class="s1">&#39;You will get a quadratic that I cannot handle.&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PolyLine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">other</span><span class="p">)</span>
<span class="c1">#            a = copy.deepcopy(self)</span>
<span class="c1">#            a.xy #ensure xy has been initialized</span>
<span class="c1">#            a._xy[:,1] *= other</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;unsupported operand type(s) for *: &#39;PolyLine&#39; and &quot;</span>
                <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="c1">#        return a</span>
    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PolyLine</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Cannot divide two PolyLines together.  You will get a quadratic that I cannot handle&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PolyLine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">/</span> <span class="n">other</span><span class="p">)</span>
<span class="c1">#            a = copy.deepcopy(self)</span>
<span class="c1">#            a.xy #ensure xy has been initialized</span>
<span class="c1">#            a._xy[:,1] /= other</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unsupported operand type(s) for /: &#39;PolyLine&#39; and &quot;</span>
                <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="c1">#        return a</span>
    <span class="k">def</span> <span class="nf">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PolyLine</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Cannot divide two PolyLines together.  You will get a quadratic that I cannot handle&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PolyLine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">other</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="c1">#            a = copy.deepcopy(self)</span>
<span class="c1">#            a.xy #ensure xy has been initialized</span>
<span class="c1">#            a._xy[:,1] = other/a._xy[:,1]</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;unsupported operand type(s) for /: &#39;PolyLine&#39; and &quot;</span>
                <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="c1">#        return a</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">xy</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atol</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_substract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Addition or subtraction of PolyLine objects&quot;&quot;&quot;</span>

        <span class="n">mp</span> <span class="o">=</span> <span class="p">{</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">iadd</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">isub</span><span class="p">}</span>
        <span class="n">iop</span> <span class="o">=</span> <span class="n">mp</span><span class="p">[</span><span class="n">op</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PolyLine</span><span class="p">):</span>

            <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="p">(</span><span class="n">non_increasing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="n">non_decreasing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)))</span> <span class="ow">or</span>
                <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">non_increasing</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="n">non_decreasing</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">x</span><span class="p">)))):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Your PolyLines have switchbacks in them; cannot add together.&#39;</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


            <span class="c1">#1. reverse values if decreasing</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_initially_increasing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
                <span class="n">xa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">ya</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[:]</span>
                <span class="n">ya</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[:]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_initially_increasing</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
                <span class="n">xb</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">yb</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xb</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">x</span><span class="p">[:]</span>
                <span class="n">yb</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">y</span><span class="p">[:]</span>

            <span class="n">xa</span><span class="p">,</span> <span class="n">ya</span> <span class="o">=</span> <span class="n">remove_superfluous_from_x_y</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">ya</span><span class="p">)</span>
            <span class="n">xb</span><span class="p">,</span> <span class="n">yb</span> <span class="o">=</span> <span class="n">remove_superfluous_from_x_y</span><span class="p">(</span><span class="n">xb</span><span class="p">,</span> <span class="n">yb</span><span class="p">)</span>



            <span class="n">data</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">xa</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">xb</span><span class="p">),</span><span class="mi">4</span><span class="p">])</span>
            <span class="n">data</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">xa</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="n">xa</span><span class="p">[:]</span>
            <span class="n">data</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">xa</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="n">ya</span><span class="p">[:]</span>
            <span class="n">data</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">xa</span><span class="p">),</span> <span class="mi">2</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span> <span class="c1">#line</span>
            <span class="n">data</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">xa</span><span class="p">),</span> <span class="mi">3</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xa</span><span class="p">))</span> <span class="c1">#orig position</span>
            <span class="n">data</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">xa</span><span class="p">):,</span> <span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="n">xb</span><span class="p">[:]</span>
            <span class="n">data</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">xa</span><span class="p">):,</span> <span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="n">yb</span><span class="p">[:]</span>
            <span class="n">data</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">xa</span><span class="p">):,</span> <span class="mi">2</span><span class="p">]</span><span class="o">=</span> <span class="mi">1</span> <span class="c1">#line</span>
            <span class="n">data</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">xa</span><span class="p">):,</span> <span class="mi">3</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xb</span><span class="p">))</span> <span class="c1">#orig position</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">data</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span><span class="n">data</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span><span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))]</span>


            <span class="n">pnts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">xnow</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="c1">#ind = np.where(np.abs(data[:,0] - xnow) &lt; (self.atol + self.rtol * np.abs(xnow)))[0]</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atol</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtol</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

                <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">ind</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1">#use point a line point</span>
                    <span class="n">y1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">y1_</span><span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1">#interpolate</span>
                    <span class="n">y1</span> <span class="o">=</span> <span class="n">interp_x_y</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">ya</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">choose_max</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">y1_</span><span class="o">=</span> <span class="n">y1</span>

                <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">ind</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1">#use point a line point</span>
                    <span class="n">y2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">y2_</span><span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1">#interpolate</span>
                    <span class="n">y2</span> <span class="o">=</span> <span class="n">interp_x_y</span><span class="p">(</span><span class="n">xb</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">choose_max</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">y2_</span><span class="o">=</span> <span class="n">y2</span>

                <span class="n">y</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span>
                <span class="n">y_</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">y1_</span><span class="p">,</span> <span class="n">y2_</span><span class="p">)</span>
                <span class="n">pnts</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">y_</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atol</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtol</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y_</span><span class="p">)):</span>
                    <span class="n">pnts</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y_</span><span class="p">])</span>

                <span class="n">i</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">ind</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>

            <span class="k">return</span> <span class="n">PolyLine</span><span class="p">(</span><span class="n">pnts</span><span class="p">)</span>


        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PolyLine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">iop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
<span class="c1">#            a = copy.deepcopy(self)</span>
<span class="c1">#            #a._xy[:,1] += other</span>
<span class="c1">#</span>
<span class="c1">#            a.xy #ensure xy has been initialized</span>
<span class="c1">#            iop(a._xy[:,1], other)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unsupported operand type(s) for +: &#39;PolyLine&#39; and &quot;</span>
                <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
<span class="c1">#            sys.exit(0)</span>
        <span class="k">return</span> <span class="n">a</span></div>


<div class="viewcode-block" id="polyline_make_x_common"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.polyline_make_x_common">[docs]</a><span class="k">def</span> <span class="nf">polyline_make_x_common</span><span class="p">(</span><span class="o">*</span><span class="n">p_lines</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add appropriate points to multiple PolyLine objetcs so that each has</span>
<span class="sd">    matching x1_x2 intevals.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p_lines : PolyLine</span>
<span class="sd">        One or more instances of PolyLine.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : tuple of PolyLine</span>
<span class="sd">        Same number of Polyline&#39;s as `p_lines`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">xa</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ya</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_lines</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">PolyLine</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;p_lines[</span><span class="si">{:d}</span><span class="s2">] is not a PolyLine&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">non_increasing</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="n">non_decreasing</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">x</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;PolyLine #</span><span class="si">{:d}</span><span class="s1"> has switchbacks.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_initially_increasing</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
            <span class="n">xa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ya</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">x</span><span class="p">[:])</span>
            <span class="n">ya</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">y</span><span class="p">[:])</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_lines</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">p_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">data</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span><span class="n">xa</span><span class="p">)),</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xa</span><span class="p">):</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="n">x</span><span class="p">[:]</span>
        <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="n">ya</span><span class="p">[</span><span class="n">i</span><span class="p">][:]</span>
        <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">=</span> <span class="n">i</span> <span class="c1">#line</span>
        <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c1">#orig position</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">stop</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">data</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span><span class="n">data</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span><span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))]</span>


    <span class="n">pnts</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xa</span><span class="p">]</span>
    <span class="n">xnow</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">atol</span> <span class="o">=</span> <span class="n">p_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">atol</span>
    <span class="n">rtol</span> <span class="o">=</span> <span class="n">p_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rtol</span>

    <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1">#ind = np.where(np.abs(data[:,0] - xnow) &lt; (self.atol + self.rtol * np.abs(xnow)))[0]</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">atol</span> <span class="o">+</span> <span class="n">rtol</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="c1"># find all x values close to current x</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xa</span><span class="p">)):</span>

            <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">ind</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">k</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#use point a line point</span>
                <span class="n">y1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">y1_</span><span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#interpolate</span>
                <span class="n">y1</span> <span class="o">=</span> <span class="n">interp_x_y</span><span class="p">(</span><span class="n">xa</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">ya</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">choose_max</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">y1_</span><span class="o">=</span> <span class="n">y1</span>
            <span class="n">pnts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y1</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y1_</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">atol</span> <span class="o">+</span> <span class="n">rtol</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y1_</span><span class="p">)):</span>
                <span class="n">pnts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y1_</span><span class="p">])</span>

        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">ind</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">PolyLine</span><span class="p">,</span> <span class="n">pnts</span><span class="p">))</span></div>




<div class="viewcode-block" id="subdivide_x_y_into_segments"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.subdivide_x_y_into_segments">[docs]</a><span class="k">def</span> <span class="nf">subdivide_x_y_into_segments</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_segments</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">just_before</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">logy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">logxzero</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">logyzero</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Subdivide piecewise-linear line segment x, y data by interpolation</span>

<span class="sd">    Subsegments are evenly spaced in linear or log space.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1d array-like</span>
<span class="sd">        List of x values to subdivide.</span>
<span class="sd">    y : 1d array-like</span>
<span class="sd">        List of y values to subdivide (y subdivision is based on</span>
<span class="sd">        interpolation at the new x values).</span>
<span class="sd">    dx : float, optional</span>
<span class="sd">        Approximate length or log10(length) of subsegment.  Say logx is True,</span>
<span class="sd">        segment x values are (1, 10), and x=0.2 then</span>
<span class="sd">        int((log(10)-log(1))/0.2)=5 subsegments will be created</span>
<span class="sd">        (i.e. 5 extra points will be inserted in the segment).  The new x</span>
<span class="sd">        values will be will be 10**(log(1)+0.2), 10**(log(1)+0.4),</span>
<span class="sd">        10**(log(1)+0.6) etc. Default dx=None i.e. no dx check and</span>
<span class="sd">        `min_segments` will be used.</span>
<span class="sd">    min_segments : int, optional</span>
<span class="sd">        Minuimum number of subsegments per inteval. This will be used if</span>
<span class="sd">        int(segment_lenght/dx)&lt;min_segments. Default min_segments=2.</span>
<span class="sd">    just_before : float, optional</span>
<span class="sd">        If `just_before` is not None then in terms of subdividing, each</span>
<span class="sd">        segment will be treated as if it begins at its starting value but</span>
<span class="sd">        ends a distance of `just_before` multiplied by the interval length</span>
<span class="sd">        before its end value. This</span>
<span class="sd">        means that an extra point will be added just before all of the</span>
<span class="sd">        original points. Default just_before=None i.e dont use just before</span>
<span class="sd">        point.  Use a small number e.g. 1e-6.</span>
<span class="sd">        `just_before` can be useful for example when getting</span>
<span class="sd">        times to evaluate pore pressure during a soil consoliation</span>
<span class="sd">        analysis.  Say you have a PolyLine representing load_vs_time. If</span>
<span class="sd">        there are step changes in your load then there will be step</span>
<span class="sd">        changes in your pore pressure.  To capture the step change in your</span>
<span class="sd">        output you need an output time just before and just after the step</span>
<span class="sd">        change in your load.  Using `just_before` can achieve this.</span>
<span class="sd">    logx, logy : True/False, optional</span>
<span class="sd">        Use log scale on x and y axes.  Default logx=logy=False.</span>
<span class="sd">    logxzero, logyzero : float, optional</span>
<span class="sd">        If log scale is used, force zero value to be given number.</span>
<span class="sd">        Useful when 1st point is zero but you really want to start from close</span>
<span class="sd">        to zero. Default logxzero=logyzero=0.01.</span>
<span class="sd">    rtol, atol : float, optional</span>
<span class="sd">        For determining equal to zero when using log scale with numpy.</span>
<span class="sd">        Default atol=1e-8, rtol = 1e-5.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xnew, ynew : 1d array</span>
<span class="sd">        New x and y coordinates.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    subdivide_x_into_segments : Subdivide only x data.</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;x and y must have same length &#39;</span>
                     <span class="s1">&#39;len(x)=</span><span class="si">{:d}</span><span class="s1">, len(y)=</span><span class="si">{:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">logx</span><span class="p">:</span>
        <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">atol</span> <span class="o">+</span> <span class="n">rtol</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span> <span class="o">=</span> <span class="n">logxzero</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;When logx=True cannot have negative &#39;</span>
                                <span class="s1">&#39;x values, x=&#39;</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">logy</span><span class="p">:</span>
        <span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">atol</span> <span class="o">+</span> <span class="n">rtol</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">))]</span> <span class="o">=</span> <span class="n">logyzero</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">y</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;When logy=True cannot have negative &#39;</span>
                                <span class="s1">&#39;y values, y=&#39;</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">dx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">just_before</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">xnew</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">((</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span><span class="o">//</span><span class="n">dx</span><span class="p">)),</span> <span class="n">min_segments</span><span class="p">),</span>
                         <span class="n">endpoint</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>

        <span class="n">ynew</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">((</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span><span class="o">//</span><span class="n">dx</span><span class="p">)),</span> <span class="n">min_segments</span><span class="p">),</span>
                            <span class="n">endpoint</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="k">for</span>
                <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xnew</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">just_before</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">),</span>
                         <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">((</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span><span class="o">//</span><span class="n">dx</span><span class="p">)),</span> <span class="n">min_segments</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                         <span class="n">endpoint</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="k">for</span>
                <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>


        <span class="n">ynew</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">just_before</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">),</span>
                         <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">((</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span><span class="o">//</span><span class="n">dx</span><span class="p">)),</span> <span class="n">min_segments</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                         <span class="n">endpoint</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="k">for</span>
                <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                                        <span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>

    <span class="c1"># add in final point</span>
    <span class="n">xnew</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">ynew</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

    <span class="n">xnew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span> <span class="k">for</span> <span class="n">subl</span> <span class="ow">in</span> <span class="n">xnew</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">subl</span><span class="p">])</span>
    <span class="n">ynew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span> <span class="k">for</span> <span class="n">subl</span> <span class="ow">in</span> <span class="n">ynew</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">subl</span><span class="p">])</span>


    <span class="k">if</span> <span class="n">logx</span><span class="p">:</span>

        <span class="n">xnew</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="n">xnew</span>
    <span class="k">if</span> <span class="n">logy</span><span class="p">:</span>
        <span class="n">ynew</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="n">ynew</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">xnew</span><span class="p">,</span> <span class="n">ynew</span><span class="p">)</span></div>


<div class="viewcode-block" id="subdivide_x_into_segments"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.subdivide_x_into_segments">[docs]</a><span class="k">def</span> <span class="nf">subdivide_x_into_segments</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_segments</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">just_before</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">logxzero</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Subdivide sequential x values into subsegments.</span>

<span class="sd">    Intervals are evenly spaced in linear or log space</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1d array-like</span>
<span class="sd">        List of x values to subdivide.</span>
<span class="sd">    dx : float, optional</span>
<span class="sd">        Approximate length or log10(length) of subsegment.  Say logx is True,</span>
<span class="sd">        segment x values are (1, 10), and x=0.2 then</span>
<span class="sd">        int((log(10)-log(1))/0.2)=5 subsegments will be created</span>
<span class="sd">        (i.e. 5 extra points will be inserted in the segment).  The new x</span>
<span class="sd">        values will be will be 10**(log(1)+0.2), 10**(log(1)+0.4),</span>
<span class="sd">        10**(log(1)+0.6) etc. Default dx=None i.e. no dx check and</span>
<span class="sd">        `min_segments` will be used.</span>
<span class="sd">    min_segments : int, optional</span>
<span class="sd">        Minuimum number of subsegments per inteval. This will be used if</span>
<span class="sd">        int(segment_lenght/dx)&lt;min_segments. Default min_segments=2.</span>
<span class="sd">    just_before : float, optional</span>
<span class="sd">        If `just_before` is not None then in terms of subdividing, each</span>
<span class="sd">        segment will be treated as if it begins at its starting value but</span>
<span class="sd">        ends a distance of `just_before` multiplied by the interval length</span>
<span class="sd">        before its end value. This</span>
<span class="sd">        means that an extra point will be added just before all of the</span>
<span class="sd">        original points. Default just_before=None i.e dont use just before</span>
<span class="sd">        point.  Use a small number e.g. 1e-6.</span>
<span class="sd">        `just_before` can be useful for example when getting</span>
<span class="sd">        times to evaluate pore pressure during a soil consoliation</span>
<span class="sd">        analysis.  Say you have a PolyLine representing load_vs_time. If</span>
<span class="sd">        there are step changes in your load then there will be step</span>
<span class="sd">        changes in your pore pressure.  To capture the step change in your</span>
<span class="sd">        output you need an output time just before and just after the step</span>
<span class="sd">        change in your load.  Using `just_before` can achieve this.</span>
<span class="sd">    logx : True/False, optional</span>
<span class="sd">        Use log scale on x data.  Default logx=False.</span>
<span class="sd">    logxzero : float, optional</span>
<span class="sd">        If log scale is used, force zero value to be given number.</span>
<span class="sd">        Useful when 1st point is zero but you really want to start from close</span>
<span class="sd">        to zero. Default logxzero=0.01.</span>
<span class="sd">    rtol, atol : float, optional</span>
<span class="sd">        For determining equal to zero when using log scale with numpy.</span>
<span class="sd">        Default atol=1e-8, rtol = 1e-5.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xnew : 1d array</span>
<span class="sd">        new x values</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    subdivide_x_y_into_segments : Subdivide both x and y data, y data is</span>
<span class="sd">        interpolated from the new x values.</span>


<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>



    <span class="k">if</span> <span class="n">logx</span><span class="p">:</span>
        <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">atol</span> <span class="o">+</span> <span class="n">rtol</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span> <span class="o">=</span> <span class="n">logxzero</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;When logx=True cannot have negative &#39;</span>
                                <span class="s1">&#39;x values, x=&#39;</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">dx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">just_before</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">xnew</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">((</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span><span class="o">//</span><span class="n">dx</span><span class="p">)),</span> <span class="n">min_segments</span><span class="p">),</span>
                         <span class="n">endpoint</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">xnew</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">just_before</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">),</span>
                         <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">((</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span><span class="o">//</span><span class="n">dx</span><span class="p">)),</span> <span class="n">min_segments</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                         <span class="n">endpoint</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="k">for</span>
                <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>


    <span class="c1"># add in final point</span>
    <span class="n">xnew</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>


    <span class="n">xnew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span> <span class="k">for</span> <span class="n">subl</span> <span class="ow">in</span> <span class="n">xnew</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">subl</span><span class="p">])</span>



    <span class="k">if</span> <span class="n">logx</span><span class="p">:</span>

        <span class="n">xnew</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="n">xnew</span>


    <span class="k">return</span> <span class="n">xnew</span></div>


<div class="viewcode-block" id="layer_coords"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.layer_coords">[docs]</a><span class="k">def</span> <span class="nf">layer_coords</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">segs</span><span class="p">,</span> <span class="n">min_segs</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Divide layer heights into segments and calculate offset from start</span>

<span class="sd">    Subdivide each layer. Calculate offset.</span>

<span class="sd">    Useful when you are interested in the end points of each layer as well as</span>
<span class="sd">    some intermediate points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h : list/array</span>
<span class="sd">        1d array of layer heights.</span>
<span class="sd">    segs : int</span>
<span class="sd">        Approximate number of segments to subdivide the whole profile into.</span>
<span class="sd">    min_segs : int, optional</span>
<span class="sd">        Minimum number of segments to subdivide a layer into. Default</span>
<span class="sd">        min_segs=2.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z : 1d array</span>
<span class="sd">        Depths.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; layer_coords([4], 2)</span>
<span class="sd">    array([0., 2., 4.])</span>
<span class="sd">    &gt;&gt;&gt; layer_coords([2], 1, 4)</span>
<span class="sd">    array([0. , 0.5, 1. , 1.5, 2. ])</span>
<span class="sd">    &gt;&gt;&gt; layer_coords([2,4,2], 5, 2)</span>
<span class="sd">    array([0., 1., 2., 4., 6., 7., 8.])</span>
<span class="sd">    &gt;&gt;&gt; layer_coords([5,1,5], 3, 2)</span>
<span class="sd">    array([ 0. ,  2.5,  5. ,  5.5,  6. ,  8.5, 11. ])</span>


<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="n">z2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
    <span class="n">z1</span> <span class="o">=</span> <span class="n">z2</span> <span class="o">-</span> <span class="n">h</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">/</span> <span class="n">segs</span>
    <span class="n">num</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">height</span><span class="o">//</span><span class="n">dx</span><span class="p">,</span> <span class="n">min_segs</span><span class="p">)</span> <span class="k">for</span> <span class="n">height</span> <span class="ow">in</span> <span class="n">h</span><span class="p">]</span>

    <span class="n">zlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">z1_</span><span class="p">,</span> <span class="n">z2_</span><span class="p">,</span> <span class="n">num_</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">z1_</span><span class="p">,</span> <span class="n">z2_</span><span class="p">,</span> <span class="n">num_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">,</span> <span class="n">num</span><span class="p">)]</span>
    <span class="n">zlist</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">z2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span> <span class="k">for</span> <span class="n">subl</span> <span class="ow">in</span> <span class="n">zlist</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">subl</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">z</span></div>


<div class="viewcode-block" id="subdivide_into_elements"><a class="viewcode-back" href="../../../api/geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.subdivide_into_elements">[docs]</a><span class="k">def</span> <span class="nf">subdivide_into_elements</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Subdivide a length into elements where sizes are proportional to</span>
<span class="sd">    adjacent elements.</span>


<span class="sd">     - element_0 = x * p**0</span>
<span class="sd">     - element_1 = x * p**1</span>
<span class="sd">     - element_2 = x * p**2</span>
<span class="sd">     - etc.</span>

<span class="sd">    x is such that sum of `n` elements equals `h`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int, optional</span>
<span class="sd">        Number of elements to subdivide into. Default n=2.</span>
<span class="sd">    h : float, optional</span>
<span class="sd">        Length to subdivide.  Default h=1.</span>
<span class="sd">    p : float, optional</span>
<span class="sd">        Ratio of subsequent elements.  If p&lt;1 then succesive elements</span>
<span class="sd">        will reduce in length.  If p&gt;1 then successive elements</span>
<span class="sd">        will increase in lenght. Default p=1</span>
<span class="sd">    symmetry : True/False, optional</span>
<span class="sd">        If True then elements will be symmetrical abount middle.  Default</span>
<span class="sd">        symmetry=True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array of float</span>
<span class="sd">        Length of each element. Should sum to `h`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    np.logspace</span>
<span class="sd">    np.linspace</span>
<span class="sd">    subdivide_x_into_segments</span>
<span class="sd">    subdivide_x_y_into_segments</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; subdivide_into_elements(n=3, h=6.0, p=1, symmetry=True)</span>
<span class="sd">    array([2., 2., 2.])</span>
<span class="sd">    &gt;&gt;&gt; subdivide_into_elements(n=4, h=6.0, p=1, symmetry=True)</span>
<span class="sd">    array([1.5, 1.5, 1.5, 1.5])</span>
<span class="sd">    &gt;&gt;&gt; subdivide_into_elements(n=4, h=6.0, p=1, symmetry=False)</span>
<span class="sd">    array([1.5, 1.5, 1.5, 1.5])</span>
<span class="sd">    &gt;&gt;&gt; subdivide_into_elements(n=3, h=6.0, p=2, symmetry=True)</span>
<span class="sd">    array([1.5, 3. , 1.5])</span>
<span class="sd">    &gt;&gt;&gt; subdivide_into_elements(n=3, h=6.0, p=0.5, symmetry=True)</span>
<span class="sd">    array([2.4, 1.2, 2.4])</span>
<span class="sd">    &gt;&gt;&gt; subdivide_into_elements(n=4, h=6.0, p=2, symmetry=True)</span>
<span class="sd">    array([1., 2., 2., 1.])</span>
<span class="sd">    &gt;&gt;&gt; subdivide_into_elements(n=4, h=6.0, p=0.5, symmetry=True)</span>
<span class="sd">    array([2., 1., 1., 2.])</span>
<span class="sd">    &gt;&gt;&gt; subdivide_into_elements(n=4, h=6.0, p=0.5, symmetry=False)</span>
<span class="sd">    array([3.2, 1.6, 0.8, 0.4])</span>
<span class="sd">    &gt;&gt;&gt; subdivide_into_elements(n=3, h=3.5, p=2, symmetry=False)</span>
<span class="sd">    array([0.5, 1. , 2. ])</span>
<span class="sd">    &gt;&gt;&gt; sum(subdivide_into_elements(n=20, h=3.5, p=1.05, symmetry=False))</span>
<span class="sd">    3.5</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">p</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;p must be greater than 0&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;p must be an integer greater than 0&quot;</span><span class="p">)</span>



    <span class="k">if</span> <span class="n">p</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">h</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">ppower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">symmetry</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#even</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">h</span>
            <span class="n">x</span> <span class="o">/=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ppower</span><span class="p">[</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1">#odd</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">h</span>
            <span class="n">x</span> <span class="o">/=</span>  <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">p</span><span class="o">**</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">ppower</span><span class="p">[(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">h</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ppower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="n">ppower</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">nose</span>
    <span class="n">nose</span><span class="o">.</span><span class="n">runmodule</span><span class="p">(</span><span class="n">argv</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;nose&#39;</span><span class="p">,</span> <span class="s1">&#39;--verbosity=3&#39;</span><span class="p">,</span> <span class="s1">&#39;--with-doctest&#39;</span><span class="p">])</span>
<span class="c1">#    nose.runmodule(argv=[&#39;nose&#39;, &#39;--verbosity=3&#39;])</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2014, Rohan Walker.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>