
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>geotecha.speccon.integrals_generate_code &#8212; geotecha 0.2.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../../index.html"><img src="../../../_static/logo.png" border="0" alt="py4sci"/></a>
</div>



      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for geotecha.speccon.integrals_generate_code</h1><div class="highlight"><pre>
<span></span><span class="c1"># geotecha - A software suite for geotechncial engineering</span>
<span class="c1"># Copyright (C) 2018  Rohan T. Walker (rtrwalker@gmail.com)</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see http://www.gnu.org/licenses/gpl.html.</span>
<span class="sd">&quot;&quot;&quot;Use sympy to generate code for generating spectral method matrix subroutines&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">sympy</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="kn">from</span> <span class="nn">geotecha.inputoutput.inputoutput</span> <span class="k">import</span> <span class="n">fcode_one_large_expr</span>


<div class="viewcode-block" id="tw"><a class="viewcode-back" href="../../../api/geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.tw">[docs]</a><span class="k">def</span> <span class="nf">tw</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">indents</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">break_long_words</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rough text wrapper for long sympy expressions</span>

<span class="sd">    1st line will not be indented.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    text : str</span>
<span class="sd">        Text to wrap</span>
<span class="sd">    width : int optional</span>
<span class="sd">        Rough width of warpping. Default width=100.</span>
<span class="sd">    indents : int, optional</span>
<span class="sd">        Multiple of 4 spaces that will be used to indent each line.</span>
<span class="sd">        Default indents=3.</span>
<span class="sd">    break_long_words : True/False, optional</span>
<span class="sd">        Default break_long_words=False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : str</span>
<span class="sd">        Multi-line string.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">subsequent_indent</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="n">indents</span>

    <span class="n">wrapper</span> <span class="o">=</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">TextWrapper</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
                                   <span class="n">subsequent_indent</span> <span class="o">=</span> <span class="n">subsequent_indent</span><span class="p">,</span>
                                   <span class="n">break_long_words</span><span class="o">=</span><span class="n">break_long_words</span><span class="p">)</span>

    <span class="n">lines</span> <span class="o">=</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
    <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>




<div class="viewcode-block" id="Eload_linear_implementations"><a class="viewcode-back" href="../../../api/geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.Eload_linear_implementations">[docs]</a><span class="k">def</span> <span class="nf">Eload_linear_implementations</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Code generation for Integration of load(tau) * exp(dT * eig * (t-tau))</span>
<span class="sd">    between [0, t], where load(tau) is piecewise linear.</span>

<span class="sd">    Performs integrations involving a piecewise linear load.  A 2d array of</span>
<span class="sd">    dimensions A[len(tvals), len(eigs)]</span>
<span class="sd">    is produced where the &#39;i&#39;th row of A contains the diagonal elements of the</span>
<span class="sd">    spectral &#39;E&#39; matrix calculated for the time value tvals[i]. i.e. rows of</span>
<span class="sd">    this matrix will be assembled into the diagonal matrix &#39;E&#39; elsewhere.</span>


<span class="sd">    Paste the resulting code (at least the loops) into `Eload_linear`.</span>

<span class="sd">    Creates three implementations:</span>

<span class="sd">     - &#39;scalar&#39;, python loops (slowest).</span>
<span class="sd">     - &#39;vectorized&#39;, numpy (much faster than scalar).</span>
<span class="sd">     - &#39;fortran&#39;, fortran loops (fastest).  Needs to be compiled and interfaced</span>
<span class="sd">       with f2py.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fn : string</span>
<span class="sd">        Python code with scalar (loops) and vectorized (numpy) implementations</span>
<span class="sd">        also calls the fortran version.</span>
<span class="sd">    fn2 : string</span>
<span class="sd">        Fortran code.  Needs to be compiled with f2py.</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function produces a complex array</span>

<span class="sd">    Assuming the load are formulated as the product of separate time and depth</span>
<span class="sd">    dependant functions:</span>

<span class="sd">    .. math:: \\sigma\\left({Z,t}\\right)=\\sigma\\left({Z}\\right)\\sigma\\left({t}\\right)</span>

<span class="sd">    the solution to the consolidation equation using the spectral method has</span>
<span class="sd">    the form:</span>

<span class="sd">    .. math:: u\\left(Z,t\\right)=\\mathbf{\\Phi v E}\\left(\\mathbf{\\Gamma v}\\right)^{-1}\\mathbf{\\theta}</span>

<span class="sd">    The matrix :math:`E` is a time dependent diagonal matrix due to time</span>
<span class="sd">    dependant loadings.  The version of :math:`E` calculated here in</span>
<span class="sd">    `Eload_linear` is from loading terms in the governing equation that are NOT</span>
<span class="sd">    differentiated wrt :math:`t`.</span>
<span class="sd">    The diagonal elements of :math:`E` are given by:</span>

<span class="sd">    .. math:: \\mathbf{E}_{i,i}=\\int_{0}^t{{\\sigma\\left(\\tau\\right)}{\exp\\left({(dT\\left(t-\\tau\\right)\\lambda_i}\\right)}\\,d\\tau}</span>

<span class="sd">    where</span>

<span class="sd">     :math:`\\lambda_i` is the `ith` eigenvalue of the problem,</span>
<span class="sd">     :math:`dT` is a time factor for numerical convienience,</span>
<span class="sd">     :math:`\\sigma\left(\\tau\\right)` is the time dependant portion of the loading function.</span>

<span class="sd">    When the time dependant loading term :math:`\\sigma\\left(\\tau\\right)` is</span>
<span class="sd">    piecewise in time. The contribution of each load segment is found by:</span>

<span class="sd">    .. math:: \\mathbf{E}_{i,i}=\\int_{t_s}^{t_f}{{\\sigma\\left(\\tau\\right)}\\exp\\left({dT\\left(t-\\tau\\right)*\\lambda_i}\\right)\\,d\\tau}</span>

<span class="sd">    where</span>

<span class="sd">    .. math:: t_s = \\min\\left(t,t_{increment\\:start}\\right)</span>

<span class="sd">    .. math:: t_f = \\min\\left(t,t_{increment\\:end}\\right)</span>

<span class="sd">    (note that this function,`Eload_linear`, rather than use :math:`t_s` and</span>
<span class="sd">    :math:`t_f`,</span>
<span class="sd">    explicitly finds increments that the current time falls in, falls after,</span>
<span class="sd">    and falls before and treates each case on it&#39;s own.)</span>

<span class="sd">    Each :math:`t` value of interest requires a separate diagonal matrix</span>
<span class="sd">    :math:`E`.  To use space more efficiently and to facilitate numpy</span>
<span class="sd">    broadcasting when using the results of the function, the diagonal elements</span>
<span class="sd">    of :math:`E` for each time value `t` value are stored in the rows of</span>
<span class="sd">    array :math:`A` returned by `Eload_linear`.  Thus:</span>

<span class="sd">    .. math:: \\mathbf{A}=\\left(\\begin{matrix}E_{0,0}(t_0)&amp;E_{1,1}(t_0)&amp; \cdots &amp; E_{neig-1,neig-1}(t_0)\\\ E_{0,0}(t_1)&amp;E_{1,1}(t_1)&amp; \\cdots &amp; E_{neig-1,neig-1}(t_1)\\\ \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots \\\ E_{0,0}(t_m)&amp;E_{1,1}(t_m)&amp; \cdots &amp; E_{neig-1,neig-1}(t_m)\\end{matrix}\\right)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    geotecha.speccon.integrals.Eload_linear : Resulting function.</span>
<span class="sd">    geotecha.speccon.integrals.pEload_linear : Resulting function with PolyLine</span>
<span class="sd">        inputs.</span>
<span class="sd">    geotecha.speccon.ext_integrals.eload_linear : Resulting fortran function.</span>
<span class="sd">    Eload_coslinear_implementations : Similar function with</span>
<span class="sd">        additional cosine term.</span>
<span class="sd">    EDload_linear_implementations : Similar function but the time dependent</span>
<span class="sd">        loading function is differentiated with respect to time.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">exp</span>

    <span class="n">sympy</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;t, tau, dT, eig&#39;</span><span class="p">)</span>
    <span class="n">loadmag</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;loadmag&#39;</span><span class="p">)</span>
    <span class="n">loadtim</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;loadtim&#39;</span><span class="p">)</span>
    <span class="n">tvals</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;tvals&#39;</span><span class="p">)</span>
    <span class="n">eigs</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;eigs&#39;</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;j&#39;</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>


    <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">sig0</span><span class="p">,</span> <span class="n">sig1</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;t0, t1, sig0, sig1&#39;</span><span class="p">)</span>
    <span class="n">load</span> <span class="o">=</span> <span class="n">sig0</span> <span class="o">+</span> <span class="p">(</span><span class="n">sig1</span> <span class="o">-</span> <span class="n">sig0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tau</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, x0, x1&#39;</span><span class="p">)</span>
    <span class="n">load</span> <span class="o">=</span> <span class="n">load</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">x</span><span class="o">/</span><span class="p">(</span><span class="n">dT</span><span class="o">*</span><span class="n">eig</span><span class="p">)</span><span class="o">+</span><span class="n">t</span><span class="p">)</span>
    <span class="n">dx_dtau</span> <span class="o">=</span> <span class="n">dT</span> <span class="o">*</span> <span class="n">eig</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x0</span><span class="p">,</span> <span class="o">-</span><span class="n">dT</span> <span class="o">*</span> <span class="n">eig</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t0</span><span class="p">)),</span>
          <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="o">-</span><span class="n">dT</span> <span class="o">*</span> <span class="n">eig</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t1</span><span class="p">))]</span>

    <span class="n">mp2</span> <span class="o">=</span> <span class="p">[(</span><span class="n">sig0</span><span class="p">,</span> <span class="n">loadmag</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">sig1</span><span class="p">,</span> <span class="n">loadmag</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">loadtim</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span>
            <span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">loadtim</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])]</span>

<span class="c1">#    mp = [(exp(-dT*eig*t)*exp(dT*eig*loadtim[k]),</span>
<span class="c1">#           exp(-dT*eig*(t-loadtim[k]))),</span>
<span class="c1">#          (exp(-dT*eig*t)*exp(dT*eig*loadtim[k+1]),</span>
<span class="c1">#           exp(-dT*eig*(t-loadtim[k+1])))]</span>
<span class="c1">#    the default output for the integrals will have expression s like</span>
<span class="c1">#    exp(-dT*eig*t)*exp(dT*eig*loadtim[k]).  when dT*eig*loadtim[k] is large</span>
<span class="c1">#    the exponential may be so large as to cause an error.  YOu may need to</span>
<span class="c1">#    manually alter the expression to exp(is large exp(-dT*eig*(t-loadtim[k]))</span>
<span class="c1">#    in which case the term in the exponential will always be negative and not</span>
<span class="c1">#    lead to any numerical blow up.</span>
<span class="c1">#    load = linear(tau, loadtim[k], loadmag[k], loadtim[k+1], loadmag[k+1])</span>
<span class="c1">#    after_instant = (loadmag[k+1] - loadmag[k]) * exp(-dT * eig * (t - loadtim[k]))</span>
<span class="c1">#    mp does this automatically with subs</span>
<span class="c1">#    load = linear(tau, loadtim[k], loadmag[k], loadtim[k+1], loadmag[k+1])</span>
    <span class="n">within_constant</span> <span class="o">=</span> <span class="n">sig0</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx_dtau</span>
    <span class="n">within_constant</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">within_constant</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span><span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">within_constant</span> <span class="o">=</span> <span class="n">within_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="n">within_constant</span> <span class="o">=</span> <span class="n">within_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>

    <span class="n">after_constant</span> <span class="o">=</span> <span class="n">sig0</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx_dtau</span>
    <span class="n">after_constant</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">after_constant</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">after_constant</span> <span class="o">=</span> <span class="n">after_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="n">after_constant</span> <span class="o">=</span> <span class="n">after_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>

    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">load</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx_dtau</span>
    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">within_ramp</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">within_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">within_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>

    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">load</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx_dtau</span>
    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">after_ramp</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">after_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">after_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>


    <span class="n">text_python</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">def Eload_linear(loadtim, loadmag, eigs, tvals, dT=1.0, implementation=&#39;vectorized&#39;):</span>

<span class="s2">    loadtim = np.asarray(loadtim)</span>
<span class="s2">    loadmag = np.asarray(loadmag)</span>
<span class="s2">    eigs = np.asarray(eigs)</span>
<span class="s2">    tvals = np.asarray(tvals)</span>

<span class="s2">    if implementation == &#39;scalar&#39;:</span>
<span class="s2">        sin = np.sin</span>
<span class="s2">        cos = np.cos</span>
<span class="s2">        exp = np.exp</span>


<span class="s2">        A = np.zeros([len(tvals), len(eigs)], dtype=complex)</span>

<span class="s2">        (ramps_less_than_t, constants_less_than_t, steps_less_than_t,</span>
<span class="s2">            ramps_containing_t, constants_containing_t) = segment_containing_also_segments_less_than_xi(loadtim, loadmag, tvals, steps_or_equal_to = True)</span>

<span class="s2">        for i, t in enumerate(tvals):</span>
<span class="s2">            for k in constants_containing_t[i]:</span>
<span class="s2">                for j, eig in enumerate(eigs):</span>
<span class="s2">                    A[i,j] += (</span><span class="si">{0}</span><span class="s2">)</span>
<span class="s2">            for k in constants_less_than_t[i]:</span>
<span class="s2">                for j, eig in enumerate(eigs):</span>
<span class="s2">                    A[i,j] += (</span><span class="si">{1}</span><span class="s2">)</span>
<span class="s2">            for k in ramps_containing_t[i]:</span>
<span class="s2">                for j, eig in enumerate(eigs):</span>
<span class="s2">                    A[i,j] += (</span><span class="si">{2}</span><span class="s2">)</span>
<span class="s2">            for k in ramps_less_than_t[i]:</span>
<span class="s2">                for j, eig in enumerate(eigs):</span>
<span class="s2">                    A[i,j] += (</span><span class="si">{3}</span><span class="s2">)</span>
<span class="s2">    elif implementation == &#39;fortran&#39;:</span>
<span class="s2">        #note than all fortran subroutines are lowercase.</span>

<span class="s2">        if MUST_TRY_FORTRAN:</span>
<span class="s2">            from geotecha.speccon.ext_integrals import eload_linear as fn</span>
<span class="s2">        else:</span>
<span class="s2">            try:</span>
<span class="s2">                from geotecha.speccon.ext_integrals import eload_linear as fn</span>
<span class="s2">            except ImportError:</span>
<span class="s2">                fn = Eload_linear</span>
<span class="s2">        A = fn(loadtim, loadmag, eigs, tvals, dT)</span>
<span class="s2">    else:#default is &#39;vectorized&#39; using numpy</span>
<span class="s2">        sin = np.sin</span>
<span class="s2">        cos = np.cos</span>
<span class="s2">        exp = np.exp</span>

<span class="s2">        A = np.zeros([len(tvals), len(eigs)], dtype=complex)</span>

<span class="s2">        (ramps_less_than_t, constants_less_than_t, steps_less_than_t,</span>
<span class="s2">            ramps_containing_t, constants_containing_t) = segment_containing_also_segments_less_than_xi(loadtim, loadmag, tvals, steps_or_equal_to = True)</span>

<span class="s2">        eig = eigs[:, None]</span>
<span class="s2">        for i, t in enumerate(tvals):</span>
<span class="s2">            k = constants_containing_t[i]</span>
<span class="s2">            if len(k):</span>
<span class="s2">                A[i, :] += np.sum(</span><span class="si">{0}</span><span class="s2">, axis=1)</span>

<span class="s2">            k = constants_less_than_t[i]</span>
<span class="s2">            if len(k):</span>
<span class="s2">                A[i, :] += np.sum(</span><span class="si">{1}</span><span class="s2">, axis=1)</span>

<span class="s2">            k = ramps_containing_t[i]</span>
<span class="s2">            if len(k):</span>
<span class="s2">                A[i, :] += np.sum(</span><span class="si">{2}</span><span class="s2">, axis=1)</span>

<span class="s2">            k = ramps_less_than_t[i]</span>
<span class="s2">            if len(k):</span>
<span class="s2">                A[i, :] += np.sum(</span><span class="si">{3}</span><span class="s2">, axis=1)</span>
<span class="s2">    return A&quot;&quot;&quot;</span>



    <span class="n">text_fortran</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">      SUBROUTINE eload_linear(loadtim, loadmag, eigs, tvals,&amp;</span>
<span class="s2">                              dT, a, neig, nload, nt)</span>
<span class="s2">        USE types</span>
<span class="s2">        IMPLICIT NONE</span>

<span class="s2">        INTEGER, intent(in) :: neig</span>
<span class="s2">        INTEGER, intent(in) :: nload</span>
<span class="s2">        INTEGER, intent(in) :: nt</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nload-1) :: loadtim</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nload-1) :: loadmag</span>
<span class="s2">        COMPLEX(DP), intent(in), dimension(0:neig-1) :: eigs</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nt-1) :: tvals</span>
<span class="s2">        REAL(DP), intent(in) :: dT</span>
<span class="s2">        COMPLEX(DP), intent(out), dimension(0:nt-1, 0:neig-1) :: a</span>
<span class="s2">        INTEGER :: i , j, k</span>
<span class="s2">        REAL(DP):: EPSILON</span>
<span class="s2">        a=0.0D0</span>
<span class="s2">        EPSILON = 0.0000005D0</span>
<span class="s2">        DO i = 0, nt-1</span>
<span class="s2">          DO k = 0, nload-2</span>

<span class="s2">            IF (tvals(i) &lt; loadtim(k)) EXIT !t is before load step</span>

<span class="s2">            IF (tvals(i) &gt;= loadtim(k + 1)) THEN</span>
<span class="s2">              !t is after the load step</span>
<span class="s2">              IF(ABS(loadtim(k) - loadtim(k + 1)) &lt;= &amp;</span>
<span class="s2">                (ABS(loadtim(k) + loadtim(k + 1))*EPSILON)) THEN</span>
<span class="s2">                !step load</span>
<span class="s2">                CONTINUE</span>
<span class="s2">              ELSEIF(ABS(loadmag(k) - loadmag(k + 1)) &lt;= &amp;</span>
<span class="s2">                    (ABS(loadmag(k) + loadmag(k + 1))*EPSILON)) THEN</span>
<span class="s2">                !constant load</span>
<span class="s2">                DO j=0, neig-1</span>
<span class="si">{0}</span><span class="s2"></span>
<span class="s2">                END DO</span>
<span class="s2">              ELSE</span>
<span class="s2">                !ramp load</span>
<span class="s2">                DO j=0, neig-1</span>
<span class="si">{1}</span><span class="s2"></span>
<span class="s2">                END DO</span>
<span class="s2">              END IF</span>
<span class="s2">            ELSE</span>
<span class="s2">              !t is in the load step</span>
<span class="s2">              IF(ABS(loadmag(k) - loadmag(k + 1)) &lt;= &amp;</span>
<span class="s2">                    (ABS(loadmag(k) + loadmag(k + 1))*EPSILON)) THEN</span>
<span class="s2">                !constant load</span>
<span class="s2">                DO j=0, neig-1</span>
<span class="si">{2}</span><span class="s2"></span>
<span class="s2">                END DO</span>
<span class="s2">              ELSE</span>
<span class="s2">                !ramp load</span>
<span class="s2">                DO j=0, neig-1</span>
<span class="si">{3}</span><span class="s2"></span>
<span class="s2">                END DO</span>
<span class="s2">              END IF</span>
<span class="s2">            END IF</span>
<span class="s2">          END DO</span>
<span class="s2">        END DO</span>

<span class="s2">      END SUBROUTINE</span>



<span class="s2">    &quot;&quot;&quot;</span>



    <span class="n">fn</span> <span class="o">=</span> <span class="n">text_python</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">tw</span><span class="p">(</span><span class="n">within_constant</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="n">tw</span><span class="p">(</span><span class="n">after_constant</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="n">tw</span><span class="p">(</span><span class="n">within_ramp</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="n">tw</span><span class="p">(</span><span class="n">after_ramp</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>


    <span class="n">mp3</span> <span class="o">=</span> <span class="p">[(</span><span class="n">eig</span><span class="p">,</span> <span class="n">eigs</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">tvals</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
    <span class="n">after_constant</span> <span class="o">=</span> <span class="n">after_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp3</span><span class="p">)</span>
    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">after_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp3</span><span class="p">)</span>
    <span class="n">within_constant</span> <span class="o">=</span> <span class="n">within_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp3</span><span class="p">)</span>
    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">within_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp3</span><span class="p">)</span>
    <span class="n">fn2</span> <span class="o">=</span> <span class="n">text_fortran</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">after_constant</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">),</span>
        <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">after_ramp</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">),</span>
        <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">within_constant</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">),</span>
        <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">within_ramp</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fn2</span></div>


<div class="viewcode-block" id="EDload_linear_implementations"><a class="viewcode-back" href="../../../api/geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.EDload_linear_implementations">[docs]</a><span class="k">def</span> <span class="nf">EDload_linear_implementations</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Code generation for Integration of D[load(tau), tau] * exp(dT * eig * (t-tau)) between</span>
<span class="sd">    [0, t], where load(tau) is piecewise linear.</span>

<span class="sd">    Performs integrations involving a piecewise linear load.  A 2d array of</span>
<span class="sd">    dimensions A[len(tvals), len(eigs)]</span>
<span class="sd">    is produced where the &#39;i&#39;th row of A contains the diagonal elements of the</span>
<span class="sd">    spectral &#39;E&#39; matrix calculated for the time value tvals[i]. i.e. rows of</span>
<span class="sd">    this matrix will be assembled into the diagonal matrix &#39;E&#39; elsewhere.</span>

<span class="sd">    Paste the resulting code (at least the loops) into `EDload_linear`.</span>

<span class="sd">    Creates three implementations:</span>

<span class="sd">     - &#39;scalar&#39;, python loops (slowest).</span>
<span class="sd">     - &#39;vectorized&#39;, numpy (much faster than scalar).</span>
<span class="sd">     - &#39;fortran&#39;, fortran loops (fastest).  Needs to be compiled and interfaced</span>
<span class="sd">       with f2py.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fn : string</span>
<span class="sd">        Python code with scalar (loops) and vectorized (numpy) implementations</span>
<span class="sd">        also calls the fortran version.</span>
<span class="sd">    fn2 : string</span>
<span class="sd">        Fortran code.  needs to be compiled with f2py</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Assuming the load are formulated as the product of separate time and depth</span>
<span class="sd">    dependant functions:</span>

<span class="sd">    .. math:: \\sigma\\left({Z,t}\\right)=\\sigma\\left({Z}\\right)\\sigma\\left({t}\\right)</span>

<span class="sd">    the solution to the consolidation equation using the spectral method has</span>
<span class="sd">    the form:</span>

<span class="sd">    .. math:: u\\left(Z,t\\right)=\\mathbf{\\Phi v E}\\left(\\mathbf{\\Gamma v}\\right)^{-1}\\mathbf{\\theta}</span>

<span class="sd">    The matrix :math:`E` is a time dependent diagonal matrix due to time</span>
<span class="sd">    dependant loadings.  The version of :math:`E` calculated here in</span>
<span class="sd">    `EDload_linear` is from loading terms in the governing equation that are NOT</span>
<span class="sd">    differentiated wrt :math:`t`.</span>
<span class="sd">    The diagonal elements of :math:`E` are given by:</span>

<span class="sd">    .. math:: \\mathbf{E}_{i,i}=\\int_{0}^t{\\frac{d{\\sigma\\left(\\tau\\right)}}{d\\tau}{\\exp\\left({(dT\\left(t-\\tau\\right)\\lambda_i}\\right)}\\,d\\tau}</span>

<span class="sd">    where</span>

<span class="sd">     :math:`\\lambda_i` is the `ith` eigenvalue of the problem,</span>
<span class="sd">     :math:`dT` is a time factor for numerical convienience,</span>
<span class="sd">     :math:`\\sigma\left(\\tau\\right)` is the time dependant portion of the loading function.</span>

<span class="sd">    When the time dependant loading term :math:`\\sigma\\left(\\tau\\right)` is</span>
<span class="sd">    piecewise in time. The contribution of each load segment is found by:</span>

<span class="sd">    .. math:: \\mathbf{E}_{i,i}=\\int_{t_s}^{t_f}{{\\sigma\\left(\\tau\\right)}\\exp\\left({dT\\left(t-\\tau\\right)*\\lambda_i}\\right)\\,d\\tau}</span>

<span class="sd">    where</span>

<span class="sd">    .. math:: t_s = \\min\\left(t,t_{increment\\:start}\\right)</span>

<span class="sd">    .. math:: t_f = \\min\\left(t,t_{increment\\:end}\\right)</span>

<span class="sd">    (note that this function,`EDload_linear`, rather than use :math:`t_s` and</span>
<span class="sd">    :math:`t_f`,</span>
<span class="sd">    explicitly finds increments that the current time falls in, falls after,</span>
<span class="sd">    and falls before and treates each case on it&#39;s own.)</span>

<span class="sd">    Each :math:`t` value of interest requires a separate diagonal matrix</span>
<span class="sd">    :math:`E`.  To use space more efficiently and to facilitate numpy</span>
<span class="sd">    broadcasting when using the results of the function, the diagonal elements</span>
<span class="sd">    of :math:`E` for each time value `t` value are stored in the rows of</span>
<span class="sd">    array :math:`A` returned by `EDload_linear`.  Thus:</span>

<span class="sd">    .. math:: \\mathbf{A}=\\left(\\begin{matrix}E_{0,0}(t_0)&amp;E_{1,1}(t_0)&amp; \cdots &amp; E_{neig-1,neig-1}(t_0)\\\ E_{0,0}(t_1)&amp;E_{1,1}(t_1)&amp; \\cdots &amp; E_{neig-1,neig-1}(t_1)\\\ \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots \\\ E_{0,0}(t_m)&amp;E_{1,1}(t_m)&amp; \cdots &amp; E_{neig-1,neig-1}(t_m)\\end{matrix}\\right)</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    geotecha.speccon.integrals.EDload_linear : Resulting function.</span>
<span class="sd">    geotecha.speccon.integrals.pEDload_linear : Resulting function with PolyLine</span>
<span class="sd">        inputs.</span>
<span class="sd">    geotecha.speccon.ext_integrals.edload_linear : Resulting fortran function.</span>
<span class="sd">    EDload_coslinear_implementations : Similar function with</span>
<span class="sd">        additional cosine term.</span>
<span class="sd">    Eload_linear_implementations : Similar function but the time dependent</span>
<span class="sd">        loading function is not differentiated with respect to time.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">exp</span>

    <span class="n">sympy</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;t, tau, dT, eig&#39;</span><span class="p">)</span>
    <span class="n">loadmag</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;loadmag&#39;</span><span class="p">)</span>
    <span class="n">loadtim</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;loadtim&#39;</span><span class="p">)</span>
    <span class="n">tvals</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;tvals&#39;</span><span class="p">)</span>
    <span class="n">eigs</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;eigs&#39;</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;j&#39;</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>


    <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">sig0</span><span class="p">,</span> <span class="n">sig1</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;t0, t1, sig0, sig1&#39;</span><span class="p">)</span>
    <span class="n">load</span> <span class="o">=</span> <span class="n">sig0</span> <span class="o">+</span> <span class="p">(</span><span class="n">sig1</span> <span class="o">-</span> <span class="n">sig0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tau</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span>

    <span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, x0, x1&#39;</span><span class="p">)</span>
    <span class="n">load</span> <span class="o">=</span> <span class="n">load</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">x</span><span class="o">/</span><span class="p">(</span><span class="n">dT</span><span class="o">*</span><span class="n">eig</span><span class="p">)</span><span class="o">+</span><span class="n">t</span><span class="p">)</span>
    <span class="n">dx_dtau</span> <span class="o">=</span> <span class="n">dT</span> <span class="o">*</span> <span class="n">eig</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x0</span><span class="p">,</span> <span class="o">-</span><span class="n">dT</span> <span class="o">*</span> <span class="n">eig</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t0</span><span class="p">)),</span>
          <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="o">-</span><span class="n">dT</span> <span class="o">*</span> <span class="n">eig</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t1</span><span class="p">))]</span>
<span class="c1">#    the default output for the integrals will have expression s like</span>
<span class="c1">#    exp(-dT*eig*t)*exp(dT*eig*loadtim[k]).  when dT*eig*loadtim[k] is large</span>
<span class="c1">#    the exponential may be so large as to cause an error.  YOu may need to</span>
<span class="c1">#    manually alter the expression to exp(is large exp(-dT*eig*(t-loadtim[k]))</span>
<span class="c1">#    in which case the term in the exponential will always be negative and not</span>
<span class="c1">#    lead to any numerical blow up.</span>

    <span class="n">mp2</span> <span class="o">=</span> <span class="p">[(</span><span class="n">sig0</span><span class="p">,</span> <span class="n">loadmag</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">sig1</span><span class="p">,</span> <span class="n">loadmag</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">loadtim</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">loadtim</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])]</span>


    <span class="n">Dload</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">load</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx_dtau</span>
    <span class="n">after_instant</span> <span class="o">=</span> <span class="p">(</span><span class="n">sig1</span> <span class="o">-</span> <span class="n">sig0</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">after_instant</span> <span class="o">=</span> <span class="n">after_instant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="n">after_instant</span> <span class="o">=</span> <span class="n">after_instant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>

    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">Dload</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx_dtau</span>
    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">within_ramp</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">within_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">within_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>

    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">Dload</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx_dtau</span>
    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">after_ramp</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">after_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">after_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>



    <span class="n">text_python</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">def EDload_linear(loadtim, loadmag, eigs, tvals, dT=1.0, implementation=&#39;vectorized&#39;):</span>

<span class="s2">    loadtim = np.asarray(loadtim)</span>
<span class="s2">    loadmag = np.asarray(loadmag)</span>
<span class="s2">    eigs = np.asarray(eigs)</span>
<span class="s2">    tvals = np.asarray(tvals)</span>

<span class="s2">    if implementation == &#39;scalar&#39;:</span>
<span class="s2">        sin = math.sin</span>
<span class="s2">        cos = math.cos</span>
<span class="s2">        exp = math.exp</span>

<span class="s2">        A = np.zeros([len(tvals), len(eigs)])</span>

<span class="s2">        (ramps_less_than_t, constants_less_than_t, steps_less_than_t,</span>
<span class="s2">            ramps_containing_t, constants_containing_t) = segment_containing_also_segments_less_than_xi(loadtim, loadmag, tvals, steps_or_equal_to = True)</span>

<span class="s2">        for i, t in enumerate(tvals):</span>
<span class="s2">            for k in steps_less_than_t[i]:</span>
<span class="s2">                for j, eig in enumerate(eigs):</span>
<span class="s2">                    A[i,j] += (</span><span class="si">{0}</span><span class="s2">)</span>
<span class="s2">            for k in ramps_containing_t[i]:</span>
<span class="s2">                for j, eig in enumerate(eigs):</span>
<span class="s2">                    A[i,j] += (</span><span class="si">{1}</span><span class="s2">)</span>
<span class="s2">            for k in ramps_less_than_t[i]:</span>
<span class="s2">                for j, eig in enumerate(eigs):</span>
<span class="s2">                    A[i,j] += (</span><span class="si">{2}</span><span class="s2">)</span>

<span class="s2">    elif implementation == &#39;fortran&#39;:</span>
<span class="s2">        #note than all fortran subroutines are lowercase.</span>
<span class="s2">        if MUST_TRY_FORTRAN:</span>
<span class="s2">            from geotecha.speccon.ext_integrals import edload_linear as fn</span>
<span class="s2">        else:</span>
<span class="s2">            try:</span>
<span class="s2">                from geotecha.speccon.ext_integrals import edload_linear as fn</span>
<span class="s2">            except ImportError:</span>
<span class="s2">                fn = EDload_linear</span>
<span class="s2">        A = fn(loadtim, loadmag, eigs, tvals, dT)</span>

<span class="s2">    else:#default is &#39;vectorized&#39; using numpy</span>
<span class="s2">        sin = np.sin</span>
<span class="s2">        cos = np.cos</span>
<span class="s2">        exp = np.exp</span>

<span class="s2">        A = np.zeros([len(tvals), len(eigs)])</span>

<span class="s2">        (ramps_less_than_t, constants_less_than_t, steps_less_than_t,</span>
<span class="s2">            ramps_containing_t, constants_containing_t) = segment_containing_also_segments_less_than_xi(loadtim, loadmag, tvals, steps_or_equal_to = True)</span>

<span class="s2">        eig = eigs[:, None]</span>


<span class="s2">        for i, t in enumerate(tvals):</span>
<span class="s2">            k = steps_less_than_t[i]</span>
<span class="s2">            if len(k):</span>
<span class="s2">                A[i, :] += np.sum(</span><span class="si">{0}</span><span class="s2">, axis=1)</span>
<span class="s2">            k = ramps_containing_t[i]</span>
<span class="s2">            if len(k):</span>
<span class="s2">                A[i, :] += np.sum(</span><span class="si">{1}</span><span class="s2">, axis=1)</span>
<span class="s2">            k = ramps_less_than_t[i]</span>
<span class="s2">            if len(k):</span>
<span class="s2">                A[i, :] += np.sum(</span><span class="si">{2}</span><span class="s2">, axis=1)</span>
<span class="s2">    return A&quot;&quot;&quot;</span>



    <span class="n">text_fortran</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">      SUBROUTINE edload_linear(loadtim, loadmag, eigs, tvals,&amp;</span>
<span class="s2">                               dT, a, neig, nload, nt)</span>
<span class="s2">        USE types</span>
<span class="s2">        IMPLICIT NONE</span>

<span class="s2">        INTEGER, intent(in) :: neig</span>
<span class="s2">        INTEGER, intent(in) :: nload</span>
<span class="s2">        INTEGER, intent(in) :: nt</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nload-1) :: loadtim</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nload-1) :: loadmag</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:neig-1) :: eigs</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nt-1) :: tvals</span>
<span class="s2">        REAL(DP), intent(in) :: dT</span>
<span class="s2">        REAL(DP), intent(out), dimension(0:nt-1, 0:neig-1) :: a</span>
<span class="s2">        INTEGER :: i , j, k</span>
<span class="s2">        REAL(DP):: EPSILON</span>
<span class="s2">        a=0.0D0</span>
<span class="s2">        EPSILON = 0.0000005D0</span>
<span class="s2">        DO i = 0, nt-1</span>
<span class="s2">          DO k = 0, nload-2</span>

<span class="s2">            IF (tvals(i) &lt; loadtim(k)) EXIT !t is before load step</span>

<span class="s2">            IF (tvals(i) &gt;= loadtim(k + 1)) THEN</span>
<span class="s2">              !t is after the load step</span>
<span class="s2">              IF(ABS(loadtim(k) - loadtim(k + 1)) &lt;= &amp;</span>
<span class="s2">                (ABS(loadtim(k) + loadtim(k + 1))*EPSILON)) THEN</span>
<span class="s2">                !step load</span>
<span class="s2">                DO j=0, neig-1</span>
<span class="si">{0}</span><span class="s2"></span>
<span class="s2">                END DO</span>
<span class="s2">              ELSEIF(ABS(loadmag(k) - loadmag(k + 1)) &lt;= &amp;</span>
<span class="s2">                    (ABS(loadmag(k) + loadmag(k + 1))*EPSILON)) THEN</span>
<span class="s2">                !constant load</span>
<span class="s2">                CONTINUE</span>
<span class="s2">              ELSE</span>
<span class="s2">                !ramp load</span>
<span class="s2">                DO j=0, neig-1</span>
<span class="si">{1}</span><span class="s2"></span>
<span class="s2">                END DO</span>
<span class="s2">              END IF</span>
<span class="s2">            ELSE</span>
<span class="s2">              !t is in the load step</span>
<span class="s2">              IF(ABS(loadmag(k) - loadmag(k + 1)) &lt;= &amp;</span>
<span class="s2">                    (ABS(loadmag(k) + loadmag(k + 1))*EPSILON)) THEN</span>
<span class="s2">                !constant load</span>
<span class="s2">                CONTINUE</span>
<span class="s2">              ELSE</span>
<span class="s2">                !ramp load</span>
<span class="s2">                DO j=0, neig-1</span>
<span class="si">{2}</span><span class="s2"></span>
<span class="s2">                END DO</span>
<span class="s2">              END IF</span>
<span class="s2">            END IF</span>
<span class="s2">          END DO</span>
<span class="s2">        END DO</span>

<span class="s2">      END SUBROUTINE</span>



<span class="s2">    &quot;&quot;&quot;</span>



    <span class="n">fn</span> <span class="o">=</span> <span class="n">text_python</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">tw</span><span class="p">(</span><span class="n">after_instant</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="n">tw</span><span class="p">(</span><span class="n">within_ramp</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="n">tw</span><span class="p">(</span><span class="n">after_ramp</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>


    <span class="n">mp3</span> <span class="o">=</span> <span class="p">[(</span><span class="n">eig</span><span class="p">,</span> <span class="n">eigs</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tvals</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
    <span class="n">after_instant</span> <span class="o">=</span> <span class="n">after_instant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp3</span><span class="p">)</span>
    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">after_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp3</span><span class="p">)</span>
    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">within_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp3</span><span class="p">)</span>
    <span class="n">fn2</span> <span class="o">=</span> <span class="n">text_fortran</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">after_instant</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">),</span>
        <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">after_ramp</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">),</span>
        <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">within_ramp</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fn2</span></div>


<div class="viewcode-block" id="Eload_coslinear_implementations"><a class="viewcode-back" href="../../../api/geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.Eload_coslinear_implementations">[docs]</a><span class="k">def</span> <span class="nf">Eload_coslinear_implementations</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Code generation for Integration of cos(omega*tau+phase)*load(tau) * exp(dT * eig * (t-tau))</span>
<span class="sd">    between [0, t], where load(tau) is piecewise linear.</span>

<span class="sd">    Performs integrations involving a piecewise linear load.  A 2d array of</span>
<span class="sd">    dimensions A[len(tvals), len(eigs)]</span>
<span class="sd">    is produced where the &#39;i&#39;th row of A contains the diagonal elements of the</span>
<span class="sd">    spectral &#39;E&#39; matrix calculated for the time value tvals[i]. i.e. rows of</span>
<span class="sd">    this matrix will be assembled into the diagonal matrix &#39;E&#39; elsewhere.</span>


<span class="sd">    Paste the resulting code (at least the loops) into `Eload_coslinear`.</span>

<span class="sd">    Creates three implementations:</span>

<span class="sd">     - &#39;scalar&#39;, python loops (slowest).</span>
<span class="sd">     - &#39;vectorized&#39;, numpy (much faster than scalar).</span>
<span class="sd">     - &#39;fortran&#39;, fortran loops (fastest).  Needs to be compiled and interfaced</span>
<span class="sd">       with f2py.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fn : string</span>
<span class="sd">        Python code with scalar (loops) and vectorized (numpy) implementations</span>
<span class="sd">        also calls the fortran version.</span>
<span class="sd">    fn2 : string</span>
<span class="sd">        Fortran code.  needs to be compiled with f2py</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Assuming the load are formulated as the product of separate time and depth</span>
<span class="sd">    dependant functions:</span>

<span class="sd">    .. math:: \\sigma\\left({Z,t}\\right)=\\sigma\\left({Z}\\right)\\sigma\\left({t}\\right)</span>

<span class="sd">    the solution to the consolidation equation using the spectral method has</span>
<span class="sd">    the form:</span>

<span class="sd">    .. math:: u\\left(Z,t\\right)=\\mathbf{\\Phi v E}\\left(\\mathbf{\\Gamma v}\\right)^{-1}\\mathbf{\\theta}</span>

<span class="sd">    The matrix :math:`E` is a time dependent diagonal matrix due to time</span>
<span class="sd">    dependant loadings.  The version of :math:`E` calculated here in</span>
<span class="sd">    `Eload_coslinear` is from loading terms in the governing equation that are NOT</span>
<span class="sd">    differentiated wrt :math:`t`.</span>
<span class="sd">    The diagonal elements of :math:`E` are given by:</span>

<span class="sd">    .. math:: \\mathbf{E}_{i,i}=\\int_{0}^t{{\\cos\\left(\\omega\\tau+\\textrm{phase}\\right)}{\\sigma\\left(\\tau\\right)}{\exp\\left({(dT\\left(t-\\tau\\right)\\lambda_i}\\right)}\\,d\\tau}</span>

<span class="sd">    where</span>

<span class="sd">     :math:`\\lambda_i` is the `ith` eigenvalue of the problem,</span>
<span class="sd">     :math:`dT` is a time factor for numerical convienience,</span>
<span class="sd">     :math:`\\sigma\left(\\tau\\right)` is the time dependant portion of the loading function.</span>

<span class="sd">    When the time dependant loading term :math:`\\sigma\\left(\\tau\\right)` is</span>
<span class="sd">    piecewise in time. The contribution of each load segment is found by:</span>

<span class="sd">    .. math:: \\mathbf{E}_{i,i}=\\int_{t_s}^{t_f}{{\\cos\\left(\\omega\\tau+\\textrm{phase}\\right)}{\\sigma\\left(\\tau\\right)}\\exp\\left({dT\\left(t-\\tau\\right)*\\lambda_i}\\right)\\,d\\tau}</span>

<span class="sd">    where</span>

<span class="sd">    .. math:: t_s = \\min\\left(t,t_{increment\\:start}\\right)</span>

<span class="sd">    .. math:: t_f = \\min\\left(t,t_{increment\\:end}\\right)</span>

<span class="sd">    (note that this function,`Eload_coslinear`, rather than use :math:`t_s` and</span>
<span class="sd">    :math:`t_f`,</span>
<span class="sd">    explicitly finds increments that the current time falls in, falls after,</span>
<span class="sd">    and falls before and treates each case on it&#39;s own.)</span>

<span class="sd">    Each :math:`t` value of interest requires a separate diagonal matrix</span>
<span class="sd">    :math:`E`.  To use space more efficiently and to facilitate numpy</span>
<span class="sd">    broadcasting when using the results of the function, the diagonal elements</span>
<span class="sd">    of :math:`E` for each time value `t` value are stored in the rows of</span>
<span class="sd">    array :math:`A` returned by `Eload_coslinear`.  Thus:</span>

<span class="sd">    .. math:: \\mathbf{A}=\\left(\\begin{matrix}E_{0,0}(t_0)&amp;E_{1,1}(t_0)&amp; \cdots &amp; E_{neig-1,neig-1}(t_0)\\\ E_{0,0}(t_1)&amp;E_{1,1}(t_1)&amp; \\cdots &amp; E_{neig-1,neig-1}(t_1)\\\ \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots \\\ E_{0,0}(t_m)&amp;E_{1,1}(t_m)&amp; \cdots &amp; E_{neig-1,neig-1}(t_m)\\end{matrix}\\right)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    geotecha.speccon.integrals.Eload_coslinear : Resulting function.</span>
<span class="sd">    geotecha.speccon.integrals.pEload_coslinear : Resulting function with PolyLine</span>
<span class="sd">        inputs.</span>
<span class="sd">    geotecha.speccon.ext_integrals.eload_coslinear : Resulting fortran function.</span>
<span class="sd">    Eload_linear_implementations : Similar function with no</span>
<span class="sd">        cosine term.</span>
<span class="sd">    EDload_coslinear_implementations : Similar function but the time dependent</span>
<span class="sd">        loading function is differentiated with respect to time.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">exp</span>

    <span class="n">sympy</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;t, tau, dT, eig, omega, phase&#39;</span><span class="p">)</span>
    <span class="n">loadmag</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;loadmag&#39;</span><span class="p">)</span>
    <span class="n">loadtim</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;loadtim&#39;</span><span class="p">)</span>
    <span class="n">tvals</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;tvals&#39;</span><span class="p">)</span>
    <span class="n">eigs</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;eigs&#39;</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;j&#39;</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>


    <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">sig0</span><span class="p">,</span> <span class="n">sig1</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;t0, t1, sig0, sig1&#39;</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, x0, x1&#39;</span><span class="p">)</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;A, B&#39;</span><span class="p">)</span>
<span class="c1">#    load1 = sympy.cos(omega * tau + phase)</span>
    <span class="n">load1</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">B</span><span class="p">)</span>
    <span class="n">load2</span> <span class="o">=</span> <span class="n">sig0</span> <span class="o">+</span> <span class="p">(</span><span class="n">sig1</span> <span class="o">-</span> <span class="n">sig0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tau</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span>

    <span class="n">load1</span> <span class="o">=</span> <span class="n">load1</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">x</span><span class="o">/</span><span class="p">(</span><span class="n">dT</span><span class="o">*</span><span class="n">eig</span><span class="p">)</span><span class="o">+</span><span class="n">t</span><span class="p">)</span>
    <span class="n">load2</span> <span class="o">=</span> <span class="n">load2</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">x</span><span class="o">/</span><span class="p">(</span><span class="n">dT</span><span class="o">*</span><span class="n">eig</span><span class="p">)</span><span class="o">+</span><span class="n">t</span><span class="p">)</span>

    <span class="n">dx_dtau</span> <span class="o">=</span> <span class="n">dT</span> <span class="o">*</span> <span class="n">eig</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x0</span><span class="p">,</span> <span class="o">-</span><span class="n">dT</span> <span class="o">*</span> <span class="n">eig</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t0</span><span class="p">)),</span>
          <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="o">-</span><span class="n">dT</span> <span class="o">*</span> <span class="n">eig</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t1</span><span class="p">)),</span>
            <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">omega</span> <span class="o">/</span> <span class="p">(</span><span class="n">dT</span><span class="o">*</span><span class="n">eig</span><span class="p">)),</span>
            <span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">omega</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">phase</span><span class="p">)]</span>

    <span class="n">mp2</span> <span class="o">=</span> <span class="p">[(</span><span class="n">sig0</span><span class="p">,</span> <span class="n">loadmag</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">sig1</span><span class="p">,</span> <span class="n">loadmag</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">loadtim</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span>
            <span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">loadtim</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])]</span>
<span class="c1">#    mp = [(exp(-dT*eig*t)*exp(dT*eig*loadtim[k]),</span>
<span class="c1">#           exp(-dT*eig*(t-loadtim[k]))),</span>
<span class="c1">#          (exp(-dT*eig*t)*exp(dT*eig*loadtim[k+1]),</span>
<span class="c1">#           exp(-dT*eig*(t-loadtim[k+1])))]</span>
<span class="c1">#    the default output for the integrals will have expression s like</span>
<span class="c1">#    exp(-dT*eig*t)*exp(dT*eig*loadtim[k]).  when dT*eig*loadtim[k] is large</span>
<span class="c1">#    the exponential may be so large as to cause an error.  YOu may need to</span>
<span class="c1">#    manually alter the expression to exp(is large exp(-dT*eig*(t-loadtim[k]))</span>
<span class="c1">#    in which case the term in the exponential will always be negative and not</span>
<span class="c1">#    lead to any numerical blow up.</span>
<span class="c1">#    load = linear(tau, loadtim[k], loadmag[k], loadtim[k+1], loadmag[k+1])</span>
<span class="c1">#    after_instant = (loadmag[k+1] - loadmag[k]) * exp(-dT * eig * (t - loadtim[k]))</span>
<span class="c1">#    mp does this automatically with subs</span>
<span class="c1">#    load = linear(tau, loadtim[k], loadmag[k], loadtim[k+1], loadmag[k+1])</span>
    <span class="n">within_constant</span> <span class="o">=</span> <span class="n">sig0</span> <span class="o">*</span> <span class="n">load1</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx_dtau</span>
    <span class="n">within_constant</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">within_constant</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span><span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">within_constant</span> <span class="o">=</span> <span class="n">within_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="n">within_constant</span> <span class="o">=</span> <span class="n">within_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>
    <span class="n">after_constant</span> <span class="o">=</span> <span class="n">sig0</span> <span class="o">*</span> <span class="n">load1</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx_dtau</span>
    <span class="n">after_constant</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">after_constant</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">after_constant</span> <span class="o">=</span> <span class="n">after_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="n">after_constant</span> <span class="o">=</span> <span class="n">after_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>

    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">load1</span> <span class="o">*</span> <span class="n">load2</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx_dtau</span>
    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">within_ramp</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">within_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">within_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>

    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">load1</span> <span class="o">*</span> <span class="n">load2</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx_dtau</span>
    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">after_ramp</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">after_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">after_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>


    <span class="n">text_python</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">def Eload_coslinear(loadtim, loadmag, omega, phase, eigs, tvals, dT=1.0, implementation=&#39;vectorized&#39;):</span>

<span class="s2">    loadtim = np.asarray(loadtim)</span>
<span class="s2">    loadmag = np.asarray(loadmag)</span>
<span class="s2">    eigs = np.asarray(eigs)</span>
<span class="s2">    tvals = np.asarray(tvals)</span>

<span class="s2">    if implementation == &#39;scalar&#39;:</span>
<span class="s2">        sin = math.sin</span>
<span class="s2">        cos = math.cos</span>
<span class="s2">        exp = math.exp</span>

<span class="s2">        A = np.zeros([len(tvals), len(eigs)])</span>

<span class="s2">        (ramps_less_than_t, constants_less_than_t, steps_less_than_t,</span>
<span class="s2">            ramps_containing_t, constants_containing_t) = segment_containing_also_segments_less_than_xi(loadtim, loadmag, tvals, steps_or_equal_to = True)</span>

<span class="s2">        for i, t in enumerate(tvals):</span>
<span class="s2">            for k in constants_containing_t[i]:</span>
<span class="s2">                for j, eig in enumerate(eigs):</span>
<span class="s2">                    A[i,j] += (</span><span class="si">{0}</span><span class="s2">)</span>
<span class="s2">            for k in constants_less_than_t[i]:</span>
<span class="s2">                for j, eig in enumerate(eigs):</span>
<span class="s2">                    A[i,j] += (</span><span class="si">{1}</span><span class="s2">)</span>
<span class="s2">            for k in ramps_containing_t[i]:</span>
<span class="s2">                for j, eig in enumerate(eigs):</span>
<span class="s2">                    A[i,j] += (</span><span class="si">{2}</span><span class="s2">)</span>
<span class="s2">            for k in ramps_less_than_t[i]:</span>
<span class="s2">                for j, eig in enumerate(eigs):</span>
<span class="s2">                    A[i,j] += (</span><span class="si">{3}</span><span class="s2">)</span>
<span class="s2">    elif implementation == &#39;fortran&#39;:</span>
<span class="s2">        #note than all fortran subroutines are lowercase.</span>
<span class="s2">        if MUST_TRY_FORTRAN:</span>
<span class="s2">            from geotecha.speccon.ext_integrals import eload_coslinear as fn</span>
<span class="s2">        else:</span>
<span class="s2">            try:</span>
<span class="s2">                from geotecha.speccon.ext_integrals import eload_coslinear as fn</span>
<span class="s2">            except ImportError:</span>
<span class="s2">                fn = Eload_coslinear</span>
<span class="s2">        A = fn(loadtim, loadmag, omega, phase, eigs, tvals, dT)</span>

<span class="s2">    else:#default is &#39;vectorized&#39; using numpy</span>
<span class="s2">        sin = np.sin</span>
<span class="s2">        cos = np.cos</span>
<span class="s2">        exp = np.exp</span>

<span class="s2">        A = np.zeros([len(tvals), len(eigs)])</span>

<span class="s2">        (ramps_less_than_t, constants_less_than_t, steps_less_than_t,</span>
<span class="s2">            ramps_containing_t, constants_containing_t) = segment_containing_also_segments_less_than_xi(loadtim, loadmag, tvals, steps_or_equal_to = True)</span>

<span class="s2">        eig = eigs[:, None]</span>
<span class="s2">        for i, t in enumerate(tvals):</span>
<span class="s2">            k = constants_containing_t[i]</span>
<span class="s2">            if len(k):</span>
<span class="s2">                A[i, :] += np.sum(</span><span class="si">{0}</span><span class="s2">, axis=1)</span>

<span class="s2">            k = constants_less_than_t[i]</span>
<span class="s2">            if len(k):</span>
<span class="s2">                A[i, :] += np.sum(</span><span class="si">{1}</span><span class="s2">, axis=1)</span>

<span class="s2">            k = ramps_containing_t[i]</span>
<span class="s2">            if len(k):</span>
<span class="s2">                A[i, :] += np.sum(</span><span class="si">{2}</span><span class="s2">, axis=1)</span>

<span class="s2">            k = ramps_less_than_t[i]</span>
<span class="s2">            if len(k):</span>
<span class="s2">                A[i, :] += np.sum(</span><span class="si">{3}</span><span class="s2">, axis=1)</span>
<span class="s2">    return A&quot;&quot;&quot;</span>



    <span class="n">text_fortran</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">      SUBROUTINE eload_coslinear(loadtim, loadmag, omega, phase, &amp;</span>
<span class="s2">                                 eigs, tvals, dT, a, neig, nload, nt)</span>
<span class="s2">        USE types</span>
<span class="s2">        IMPLICIT NONE</span>

<span class="s2">        INTEGER, intent(in) :: neig</span>
<span class="s2">        INTEGER, intent(in) :: nload</span>
<span class="s2">        INTEGER, intent(in) :: nt</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nload-1) :: loadtim</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nload-1) :: loadmag</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:neig-1) :: eigs</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nt-1) :: tvals</span>
<span class="s2">        REAL(DP), intent(in) :: dT</span>
<span class="s2">        REAL(DP), intent(in) :: omega</span>
<span class="s2">        REAL(DP), intent(in) :: phase</span>
<span class="s2">        REAL(DP), intent(out), dimension(0:nt-1, 0:neig-1) :: a</span>
<span class="s2">        INTEGER :: i , j, k</span>
<span class="s2">        REAL(DP):: EPSILON</span>
<span class="s2">        a=0.0D0</span>
<span class="s2">        EPSILON = 0.0000005D0</span>
<span class="s2">        DO i = 0, nt-1</span>
<span class="s2">          DO k = 0, nload-2</span>

<span class="s2">            IF (tvals(i) &lt; loadtim(k)) EXIT !t is before load step</span>

<span class="s2">            IF (tvals(i) &gt;= loadtim(k + 1)) THEN</span>
<span class="s2">              !t is after the load step</span>
<span class="s2">              IF(ABS(loadtim(k) - loadtim(k + 1)) &lt;= &amp;</span>
<span class="s2">                (ABS(loadtim(k) + loadtim(k + 1))*EPSILON)) THEN</span>
<span class="s2">                !step load</span>
<span class="s2">                CONTINUE</span>
<span class="s2">              ELSEIF(ABS(loadmag(k) - loadmag(k + 1)) &lt;= &amp;</span>
<span class="s2">                    (ABS(loadmag(k) + loadmag(k + 1))*EPSILON)) THEN</span>
<span class="s2">                !constant load</span>
<span class="s2">                DO j=0, neig-1</span>
<span class="si">{0}</span><span class="s2"></span>
<span class="s2">                END DO</span>
<span class="s2">              ELSE</span>
<span class="s2">                !ramp load</span>
<span class="s2">                DO j=0, neig-1</span>
<span class="si">{1}</span><span class="s2"></span>
<span class="s2">                END DO</span>
<span class="s2">              END IF</span>
<span class="s2">            ELSE</span>
<span class="s2">              !t is in the load step</span>
<span class="s2">              IF(ABS(loadmag(k) - loadmag(k + 1)) &lt;= &amp;</span>
<span class="s2">                    (ABS(loadmag(k) + loadmag(k + 1))*EPSILON)) THEN</span>
<span class="s2">                !constant load</span>
<span class="s2">                DO j=0, neig-1</span>
<span class="si">{2}</span><span class="s2"></span>
<span class="s2">                END DO</span>
<span class="s2">              ELSE</span>
<span class="s2">                !ramp load</span>
<span class="s2">                DO j=0, neig-1</span>
<span class="si">{3}</span><span class="s2"></span>
<span class="s2">                END DO</span>
<span class="s2">              END IF</span>
<span class="s2">            END IF</span>
<span class="s2">          END DO</span>
<span class="s2">        END DO</span>

<span class="s2">      END SUBROUTINE</span>



<span class="s2">    &quot;&quot;&quot;</span>



    <span class="n">fn</span> <span class="o">=</span> <span class="n">text_python</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">tw</span><span class="p">(</span><span class="n">within_constant</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="n">tw</span><span class="p">(</span><span class="n">after_constant</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="n">tw</span><span class="p">(</span><span class="n">within_ramp</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="n">tw</span><span class="p">(</span><span class="n">after_ramp</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>


    <span class="n">mp3</span> <span class="o">=</span> <span class="p">[(</span><span class="n">eig</span><span class="p">,</span> <span class="n">eigs</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">tvals</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
    <span class="n">after_constant</span> <span class="o">=</span> <span class="n">after_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp3</span><span class="p">)</span>
    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">after_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp3</span><span class="p">)</span>
    <span class="n">within_constant</span> <span class="o">=</span> <span class="n">within_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp3</span><span class="p">)</span>
    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">within_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp3</span><span class="p">)</span>
    <span class="n">fn2</span> <span class="o">=</span> <span class="n">text_fortran</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">after_constant</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">),</span>
        <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">after_ramp</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">),</span>
        <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">within_constant</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">),</span>
        <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">within_ramp</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fn2</span></div>

<div class="viewcode-block" id="EDload_coslinear_implementations"><a class="viewcode-back" href="../../../api/geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.EDload_coslinear_implementations">[docs]</a><span class="k">def</span> <span class="nf">EDload_coslinear_implementations</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Code generation for Integration of D[cos(omega*tau+phase)*load(tau), tau] * exp(dT * eig * (t-tau)) between [0, t], where</span>
<span class="sd">    load(tau) is piecewise linear.</span>

<span class="sd">    Performs integrations involving a piecewise linear load.  A 2d array of</span>
<span class="sd">    dimensions A[len(tvals), len(eigs)]</span>
<span class="sd">    is produced where the &#39;i&#39;th row of A contains the diagonal elements of the</span>
<span class="sd">    spectral &#39;E&#39; matrix calculated for the time value tvals[i]. i.e. rows of</span>
<span class="sd">    this matrix will be assembled into the diagonal matrix &#39;E&#39; elsewhere.</span>

<span class="sd">    Paste the resulting code (at least the loops) into `EDload_coslinear`.</span>

<span class="sd">    Creates three implementations:</span>

<span class="sd">     - &#39;scalar&#39;, python loops (slowest).</span>
<span class="sd">     - &#39;vectorized&#39;, numpy (much faster than scalar).</span>
<span class="sd">     - &#39;fortran&#39;, fortran loops (fastest).  Needs to be compiled and interfaced</span>
<span class="sd">       with f2py.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fn : string</span>
<span class="sd">        Python code with scalar (loops) and vectorized (numpy) implementations</span>
<span class="sd">        also calls the fortran version.</span>
<span class="sd">    fn2 : string</span>
<span class="sd">        Fortran code.  Needs to be compiled with f2py.</span>

<span class="sd">        Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Assuming the load are formulated as the product of separate time and depth</span>
<span class="sd">    dependant functions:</span>

<span class="sd">    .. math:: \\sigma\\left({Z,t}\\right)=\\sigma\\left({Z}\\right)\\sigma\\left({t}\\right)</span>

<span class="sd">    the solution to the consolidation equation using the spectral method has</span>
<span class="sd">    the form:</span>

<span class="sd">    .. math:: u\\left(Z,t\\right)=\\mathbf{\\Phi v E}\\left(\\mathbf{\\Gamma v}\\right)^{-1}\\mathbf{\\theta}</span>

<span class="sd">    The matrix :math:`E` is a time dependent diagonal matrix due to time</span>
<span class="sd">    dependant loadings.  The version of :math:`E` calculated here in</span>
<span class="sd">    `EDload_coslinear` is from loading terms in the governing equation that are NOT</span>
<span class="sd">    differentiated wrt :math:`t`.</span>
<span class="sd">    The diagonal elements of :math:`E` are given by:</span>

<span class="sd">    .. math:: \\mathbf{E}_{i,i}=\\int_{0}^t{\\frac{d{{\\cos\\left(\\omega\\tau+\\textrm{phase}\\right)}\\sigma\\left(\\tau\\right)}}{d\\tau}{\\exp\\left({(dT\\left(t-\\tau\\right)\\lambda_i}\\right)}\\,d\\tau}</span>

<span class="sd">    where</span>

<span class="sd">     :math:`\\lambda_i` is the `ith` eigenvalue of the problem,</span>
<span class="sd">     :math:`dT` is a time factor for numerical convienience,</span>
<span class="sd">     :math:`\\sigma\left(\\tau\\right)` is the time dependant portion of the loading function.</span>

<span class="sd">    When the time dependant loading term :math:`\\sigma\\left(\\tau\\right)` is</span>
<span class="sd">    piecewise in time. The contribution of each load segment is found by:</span>

<span class="sd">    .. math:: \\mathbf{E}_{i,i}=\\int_{t_s}^{t_f}{\\frac{d{{\\cos\\left(\\omega\\tau+\\textrm{phase}\\right)}\\sigma\\left(\\tau\\right)}}{d\\tau}\\exp\\left({dT\\left(t-\\tau\\right)*\\lambda_i}\\right)\\,d\\tau}</span>

<span class="sd">    where</span>

<span class="sd">    .. math:: t_s = \\min\\left(t,t_{increment\\:start}\\right)</span>

<span class="sd">    .. math:: t_f = \\min\\left(t,t_{increment\\:end}\\right)</span>

<span class="sd">    (note that this function,`EDload_coslinear`, rather than use :math:`t_s` and</span>
<span class="sd">    :math:`t_f`,</span>
<span class="sd">    explicitly finds increments that the current time falls in, falls after,</span>
<span class="sd">    and falls before and treates each case on it&#39;s own.)</span>

<span class="sd">    Each :math:`t` value of interest requires a separate diagonal matrix</span>
<span class="sd">    :math:`E`.  To use space more efficiently and to facilitate numpy</span>
<span class="sd">    broadcasting when using the results of the function, the diagonal elements</span>
<span class="sd">    of :math:`E` for each time value `t` value are stored in the rows of</span>
<span class="sd">    array :math:`A` returned by `EDload_coslinear`.  Thus:</span>

<span class="sd">    .. math:: \\mathbf{A}=\\left(\\begin{matrix}E_{0,0}(t_0)&amp;E_{1,1}(t_0)&amp; \cdots &amp; E_{neig-1,neig-1}(t_0)\\\ E_{0,0}(t_1)&amp;E_{1,1}(t_1)&amp; \\cdots &amp; E_{neig-1,neig-1}(t_1)\\\ \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots \\\ E_{0,0}(t_m)&amp;E_{1,1}(t_m)&amp; \cdots &amp; E_{neig-1,neig-1}(t_m)\\end{matrix}\\right)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    geotecha.speccon.integrals.EDload_coslinear : Resulting function.</span>
<span class="sd">    geotecha.speccon.integrals.pEDload_coslinear : Resulting function with PolyLine</span>
<span class="sd">        inputs.</span>
<span class="sd">    geotecha.speccon.ext_integrals.edload_coslinear : Resulting fortran function.</span>
<span class="sd">    EDload_linear_implementations : Similar function with no</span>
<span class="sd">        cosine term.</span>
<span class="sd">    Eload_coslinear_implementations : Similar function but the time dependent</span>
<span class="sd">        loading function is not differentiated w.r.t. time.</span>



<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">exp</span>

    <span class="n">sympy</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;t, tau, dT, eig, omega, phase&#39;</span><span class="p">)</span>
    <span class="n">loadmag</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;loadmag&#39;</span><span class="p">)</span>
    <span class="n">loadtim</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;loadtim&#39;</span><span class="p">)</span>
    <span class="n">tvals</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;tvals&#39;</span><span class="p">)</span>
    <span class="n">eigs</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;eigs&#39;</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;j&#39;</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>


    <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">sig0</span><span class="p">,</span> <span class="n">sig1</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;t0, t1, sig0, sig1&#39;</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, x0, x1&#39;</span><span class="p">)</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;A, B&#39;</span><span class="p">)</span>
<span class="c1">#    load1 = sympy.cos(omega * tau + phase)</span>
    <span class="n">load1</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">B</span><span class="p">)</span>
    <span class="n">load2</span> <span class="o">=</span> <span class="n">sig0</span> <span class="o">+</span> <span class="p">(</span><span class="n">sig1</span> <span class="o">-</span> <span class="n">sig0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tau</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span>
    <span class="n">load2</span> <span class="o">=</span> <span class="n">load2</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">x</span><span class="o">/</span><span class="p">(</span><span class="n">dT</span><span class="o">*</span><span class="n">eig</span><span class="p">)</span><span class="o">+</span><span class="n">t</span><span class="p">)</span>

    <span class="n">dx_dtau</span> <span class="o">=</span> <span class="n">dT</span> <span class="o">*</span> <span class="n">eig</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x0</span><span class="p">,</span> <span class="o">-</span><span class="n">dT</span> <span class="o">*</span> <span class="n">eig</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t0</span><span class="p">)),</span>
          <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="o">-</span><span class="n">dT</span> <span class="o">*</span> <span class="n">eig</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t1</span><span class="p">)),</span>
            <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">omega</span> <span class="o">/</span> <span class="p">(</span><span class="n">dT</span><span class="o">*</span><span class="n">eig</span><span class="p">)),</span>
            <span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">omega</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">phase</span><span class="p">)]</span>

    <span class="n">mp2</span> <span class="o">=</span> <span class="p">[(</span><span class="n">sig0</span><span class="p">,</span> <span class="n">loadmag</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">sig1</span><span class="p">,</span> <span class="n">loadmag</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">loadtim</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span>
            <span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">loadtim</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])]</span>
<span class="c1">#    the default output for the integrals will have expression s like</span>
<span class="c1">#    exp(-dT*eig*t)*exp(dT*eig*loadtim[k]).  when dT*eig*loadtim[k] is large</span>
<span class="c1">#    the exponential may be so large as to cause an error.  YOu may need to</span>
<span class="c1">#    manually alter the expression to exp(is large exp(-dT*eig*(t-loadtim[k]))</span>
<span class="c1">#    in which case the term in the exponential will always be negative and not</span>
<span class="c1">#    lead to any numerical blow up.</span>

    <span class="n">mp2</span> <span class="o">=</span> <span class="p">[(</span><span class="n">sig0</span><span class="p">,</span> <span class="n">loadmag</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">sig1</span><span class="p">,</span> <span class="n">loadmag</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">loadtim</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">loadtim</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])]</span>


    <span class="n">Dload</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">load1</span> <span class="o">*</span> <span class="n">load2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx_dtau</span>
    <span class="n">after_instant</span> <span class="o">=</span> <span class="p">(</span><span class="n">sig1</span> <span class="o">-</span> <span class="n">sig0</span><span class="p">)</span> <span class="o">*</span> <span class="n">sympy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span> <span class="o">*</span> <span class="n">t0</span> <span class="o">+</span> <span class="n">phase</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dT</span> <span class="o">*</span> <span class="n">eig</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">t0</span><span class="p">))</span>
    <span class="n">after_instant</span> <span class="o">=</span> <span class="n">after_instant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="n">after_instant</span> <span class="o">=</span> <span class="n">after_instant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>

    <span class="n">within_constant</span> <span class="o">=</span> <span class="n">sig0</span> <span class="o">*</span> <span class="n">sympy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">load1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1">#dx_dtau cancels from diff and substitution</span>
    <span class="n">within_constant</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">within_constant</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">within_constant</span> <span class="o">=</span> <span class="n">within_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="n">within_constant</span> <span class="o">=</span> <span class="n">within_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>

    <span class="n">after_constant</span> <span class="o">=</span> <span class="n">sig0</span> <span class="o">*</span> <span class="n">sympy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">load1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1">#dx_dtau cancels from diff and substitution</span>
    <span class="n">after_constant</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">after_constant</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">after_constant</span> <span class="o">=</span> <span class="n">after_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="n">after_constant</span> <span class="o">=</span> <span class="n">after_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>


    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">Dload</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx_dtau</span>
    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">within_ramp</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">within_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">within_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>

    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">Dload</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx_dtau</span>
    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">after_ramp</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">after_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">after_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>



    <span class="n">text_python</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">def EDload_coslinear(loadtim, loadmag, omega, phase,eigs, tvals, dT=1.0, implementation=&#39;vectorized&#39;):</span>

<span class="s2">    loadtim = np.asarray(loadtim)</span>
<span class="s2">    loadmag = np.asarray(loadmag)</span>
<span class="s2">    eigs = np.asarray(eigs)</span>
<span class="s2">    tvals = np.asarray(tvals)</span>

<span class="s2">    if implementation == &#39;scalar&#39;:</span>
<span class="s2">        sin = math.sin</span>
<span class="s2">        cos = math.cos</span>
<span class="s2">        exp = math.exp</span>

<span class="s2">        A = np.zeros([len(tvals), len(eigs)])</span>

<span class="s2">        (ramps_less_than_t, constants_less_than_t, steps_less_than_t,</span>
<span class="s2">            ramps_containing_t, constants_containing_t) = segment_containing_also_segments_less_than_xi(loadtim, loadmag, tvals, steps_or_equal_to = True)</span>

<span class="s2">        for i, t in enumerate(tvals):</span>
<span class="s2">            for k in steps_less_than_t[i]:</span>
<span class="s2">                for j, eig in enumerate(eigs):</span>
<span class="s2">                    A[i,j] += (</span><span class="si">{0}</span><span class="s2">)</span>
<span class="s2">            for k in ramps_containing_t[i]:</span>
<span class="s2">                for j, eig in enumerate(eigs):</span>
<span class="s2">                    A[i,j] += (</span><span class="si">{1}</span><span class="s2">)</span>
<span class="s2">            for k in ramps_less_than_t[i]:</span>
<span class="s2">                for j, eig in enumerate(eigs):</span>
<span class="s2">                    A[i,j] += (</span><span class="si">{2}</span><span class="s2">)</span>
<span class="s2">            for k in constants_containing_t[i]:</span>
<span class="s2">                for j, eig in enumerate(eigs):</span>
<span class="s2">                    A[i,j] += (</span><span class="si">{3}</span><span class="s2">)</span>
<span class="s2">            for k in constants_less_than_t[i]:</span>
<span class="s2">                for j, eig in enumerate(eigs):</span>
<span class="s2">                    A[i,j] += (</span><span class="si">{4}</span><span class="s2">)</span>

<span class="s2">    elif implementation == &#39;fortran&#39;:</span>
<span class="s2">        #note than all fortran subroutines are lowercase.</span>
<span class="s2">        if MUST_TRY_FORTRAN:</span>
<span class="s2">            from geotecha.speccon.ext_integrals import edload_coslinear as fn</span>
<span class="s2">        else:</span>
<span class="s2">            try:</span>
<span class="s2">                from geotecha.speccon.ext_integrals import edload_coslinear as fn</span>
<span class="s2">            except ImportError:</span>
<span class="s2">                fn = EDload_coslinear</span>
<span class="s2">        A = fn(loadtim, loadmag, omega, phase, eigs, tvals, dT)</span>

<span class="s2">    else:#default is &#39;vectorized&#39; using numpy</span>
<span class="s2">        sin = np.sin</span>
<span class="s2">        cos = np.cos</span>
<span class="s2">        exp = np.exp</span>

<span class="s2">        A = np.zeros([len(tvals), len(eigs)])</span>

<span class="s2">        (ramps_less_than_t, constants_less_than_t, steps_less_than_t,</span>
<span class="s2">            ramps_containing_t, constants_containing_t) = segment_containing_also_segments_less_than_xi(loadtim, loadmag, tvals, steps_or_equal_to = True)</span>

<span class="s2">        eig = eigs[:, None]</span>


<span class="s2">        for i, t in enumerate(tvals):</span>
<span class="s2">            k = steps_less_than_t[i]</span>
<span class="s2">            if len(k):</span>
<span class="s2">                A[i, :] += np.sum(</span><span class="si">{0}</span><span class="s2">, axis=1)</span>
<span class="s2">            k = ramps_containing_t[i]</span>
<span class="s2">            if len(k):</span>
<span class="s2">                A[i, :] += np.sum(</span><span class="si">{1}</span><span class="s2">, axis=1)</span>
<span class="s2">            k = ramps_less_than_t[i]</span>
<span class="s2">            if len(k):</span>
<span class="s2">                A[i, :] += np.sum(</span><span class="si">{2}</span><span class="s2">, axis=1)</span>
<span class="s2">            k = constants_containing_t[i]</span>
<span class="s2">            if len(k):</span>
<span class="s2">                A[i,:] += np.sum(</span><span class="si">{3}</span><span class="s2">, axis=1)</span>
<span class="s2">            k = constants_less_than_t[i]</span>
<span class="s2">            if len(k):</span>
<span class="s2">                A[i,:] += np.sum(</span><span class="si">{4}</span><span class="s2">, axis=1)</span>
<span class="s2">    return A&quot;&quot;&quot;</span>



    <span class="n">text_fortran</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">      SUBROUTINE edload_coslinear(loadtim, loadmag, omega, phase,&amp;</span>
<span class="s2">                                  eigs, tvals, dT, a, neig, nload, nt)</span>
<span class="s2">        USE types</span>
<span class="s2">        IMPLICIT NONE</span>

<span class="s2">        INTEGER, intent(in) :: neig</span>
<span class="s2">        INTEGER, intent(in) :: nload</span>
<span class="s2">        INTEGER, intent(in) :: nt</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nload-1) :: loadtim</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nload-1) :: loadmag</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:neig-1) :: eigs</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nt-1) :: tvals</span>
<span class="s2">        REAL(DP), intent(in) :: dT</span>
<span class="s2">        REAL(DP), intent(in) :: omega</span>
<span class="s2">        REAL(DP), intent(in) :: phase</span>
<span class="s2">        REAL(DP), intent(out), dimension(0:nt-1, 0:neig-1) :: a</span>
<span class="s2">        INTEGER :: i , j, k</span>
<span class="s2">        REAL(DP):: EPSILON</span>
<span class="s2">        a=0.0D0</span>
<span class="s2">        EPSILON = 0.0000005D0</span>
<span class="s2">        DO i = 0, nt-1</span>
<span class="s2">          DO k = 0, nload-2</span>

<span class="s2">            IF (tvals(i) &lt; loadtim(k)) EXIT !t is before load step</span>

<span class="s2">            IF (tvals(i) &gt;= loadtim(k + 1)) THEN</span>
<span class="s2">              !t is after the load step</span>
<span class="s2">              IF(ABS(loadtim(k) - loadtim(k + 1)) &lt;= &amp;</span>
<span class="s2">                (ABS(loadtim(k) + loadtim(k + 1))*EPSILON)) THEN</span>
<span class="s2">                !step load</span>
<span class="s2">                DO j=0, neig-1</span>
<span class="si">{0}</span><span class="s2"></span>
<span class="s2">                END DO</span>
<span class="s2">              ELSEIF(ABS(loadmag(k) - loadmag(k + 1)) &lt;= &amp;</span>
<span class="s2">                    (ABS(loadmag(k) + loadmag(k + 1))*EPSILON)) THEN</span>
<span class="s2">                !constant load</span>
<span class="s2">                DO j=0, neig-1</span>
<span class="si">{1}</span><span class="s2"></span>
<span class="s2">                END DO</span>
<span class="s2">              ELSE</span>
<span class="s2">                !ramp load</span>
<span class="s2">                DO j=0, neig-1</span>
<span class="si">{2}</span><span class="s2"></span>
<span class="s2">                END DO</span>
<span class="s2">              END IF</span>
<span class="s2">            ELSE</span>
<span class="s2">              !t is in the load step</span>
<span class="s2">              IF(ABS(loadmag(k) - loadmag(k + 1)) &lt;= &amp;</span>
<span class="s2">                    (ABS(loadmag(k) + loadmag(k + 1))*EPSILON)) THEN</span>
<span class="s2">                !constant load</span>
<span class="s2">                DO j=0, neig-1</span>
<span class="si">{3}</span><span class="s2"></span>
<span class="s2">                END DO</span>
<span class="s2">              ELSE</span>
<span class="s2">                !ramp load</span>
<span class="s2">                DO j=0, neig-1</span>
<span class="si">{4}</span><span class="s2"></span>
<span class="s2">                END DO</span>
<span class="s2">              END IF</span>
<span class="s2">            END IF</span>
<span class="s2">          END DO</span>
<span class="s2">        END DO</span>

<span class="s2">      END SUBROUTINE</span>



<span class="s2">    &quot;&quot;&quot;</span>



    <span class="n">fn</span> <span class="o">=</span> <span class="n">text_python</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">tw</span><span class="p">(</span><span class="n">after_instant</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="n">tw</span><span class="p">(</span><span class="n">within_ramp</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="n">tw</span><span class="p">(</span><span class="n">after_ramp</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="n">tw</span><span class="p">(</span><span class="n">within_constant</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="n">tw</span><span class="p">(</span><span class="n">after_constant</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>


    <span class="n">mp3</span> <span class="o">=</span> <span class="p">[(</span><span class="n">eig</span><span class="p">,</span> <span class="n">eigs</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tvals</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>

    <span class="n">after_instant</span> <span class="o">=</span> <span class="n">after_instant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp3</span><span class="p">)</span>
    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">after_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp3</span><span class="p">)</span>
    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">within_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp3</span><span class="p">)</span>
    <span class="n">after_constant</span> <span class="o">=</span> <span class="n">after_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp3</span><span class="p">)</span>
    <span class="n">within_constant</span> <span class="o">=</span> <span class="n">within_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp3</span><span class="p">)</span>

    <span class="n">fn2</span> <span class="o">=</span> <span class="n">text_fortran</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">after_instant</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">),</span>
        <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">after_constant</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">),</span>
        <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">after_ramp</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">),</span>
        <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">within_constant</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">),</span>
        <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">within_ramp</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fn2</span></div>

<div class="viewcode-block" id="Eload_sinlinear_implementations"><a class="viewcode-back" href="../../../api/geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.Eload_sinlinear_implementations">[docs]</a><span class="k">def</span> <span class="nf">Eload_sinlinear_implementations</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Code generation for Integration of sin(omega*tau+phase)*load(tau) * exp(dT * eig * (t-tau))</span>
<span class="sd">    between [0, t], where load(tau) is piecewise linear.</span>

<span class="sd">    Performs integrations involving a piecewise linear load.  A 2d array of</span>
<span class="sd">    dimensions A[len(tvals), len(eigs)]</span>
<span class="sd">    is produced where the &#39;i&#39;th row of A contains the diagonal elements of the</span>
<span class="sd">    spectral &#39;E&#39; matrix calculated for the time value tvals[i]. i.e. rows of</span>
<span class="sd">    this matrix will be assembled into the diagonal matrix &#39;E&#39; elsewhere.</span>


<span class="sd">    Paste the resulting code (at least the loops) into `Eload_sinlinear`.</span>

<span class="sd">    Creates three implementations:</span>

<span class="sd">     - &#39;scalar&#39;, python loops (slowest).</span>
<span class="sd">     - &#39;vectorized&#39;, numpy (much faster than scalar).</span>
<span class="sd">     - &#39;fortran&#39;, fortran loops (fastest).  Needs to be compiled and interfaced</span>
<span class="sd">       with f2py.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fn : string</span>
<span class="sd">        Python code with scalar (loops) and vectorized (numpy) implementations</span>
<span class="sd">        also calls the fortran version.</span>
<span class="sd">    fn2 : string</span>
<span class="sd">        Fortran code.  needs to be compiled with f2py</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    Note this will make complex arrays a complex array!!!</span>


<span class="sd">    Assuming the load are formulated as the product of separate time and depth</span>
<span class="sd">    dependant functions:</span>

<span class="sd">    .. math:: \\sigma\\left({Z,t}\\right)=\\sigma\\left({Z}\\right)\\sigma\\left({t}\\right)</span>

<span class="sd">    the solution to the consolidation equation using the spectral method has</span>
<span class="sd">    the form:</span>

<span class="sd">    .. math:: u\\left(Z,t\\right)=\\mathbf{\\Phi v E}\\left(\\mathbf{\\Gamma v}\\right)^{-1}\\mathbf{\\theta}</span>

<span class="sd">    The matrix :math:`E` is a time dependent diagonal matrix due to time</span>
<span class="sd">    dependant loadings.  The version of :math:`E` calculated here in</span>
<span class="sd">    `Eload_sinlinear` is from loading terms in the governing equation that are NOT</span>
<span class="sd">    differentiated wrt :math:`t`.</span>
<span class="sd">    The diagonal elements of :math:`E` are given by:</span>

<span class="sd">    .. math:: \\mathbf{E}_{i,i}=\\int_{0}^t{{\\sin\\left(\\omega\\tau+\\textrm{phase}\\right)}{\\sigma\\left(\\tau\\right)}{\exp\\left({(dT\\left(t-\\tau\\right)\\lambda_i}\\right)}\\,d\\tau}</span>

<span class="sd">    where</span>

<span class="sd">     :math:`\\lambda_i` is the `ith` eigenvalue of the problem,</span>
<span class="sd">     :math:`dT` is a time factor for numerical convienience,</span>
<span class="sd">     :math:`\\sigma\left(\\tau\\right)` is the time dependant portion of the loading function.</span>

<span class="sd">    When the time dependant loading term :math:`\\sigma\\left(\\tau\\right)` is</span>
<span class="sd">    piecewise in time. The contribution of each load segment is found by:</span>

<span class="sd">    .. math:: \\mathbf{E}_{i,i}=\\int_{t_s}^{t_f}{{\\sin\\left(\\omega\\tau+\\textrm{phase}\\right)}{\\sigma\\left(\\tau\\right)}\\exp\\left({dT\\left(t-\\tau\\right)*\\lambda_i}\\right)\\,d\\tau}</span>

<span class="sd">    where</span>

<span class="sd">    .. math:: t_s = \\min\\left(t,t_{increment\\:start}\\right)</span>

<span class="sd">    .. math:: t_f = \\min\\left(t,t_{increment\\:end}\\right)</span>

<span class="sd">    (note that this function,`Eload_sinlinear`, rather than use :math:`t_s` and</span>
<span class="sd">    :math:`t_f`,</span>
<span class="sd">    explicitly finds increments that the current time falls in, falls after,</span>
<span class="sd">    and falls before and treates each case on it&#39;s own.)</span>

<span class="sd">    Each :math:`t` value of interest requires a separate diagonal matrix</span>
<span class="sd">    :math:`E`.  To use space more efficiently and to facilitate numpy</span>
<span class="sd">    broadcasting when using the results of the function, the diagonal elements</span>
<span class="sd">    of :math:`E` for each time value `t` value are stored in the rows of</span>
<span class="sd">    array :math:`A` returned by `Eload_sinlinear`.  Thus:</span>

<span class="sd">    .. math:: \\mathbf{A}=\\left(\\begin{matrix}E_{0,0}(t_0)&amp;E_{1,1}(t_0)&amp; \cdots &amp; E_{neig-1,neig-1}(t_0)\\\ E_{0,0}(t_1)&amp;E_{1,1}(t_1)&amp; \\cdots &amp; E_{neig-1,neig-1}(t_1)\\\ \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots \\\ E_{0,0}(t_m)&amp;E_{1,1}(t_m)&amp; \cdots &amp; E_{neig-1,neig-1}(t_m)\\end{matrix}\\right)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    geotecha.speccon.integrals.Eload_sinlinear : Resulting function.</span>
<span class="sd">    geotecha.speccon.integrals.pEload_sinlinear : Resulting function with PolyLine</span>
<span class="sd">        inputs.</span>
<span class="sd">    geotecha.speccon.ext_integrals.eload_sinlinear : Resulting fortran function.</span>
<span class="sd">    Eload_linear_implementations : Similar function with no</span>
<span class="sd">        sine term.</span>
<span class="sd">    Eload_coslinear_implementations : Similar function</span>
<span class="sd">        but with cosine term.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">exp</span>

    <span class="n">sympy</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;t, tau, dT, eig, omega, phase&#39;</span><span class="p">)</span>
    <span class="n">loadmag</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;loadmag&#39;</span><span class="p">)</span>
    <span class="n">loadtim</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;loadtim&#39;</span><span class="p">)</span>
    <span class="n">tvals</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;tvals&#39;</span><span class="p">)</span>
    <span class="n">eigs</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;eigs&#39;</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;j&#39;</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>


    <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">sig0</span><span class="p">,</span> <span class="n">sig1</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;t0, t1, sig0, sig1&#39;</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, x0, x1&#39;</span><span class="p">)</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;A, B&#39;</span><span class="p">)</span>
<span class="c1">#    load1 = sympy.sin(omega * tau + phase)</span>
    <span class="n">load1</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">B</span><span class="p">)</span>
    <span class="n">load2</span> <span class="o">=</span> <span class="n">sig0</span> <span class="o">+</span> <span class="p">(</span><span class="n">sig1</span> <span class="o">-</span> <span class="n">sig0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tau</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span>

    <span class="n">load1</span> <span class="o">=</span> <span class="n">load1</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">x</span><span class="o">/</span><span class="p">(</span><span class="n">dT</span><span class="o">*</span><span class="n">eig</span><span class="p">)</span><span class="o">+</span><span class="n">t</span><span class="p">)</span>
    <span class="n">load2</span> <span class="o">=</span> <span class="n">load2</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">x</span><span class="o">/</span><span class="p">(</span><span class="n">dT</span><span class="o">*</span><span class="n">eig</span><span class="p">)</span><span class="o">+</span><span class="n">t</span><span class="p">)</span>

    <span class="n">dx_dtau</span> <span class="o">=</span> <span class="n">dT</span> <span class="o">*</span> <span class="n">eig</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x0</span><span class="p">,</span> <span class="o">-</span><span class="n">dT</span> <span class="o">*</span> <span class="n">eig</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t0</span><span class="p">)),</span>
          <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="o">-</span><span class="n">dT</span> <span class="o">*</span> <span class="n">eig</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t1</span><span class="p">)),</span>
            <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">omega</span> <span class="o">/</span> <span class="p">(</span><span class="n">dT</span><span class="o">*</span><span class="n">eig</span><span class="p">)),</span>
            <span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">omega</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">phase</span><span class="p">)]</span>

    <span class="n">mp2</span> <span class="o">=</span> <span class="p">[(</span><span class="n">sig0</span><span class="p">,</span> <span class="n">loadmag</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">sig1</span><span class="p">,</span> <span class="n">loadmag</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">loadtim</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span>
            <span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">loadtim</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])]</span>
<span class="c1">#    mp = [(exp(-dT*eig*t)*exp(dT*eig*loadtim[k]),</span>
<span class="c1">#           exp(-dT*eig*(t-loadtim[k]))),</span>
<span class="c1">#          (exp(-dT*eig*t)*exp(dT*eig*loadtim[k+1]),</span>
<span class="c1">#           exp(-dT*eig*(t-loadtim[k+1])))]</span>
<span class="c1">#    the default output for the integrals will have expression s like</span>
<span class="c1">#    exp(-dT*eig*t)*exp(dT*eig*loadtim[k]).  when dT*eig*loadtim[k] is large</span>
<span class="c1">#    the exponential may be so large as to cause an error.  YOu may need to</span>
<span class="c1">#    manually alter the expression to exp(is large exp(-dT*eig*(t-loadtim[k]))</span>
<span class="c1">#    in which case the term in the exponential will always be negative and not</span>
<span class="c1">#    lead to any numerical blow up.</span>
<span class="c1">#    load = linear(tau, loadtim[k], loadmag[k], loadtim[k+1], loadmag[k+1])</span>
<span class="c1">#    after_instant = (loadmag[k+1] - loadmag[k]) * exp(-dT * eig * (t - loadtim[k]))</span>
<span class="c1">#    mp does this automatically with subs</span>
<span class="c1">#    load = linear(tau, loadtim[k], loadmag[k], loadtim[k+1], loadmag[k+1])</span>
    <span class="n">within_constant</span> <span class="o">=</span> <span class="n">sig0</span> <span class="o">*</span> <span class="n">load1</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx_dtau</span>
    <span class="n">within_constant</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">within_constant</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span><span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">within_constant</span> <span class="o">=</span> <span class="n">within_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="n">within_constant</span> <span class="o">=</span> <span class="n">within_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>
    <span class="n">after_constant</span> <span class="o">=</span> <span class="n">sig0</span> <span class="o">*</span> <span class="n">load1</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx_dtau</span>
    <span class="n">after_constant</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">after_constant</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">after_constant</span> <span class="o">=</span> <span class="n">after_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="n">after_constant</span> <span class="o">=</span> <span class="n">after_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>

    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">load1</span> <span class="o">*</span> <span class="n">load2</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx_dtau</span>
    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">within_ramp</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">within_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">within_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>

    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">load1</span> <span class="o">*</span> <span class="n">load2</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx_dtau</span>
    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">after_ramp</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">after_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">after_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>


    <span class="n">text_python</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">def Eload_sinlinear(loadtim, loadmag, omega, phase, eigs, tvals, dT=1.0, implementation=&#39;vectorized&#39;):</span>

<span class="s2">    loadtim = np.asarray(loadtim)</span>
<span class="s2">    loadmag = np.asarray(loadmag)</span>
<span class="s2">    eigs = np.asarray(eigs)</span>
<span class="s2">    tvals = np.asarray(tvals)</span>

<span class="s2">    if implementation == &#39;scalar&#39;:</span>
<span class="s2">        sin = np.sin</span>
<span class="s2">        cos = np.cos</span>
<span class="s2">        exp = np.exp</span>
<span class="s2">        #note that math module doesn&#39;t like complex numbers</span>

<span class="s2">        A = np.zeros([len(tvals), len(eigs)], dtype=complex)</span>

<span class="s2">        (ramps_less_than_t, constants_less_than_t, steps_less_than_t,</span>
<span class="s2">            ramps_containing_t, constants_containing_t) = segment_containing_also_segments_less_than_xi(loadtim, loadmag, tvals, steps_or_equal_to = True)</span>

<span class="s2">        for i, t in enumerate(tvals):</span>
<span class="s2">            for k in constants_containing_t[i]:</span>
<span class="s2">                for j, eig in enumerate(eigs):</span>
<span class="s2">                    A[i,j] += (</span><span class="si">{0}</span><span class="s2">)</span>
<span class="s2">            for k in constants_less_than_t[i]:</span>
<span class="s2">                for j, eig in enumerate(eigs):</span>
<span class="s2">                    A[i,j] += (</span><span class="si">{1}</span><span class="s2">)</span>
<span class="s2">            for k in ramps_containing_t[i]:</span>
<span class="s2">                for j, eig in enumerate(eigs):</span>
<span class="s2">                    A[i,j] += (</span><span class="si">{2}</span><span class="s2">)</span>
<span class="s2">            for k in ramps_less_than_t[i]:</span>
<span class="s2">                for j, eig in enumerate(eigs):</span>
<span class="s2">                    A[i,j] += (</span><span class="si">{3}</span><span class="s2">)</span>
<span class="s2">    elif implementation == &#39;fortran&#39;:</span>
<span class="s2">        #note than all fortran subroutines are lowercase.</span>
<span class="s2">        if MUST_TRY_FORTRAN:</span>
<span class="s2">            from geotecha.speccon.ext_integrals import eload_sinlinear as fn</span>
<span class="s2">        else:</span>
<span class="s2">            try:</span>
<span class="s2">                from geotecha.speccon.ext_integrals import eload_sinlinear as fn</span>
<span class="s2">            except ImportError:</span>
<span class="s2">                fn = Eload_sinlinear</span>
<span class="s2">        A = fn(loadtim, loadmag, omega, phase, eigs, tvals, dT)</span>

<span class="s2">    else:#default is &#39;vectorized&#39; using numpy</span>
<span class="s2">        sin = np.sin</span>
<span class="s2">        cos = np.cos</span>
<span class="s2">        exp = np.exp</span>

<span class="s2">        A = np.zeros([len(tvals), len(eigs)], dtype=complex)</span>

<span class="s2">        (ramps_less_than_t, constants_less_than_t, steps_less_than_t,</span>
<span class="s2">            ramps_containing_t, constants_containing_t) = segment_containing_also_segments_less_than_xi(loadtim, loadmag, tvals, steps_or_equal_to = True)</span>

<span class="s2">        eig = eigs[:, None]</span>
<span class="s2">        for i, t in enumerate(tvals):</span>
<span class="s2">            k = constants_containing_t[i]</span>
<span class="s2">            if len(k):</span>
<span class="s2">                A[i, :] += np.sum(</span><span class="si">{0}</span><span class="s2">, axis=1)</span>

<span class="s2">            k = constants_less_than_t[i]</span>
<span class="s2">            if len(k):</span>
<span class="s2">                A[i, :] += np.sum(</span><span class="si">{1}</span><span class="s2">, axis=1)</span>

<span class="s2">            k = ramps_containing_t[i]</span>
<span class="s2">            if len(k):</span>
<span class="s2">                A[i, :] += np.sum(</span><span class="si">{2}</span><span class="s2">, axis=1)</span>

<span class="s2">            k = ramps_less_than_t[i]</span>
<span class="s2">            if len(k):</span>
<span class="s2">                A[i, :] += np.sum(</span><span class="si">{3}</span><span class="s2">, axis=1)</span>
<span class="s2">    return A&quot;&quot;&quot;</span>



    <span class="n">text_fortran</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">      SUBROUTINE eload_sinlinear(loadtim, loadmag, omega, phase, &amp;</span>
<span class="s2">                                 eigs, tvals, dT, a, neig, nload, nt)</span>
<span class="s2">        USE types</span>
<span class="s2">        IMPLICIT NONE</span>

<span class="s2">        INTEGER, intent(in) :: neig</span>
<span class="s2">        INTEGER, intent(in) :: nload</span>
<span class="s2">        INTEGER, intent(in) :: nt</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nload-1) :: loadtim</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nload-1) :: loadmag</span>
<span class="s2">        COMPLEX(DP), intent(in), dimension(0:neig-1) :: eigs</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nt-1) :: tvals</span>
<span class="s2">        REAL(DP), intent(in) :: dT</span>
<span class="s2">        REAL(DP), intent(in) :: omega</span>
<span class="s2">        REAL(DP), intent(in) :: phase</span>
<span class="s2">        COMPLEX(DP), intent(out), dimension(0:nt-1, 0:neig-1) :: a</span>
<span class="s2">        INTEGER :: i , j, k</span>
<span class="s2">        REAL(DP):: EPSILON</span>
<span class="s2">        a=0.0D0</span>
<span class="s2">        EPSILON = 0.0000005D0</span>
<span class="s2">        DO i = 0, nt-1</span>
<span class="s2">          DO k = 0, nload-2</span>

<span class="s2">            IF (tvals(i) &lt; loadtim(k)) EXIT !t is before load step</span>

<span class="s2">            IF (tvals(i) &gt;= loadtim(k + 1)) THEN</span>
<span class="s2">              !t is after the load step</span>
<span class="s2">              IF(ABS(loadtim(k) - loadtim(k + 1)) &lt;= &amp;</span>
<span class="s2">                (ABS(loadtim(k) + loadtim(k + 1))*EPSILON)) THEN</span>
<span class="s2">                !step load</span>
<span class="s2">                CONTINUE</span>
<span class="s2">              ELSEIF(ABS(loadmag(k) - loadmag(k + 1)) &lt;= &amp;</span>
<span class="s2">                    (ABS(loadmag(k) + loadmag(k + 1))*EPSILON)) THEN</span>
<span class="s2">                !constant load</span>
<span class="s2">                DO j=0, neig-1</span>
<span class="si">{0}</span><span class="s2"></span>
<span class="s2">                END DO</span>
<span class="s2">              ELSE</span>
<span class="s2">                !ramp load</span>
<span class="s2">                DO j=0, neig-1</span>
<span class="si">{1}</span><span class="s2"></span>
<span class="s2">                END DO</span>
<span class="s2">              END IF</span>
<span class="s2">            ELSE</span>
<span class="s2">              !t is in the load step</span>
<span class="s2">              IF(ABS(loadmag(k) - loadmag(k + 1)) &lt;= &amp;</span>
<span class="s2">                    (ABS(loadmag(k) + loadmag(k + 1))*EPSILON)) THEN</span>
<span class="s2">                !constant load</span>
<span class="s2">                DO j=0, neig-1</span>
<span class="si">{2}</span><span class="s2"></span>
<span class="s2">                END DO</span>
<span class="s2">              ELSE</span>
<span class="s2">                !ramp load</span>
<span class="s2">                DO j=0, neig-1</span>
<span class="si">{3}</span><span class="s2"></span>
<span class="s2">                END DO</span>
<span class="s2">              END IF</span>
<span class="s2">            END IF</span>
<span class="s2">          END DO</span>
<span class="s2">        END DO</span>

<span class="s2">      END SUBROUTINE</span>



<span class="s2">    &quot;&quot;&quot;</span>



    <span class="n">fn</span> <span class="o">=</span> <span class="n">text_python</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">tw</span><span class="p">(</span><span class="n">within_constant</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="n">tw</span><span class="p">(</span><span class="n">after_constant</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="n">tw</span><span class="p">(</span><span class="n">within_ramp</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="n">tw</span><span class="p">(</span><span class="n">after_ramp</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>


    <span class="n">mp3</span> <span class="o">=</span> <span class="p">[(</span><span class="n">eig</span><span class="p">,</span> <span class="n">eigs</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">tvals</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
    <span class="n">after_constant</span> <span class="o">=</span> <span class="n">after_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp3</span><span class="p">)</span>
    <span class="n">after_ramp</span> <span class="o">=</span> <span class="n">after_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp3</span><span class="p">)</span>
    <span class="n">within_constant</span> <span class="o">=</span> <span class="n">within_constant</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp3</span><span class="p">)</span>
    <span class="n">within_ramp</span> <span class="o">=</span> <span class="n">within_ramp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp3</span><span class="p">)</span>
    <span class="n">fn2</span> <span class="o">=</span> <span class="n">text_fortran</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">after_constant</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">),</span>
        <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">after_ramp</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">),</span>
        <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">within_constant</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">),</span>
        <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">within_ramp</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fn2</span></div>





<div class="viewcode-block" id="SympyVarsFor1DSpectralDerivation"><a class="viewcode-back" href="../../../api/geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.SympyVarsFor1DSpectralDerivation">[docs]</a><span class="k">class</span> <span class="nc">SympyVarsFor1DSpectralDerivation</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Container for sympy vars, z, zt, zb, at, etc piecewise linear</span>
<span class="sd">    Spectral Galerkin integrations.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    linear_var : [&#39;z&#39;, &#39;x&#39;, &#39;y&#39;], optional</span>
<span class="sd">        Independent variable for the linear function specification.</span>
<span class="sd">        f(linear_var) = at+a_slope * (linear_var-linear_vart).</span>
<span class="sd">        Default linear_var=&#39;z&#39;.</span>
<span class="sd">    slope : True/False, optional</span>
<span class="sd">        If True (default), then the linear functions will be defined with a</span>
<span class="sd">        lumped slope term, e.g. a = atop + a_slope * (z - ztop) compared to</span>
<span class="sd">        if slope=False, where a = atop + (abot-atop)/(zbot-ztop)*(z-ztop).</span>
<span class="sd">        You will have to define a_slope in your code template, e.g.</span>
<span class="sd">        Python loops: a_slope = (ab[layer]-at[layer])/(zb[layer]-zt[layer]).</span>
<span class="sd">        Fortran loops: a_slope = (ab(layer)-at(layer)/(zb(layer)-zt(layer)).</span>
<span class="sd">        Vectorised: a_slope = (ab-at)/(zb-zt).</span>


<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y, z : sympy.Symbol</span>
<span class="sd">        Independent variables.</span>
<span class="sd">    xtop, xbot, ytop, ybot, ztop, zbot : sympy.Symbol</span>
<span class="sd">        Symbols used in expressions to be integrated with sympy.integrate.</span>
<span class="sd">        After the integration these variables are usually replaced with</span>
<span class="sd">        the relevant xt, xb, yt etc. or xt[layer], yb[layer] etc.  These</span>
<span class="sd">        substitutions can be made using `map_to_add_index&#39; or</span>
<span class="sd">        `map_top_to_t_bot_to_b`.</span>
<span class="sd">    i, j, k , layer : sympy.tensor.Idx</span>
<span class="sd">        Index variables.</span>
<span class="sd">    xt, xb, yt, yb, zt, zb : sympy.tensor.IndexedBase</span>
<span class="sd">        Variables for values at top and bottom of layer.  Used to define</span>
<span class="sd">        linear relationships.  These variable usually replace xtop, xbot</span>
<span class="sd">        after integrations.  The reason they are not used before integration</span>
<span class="sd">        is thatsympy doesn&#39;t seem to like the sympy.tensor.IndexedBase for</span>
<span class="sd">        integrations. Substitutions can be made using `map_to_add_index&#39; or</span>
<span class="sd">        `map_top_to_t_bot_to_b`.</span>
<span class="sd">    at, ab, a, a_slope: sympy.Symbol and sympy.Expr</span>
<span class="sd">        Variables to define linear relationships.</span>
<span class="sd">        If `slope`=True, a = atop + a_slope * (z - ztop)</span>
<span class="sd">        If `slope`=False, a = atop + (abot - atop)/(zbot - ztop) * (z - ztop).</span>
<span class="sd">        Where z and ztop may change according to `linear_var`.</span>
<span class="sd">    bt, bb, b, b_slope: sympy.Symbol and sympy.Expr</span>
<span class="sd">        Variables to define linear relationships.</span>
<span class="sd">        If `slope`=True, b = atop + b_slope * (z - ztop)</span>
<span class="sd">        If `slope`=False, b = btop + (bbot - btop)/(zbot - ztop) * (z - ztop).</span>
<span class="sd">        Where z and ztop may change according to `linear_var`.</span>
<span class="sd">    ct, cb, c, c_slope: sympy.Symbol and sympy.Expr</span>
<span class="sd">        Variables to define linear relationships.</span>
<span class="sd">        If `slope`=True, c = ctop + c_slope * (z - ztop)</span>
<span class="sd">        If `slope`=False, c = ctop + (cbot - ctop)/(zbot - ztop) * (z - ztop).</span>
<span class="sd">        Where z and ztop may change according to `linear_var`.</span>
<span class="sd">    map_to_add_index : list of 2 element tuples</span>
<span class="sd">        A list to be used with the subs method of sympy expressions to</span>
<span class="sd">        add a index variables to the variables. A typical entries in</span>
<span class="sd">        `map_to_add_index` would be [(mi, m[i]), (mj, m[j]), (atop, at[layer]),</span>
<span class="sd">        (ztop, zt[layer]), ...].  Use this to after an integration invoving</span>
<span class="sd">        ztop, atop etc. to format the expression for use in function with</span>
<span class="sd">        loops.</span>
<span class="sd">    map_top_to_t_bot_to_b : list of 2 element tuples</span>
<span class="sd">        A list to be used with the subs method of sympy expressions to</span>
<span class="sd">        add change &#39;ztop&#39; to &#39;zt&#39;, &#39;abot&#39; to &#39;at&#39; etc. Typical entries in</span>
<span class="sd">        `map_top_to_t_bot_to_b` would be [(atop, at), (ztop, zt), ...].</span>
<span class="sd">        Use this to after an integration invoving ztop, atop etc. to format</span>
<span class="sd">        the expression for use in a vectorised function.</span>
<span class="sd">    mi, mj : sympy.Symbol</span>
<span class="sd">        Variable for row and column eigs.</span>
<span class="sd">    m : sympy.tensor.IndexedBase</span>
<span class="sd">        IndexedBaseVariable of eigs.  used for m[i], and m[j].</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; v = SympyVarsFor1DSpectralDerivation()</span>
<span class="sd">    &gt;&gt;&gt; v.a</span>
<span class="sd">    a_slope*(z - ztop) + atop</span>
<span class="sd">    &gt;&gt;&gt; v.b</span>
<span class="sd">    b_slope*(z - ztop) + btop</span>
<span class="sd">    &gt;&gt;&gt; v.c</span>
<span class="sd">    c_slope*(z - ztop) + ctop</span>
<span class="sd">    &gt;&gt;&gt; v.map_to_add_index</span>
<span class="sd">    [(mi, m[i]), (mj, m[j]), (atop, at[layer]), (abot, ab[layer]), (btop, bt[layer]), (bbot, bb[layer]), (ctop, ct[layer]), (cbot, cb[layer]), (ztop, zt[layer]), (zbot, zb[layer])]</span>
<span class="sd">    &gt;&gt;&gt; v.a.subs(v.map_to_add_index)</span>
<span class="sd">    a_slope*(z - zt[layer]) + at[layer]</span>
<span class="sd">    &gt;&gt;&gt; v.b.subs(v.map_top_to_t_bot_to_b)</span>
<span class="sd">    b_slope*(z - zt) + bt</span>
<span class="sd">    &gt;&gt;&gt; v.mi</span>
<span class="sd">    mi</span>
<span class="sd">    &gt;&gt;&gt; v.mi.subs(v.map_to_add_index)</span>
<span class="sd">    m[i]</span>
<span class="sd">    &gt;&gt;&gt; v.mi.subs(v.map_top_to_t_bot_to_b)</span>
<span class="sd">    mi</span>


<span class="sd">    &gt;&gt;&gt; v = SympyVarsFor1DSpectralDerivation(linear_var=&#39;x&#39;, slope=False)</span>
<span class="sd">    &gt;&gt;&gt; v.a</span>
<span class="sd">    atop + (abot - atop)*(x - xtop)/(xbot - xtop)</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_var</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">slope</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="kn">import</span> <span class="nn">sympy</span>


        <span class="c1">#integration variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,y,z&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xtop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xbot</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;xtop,xbot&#39;</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ytop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ybot</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;ytop,ybot&#39;</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ztop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zbot</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;ztop,zbot&#39;</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">abot</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;atop,abot&#39;</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">btop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bbot</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;btop,bbot&#39;</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cbot</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;ctop,cbot&#39;</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># indexes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;j&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layer</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;layer&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">xt</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;xt&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xb</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;xb&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yt</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;yt&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yb</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;yb&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zt</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;zt&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zb</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;zb&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mj</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;mi,mj&#39;</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">mmap_to_add_index</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">mi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">]),</span>
                             <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">])]</span>


        <span class="c1">#linear f(linear_var)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_var</span> <span class="o">=</span> <span class="n">linear_var</span>
        <span class="n">_x</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_var</span><span class="p">)</span>
        <span class="n">_xtop</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_var</span> <span class="o">+</span> <span class="s1">&#39;top&#39;</span><span class="p">)</span>
        <span class="n">_xbot</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_var</span> <span class="o">+</span> <span class="s1">&#39;bot&#39;</span><span class="p">)</span>
        <span class="n">_xt</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_var</span> <span class="o">+</span> <span class="s1">&#39;t&#39;</span><span class="p">)</span>
        <span class="n">_xb</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_var</span> <span class="o">+</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
        <span class="n">_xmap_to_add_index</span> <span class="o">=</span> <span class="p">[(</span><span class="n">_xtop</span><span class="p">,</span> <span class="n">_xt</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="p">]),</span>
                              <span class="p">(</span><span class="n">_xbot</span><span class="p">,</span> <span class="n">_xb</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="p">])]</span>
        <span class="n">_xmap_top_to_t_bot_to_b</span> <span class="o">=</span> <span class="p">[(</span><span class="n">_xtop</span><span class="p">,</span> <span class="n">_xt</span><span class="p">),</span>
                                   <span class="p">(</span><span class="n">_xbot</span><span class="p">,</span> <span class="n">_xb</span><span class="p">)]</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">at</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;at&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ab</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;ab&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a_slope</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a_slope&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">slope</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atop</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_slope</span> <span class="o">*</span> <span class="p">(</span><span class="n">_x</span> <span class="o">-</span> <span class="n">_xtop</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atop</span> <span class="o">+</span>
                      <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abot</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">atop</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">_xbot</span> <span class="o">-</span> <span class="n">_xtop</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">_x</span> <span class="o">-</span> <span class="n">_xtop</span><span class="p">))</span>

        <span class="n">amap_to_add_index</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">atop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="p">]),</span>
                             <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ab</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="p">])]</span>
        <span class="n">amap_top_to_t_bot_to_b</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">atop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">at</span><span class="p">),</span>
                                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ab</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bt</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;bt&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bb</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;bb&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_slope</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;b_slope&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">slope</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btop</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_slope</span> <span class="o">*</span> <span class="p">(</span><span class="n">_x</span> <span class="o">-</span> <span class="n">_xtop</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btop</span> <span class="o">+</span>
                      <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bbot</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">btop</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">_xbot</span> <span class="o">-</span> <span class="n">_xtop</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">_x</span> <span class="o">-</span> <span class="n">_xtop</span><span class="p">))</span>

        <span class="n">bmap_to_add_index</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">btop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bt</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="p">]),</span>
                             <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bbot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bb</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="p">])]</span>
        <span class="n">bmap_top_to_t_bot_to_b</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">btop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bt</span><span class="p">),</span>
                                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bbot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bb</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ct</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;ct&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cb</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;cb&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_slope</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;c_slope&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">slope</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctop</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_slope</span> <span class="o">*</span> <span class="p">(</span><span class="n">_x</span> <span class="o">-</span> <span class="n">_xtop</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctop</span> <span class="o">+</span>
                      <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cbot</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctop</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">_xbot</span> <span class="o">-</span> <span class="n">_xtop</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">_x</span> <span class="o">-</span> <span class="n">_xtop</span><span class="p">))</span>

        <span class="n">cmap_to_add_index</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ct</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="p">]),</span>
                             <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cbot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cb</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="p">])]</span>
        <span class="n">cmap_top_to_t_bot_to_b</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ct</span><span class="p">),</span>
                                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cbot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cb</span><span class="p">)]</span>

        <span class="c1"># make sure mmap... is the first entry!!!!!!!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_to_add_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">mmap_to_add_index</span> <span class="o">+</span>
                                 <span class="n">amap_to_add_index</span> <span class="o">+</span>
                                 <span class="n">bmap_to_add_index</span> <span class="o">+</span>
                                 <span class="n">cmap_to_add_index</span> <span class="o">+</span>
                                 <span class="n">_xmap_to_add_index</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">map_top_to_t_bot_to_b</span> <span class="o">=</span> <span class="p">(</span><span class="n">amap_top_to_t_bot_to_b</span> <span class="o">+</span>
                                      <span class="n">bmap_top_to_t_bot_to_b</span> <span class="o">+</span>
                                      <span class="n">cmap_top_to_t_bot_to_b</span> <span class="o">+</span>
                                     <span class="n">_xmap_top_to_t_bot_to_b</span><span class="p">)</span></div>


<div class="viewcode-block" id="dim1sin_af_linear_implementations"><a class="viewcode-back" href="../../../api/geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.dim1sin_af_linear_implementations">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_af_linear_implementations</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Code generation for Integration of sin(mi * z) * a(z) * sin(mj * z)</span>
<span class="sd">    between ztop and zbot where a(z) is piecewise linear.</span>

<span class="sd">    Code is generated that will produce a square array with the</span>
<span class="sd">    appropriate integrals at each location.</span>

<span class="sd">    Paste the resulting code (at least the loops) into `dim1sin_af_linear`.</span>

<span class="sd">    Creates three implementations:</span>

<span class="sd">     - &#39;scalar&#39;, python loops (slowest).</span>
<span class="sd">     - &#39;vectorized&#39;, numpy (much faster than scalar).</span>
<span class="sd">     - &#39;fortran&#39;, fortran loops (fastest).  Needs to be compiled and interfaced</span>
<span class="sd">       with f2py.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fn : string</span>
<span class="sd">        Python code with scalar (loops) and vectorized (numpy) implementations</span>
<span class="sd">        also calls the fortran version.</span>
<span class="sd">    fn2 : string</span>
<span class="sd">        Fortran code.  Needs to be compiled with f2py.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The `dim1sin_af_linear` matrix, :math:`A` is given by:</span>

<span class="sd">    .. math:: \\mathbf{A}_{i,j}=\\int_{0}^1{{a\\left(z\\right)}\\phi_i\\phi_j\\,dz}</span>

<span class="sd">    where the basis function :math:`\\phi_i` is given by:</span>

<span class="sd">    .. math:: \\phi_i\\left(z\\right)=\\sin\\left({m_i}z\\right)</span>

<span class="sd">    and :math:`a\\left(z\\right)` is a piecewise linear function</span>
<span class="sd">    with respect to :math:`z`, that within a layer are defined by:</span>

<span class="sd">    .. math:: a\\left(z\\right) = a_t+\\frac{a_b-a_t}{z_b-z_t}\\left(z-z_t\\right)</span>

<span class="sd">    with :math:`t` and :math:`b` subscripts representing &#39;top&#39; and &#39;bottom&#39; of</span>
<span class="sd">    each layer respectively.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    geotecha.speccon.integrals.dim1sin_af_linear : Resulting function.</span>
<span class="sd">    geotecha.speccon.integrals.pdim1sin_af_linear : Resulting function with PolyLine</span>
<span class="sd">        inputs.</span>
<span class="sd">    geotecha.speccon.ext_integrals.dim1sin_af_linear : Resulting fortran function.</span>


<span class="sd">    &quot;&quot;&quot;</span>



    <span class="n">v</span> <span class="o">=</span> <span class="n">SympyVarsFor1DSpectralDerivation</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
    <span class="n">integ_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

    <span class="n">phi_i</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">mi</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
    <span class="n">phi_j</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">mj</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

    <span class="n">fdiag</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">phi_i</span> <span class="o">*</span> <span class="n">phi_i</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="o">**</span><span class="n">integ_kwargs</span><span class="p">)</span>
    <span class="n">fdiag_loops</span> <span class="o">=</span> <span class="n">fdiag</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">fdiag</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">fdiag_loops</span> <span class="o">=</span> <span class="n">fdiag_loops</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span>
    <span class="n">fdiag_vector</span> <span class="o">=</span> <span class="n">fdiag</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">fdiag</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">fdiag_vector</span> <span class="o">=</span> <span class="n">fdiag_vector</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_top_to_t_bot_to_b</span><span class="p">)</span>

    <span class="n">foff</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">phi_j</span> <span class="o">*</span> <span class="n">phi_i</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="o">**</span><span class="n">integ_kwargs</span><span class="p">)</span>
    <span class="n">foff_loops</span> <span class="o">=</span> <span class="n">foff</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">foff</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">foff_loops</span> <span class="o">=</span> <span class="n">foff_loops</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span>
    <span class="n">foff_vector</span> <span class="o">=</span> <span class="n">foff</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">foff</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">foff_vector</span> <span class="o">=</span> <span class="n">foff_vector</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_top_to_t_bot_to_b</span><span class="p">)</span>

    <span class="n">text_python</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;def dim1sin_af_linear(m, at, ab, zt, zb, implementation=&#39;vectorized&#39;):</span>

<span class="s2">    #import numpy as np #import this at module level</span>
<span class="s2">    #import math #import this at module level</span>

<span class="s2">    m = np.asarray(m)</span>
<span class="s2">    at = np.asarray(at)</span>
<span class="s2">    ab = np.asarray(ab)</span>
<span class="s2">    zt = np.asarray(zt)</span>
<span class="s2">    zb = np.asarray(zb)</span>

<span class="s2">    neig = len(m)</span>

<span class="s2">    if implementation == &#39;scalar&#39;:</span>
<span class="s2">        sin = math.sin</span>
<span class="s2">        cos = math.cos</span>
<span class="s2">        A = np.zeros([neig, neig], float)</span>
<span class="s2">        nlayers = len(zt)</span>
<span class="s2">        for layer in range(nlayers):</span>
<span class="s2">            a_slope = (ab[layer] - at[layer]) / (zb[layer] - zt[layer])</span>
<span class="s2">            for i in range(neig):</span>
<span class="s2">                A[i, i] += (</span><span class="si">{0}</span><span class="s2">)</span>
<span class="s2">            for i in range(neig-1):</span>
<span class="s2">                for j in range(i + 1, neig):</span>
<span class="s2">                    A[i, j] += (</span><span class="si">{1}</span><span class="s2">)</span>

<span class="s2">        #A is symmetric</span>
<span class="s2">        for i in range(neig - 1):</span>
<span class="s2">            for j in range(i + 1, neig):</span>
<span class="s2">                A[j, i] = A[i, j]</span>

<span class="s2">    elif implementation == &#39;fortran&#39;:</span>
<span class="s2">        if MUST_TRY_FORTRAN:</span>
<span class="s2">            import geotecha.speccon.ext_integrals as ext_integ</span>
<span class="s2">            A = ext_integ.dim1sin_af_linear(m, at, ab, zt, zb)</span>
<span class="s2">        try:</span>
<span class="s2">            import geotecha.speccon.ext_integrals as ext_integ</span>
<span class="s2">            A = ext_integ.dim1sin_af_linear(m, at, ab, zt, zb)</span>
<span class="s2">        except ImportError:</span>
<span class="s2">            A = dim1sin_af_linear(m, at, ab, zt, zb, implementation=&#39;vectorized&#39;)</span>

<span class="s2">    else:#default is &#39;vectorized&#39; using numpy</span>
<span class="s2">        sin = np.sin</span>
<span class="s2">        cos = np.cos</span>
<span class="s2">        A = np.zeros([neig, neig], float)</span>

<span class="s2">        diag =  np.diag_indices(neig)</span>
<span class="s2">        triu = np.triu_indices(neig, k = 1)</span>
<span class="s2">        tril = (triu[1], triu[0])</span>

<span class="s2">        a_slope = (ab - at) / (zb - zt)</span>

<span class="s2">        mi = m[:, np.newaxis]</span>
<span class="s2">        A[diag] = np.sum(</span><span class="si">{2}</span><span class="s2">, axis=1)</span>

<span class="s2">        mi = m[triu[0]][:, np.newaxis]</span>
<span class="s2">        mj = m[triu[1]][:, np.newaxis]</span>
<span class="s2">        A[triu] = np.sum(</span><span class="si">{3}</span><span class="s2">, axis=1)</span>
<span class="s2">        #A is symmetric</span>
<span class="s2">        A[tril] = A[triu]</span>

<span class="s2">    return A&quot;&quot;&quot;</span>


<span class="c1">#    note the the i=j part in the fortran loop  below is because</span>
<span class="c1">#      I changed the loop order from layer, i,j to layer, j,i which is</span>
<span class="c1">#      i think faster as first index of a fortran array loops faster</span>
<span class="c1">#      my sympy code is mased on m[i], hence the need for i=j.</span>
    <span class="n">text_fortran</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;      SUBROUTINE dim1sin_af_linear(m, at, ab, zt, zb, a, neig, nlayers)</span>
<span class="s2">        USE types</span>
<span class="s2">        IMPLICIT NONE</span>

<span class="s2">        INTEGER, intent(in) :: neig</span>
<span class="s2">        INTEGER, intent(in) :: nlayers</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:neig-1) ::m</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nlayers-1) :: at</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nlayers-1) :: ab</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nlayers-1) :: zt</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nlayers-1) :: zb</span>
<span class="s2">        REAL(DP), intent(out), dimension(0:neig-1, 0:neig-1) :: a</span>
<span class="s2">        INTEGER :: i , j, layer</span>
<span class="s2">        REAL(DP) :: a_slope</span>

<span class="s2">        a=0.0D0</span>
<span class="s2">        DO layer = 0, nlayers-1</span>
<span class="s2">          a_slope = (ab(layer) - at(layer)) / (zb(layer) - zt(layer))</span>
<span class="s2">          DO j = 0, neig-1</span>
<span class="s2">              i=j</span>
<span class="si">{0}</span><span class="s2"></span>
<span class="s2">            DO i = j+1, neig-1</span>
<span class="si">{1}</span><span class="s2"></span>
<span class="s2">            END DO</span>
<span class="s2">          END DO</span>
<span class="s2">        END DO</span>

<span class="s2">        DO j = 0, neig -2</span>
<span class="s2">          DO i = j + 1, neig-1</span>
<span class="s2">            a(j,i) = a(i, j)</span>
<span class="s2">          END DO</span>
<span class="s2">        END DO</span>

<span class="s2">      END SUBROUTINE&quot;&quot;&quot;</span>





    <span class="n">fn</span> <span class="o">=</span> <span class="n">text_python</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tw</span><span class="p">(</span><span class="n">fdiag_loops</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">foff_loops</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">fdiag_vector</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">foff_vector</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">fn2</span> <span class="o">=</span> <span class="n">text_fortran</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">fdiag_loops</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, i) = a(i, i) + &#39;</span><span class="p">),</span>
                 <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">foff_loops</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fn2</span></div>


<div class="viewcode-block" id="dim1sin_abf_linear_implementations"><a class="viewcode-back" href="../../../api/geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.dim1sin_abf_linear_implementations">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_abf_linear_implementations</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Code generation for Integration of sin(mi * z) * a(z) * a(z) * sin(mj * z)</span>
<span class="sd">    between ztop and zbot where a(z) is piecewise linear.</span>

<span class="sd">    Code is generated that will produce a square array with the</span>
<span class="sd">    appropriate integrals at each location.</span>

<span class="sd">    Paste the resulting code (at least the loops) into `dim1sin_abf_linear`.</span>

<span class="sd">    Creates three implementations:</span>

<span class="sd">     - &#39;scalar&#39;, python loops (slowest).</span>
<span class="sd">     - &#39;vectorized&#39;, numpy (much faster than scalar).</span>
<span class="sd">     - &#39;fortran&#39;, fortran loops (fastest).  Needs to be compiled and interfaced</span>
<span class="sd">       with f2py.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fn : string</span>
<span class="sd">        Python code with scalar (loops) and vectorized (numpy) implementations</span>
<span class="sd">        also calls the fortran version.</span>
<span class="sd">    fn2 : string</span>
<span class="sd">        Fortran code.  Needs to be compiled with f2py.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The `dim1sin_abf_linear` matrix, :math:`A` is given by:</span>

<span class="sd">    .. math:: \\mathbf{A}_{i,j}=\\int_{0}^1{{a\\left(z\\right)}{b\\left(z\\right)}\\phi_i\\phi_j\\,dz}</span>

<span class="sd">    where the basis function :math:`\\phi_i` is given by:</span>

<span class="sd">    .. math:: \\phi_i\\left(z\\right)=\\sin\\left({m_i}z\\right)</span>

<span class="sd">    and :math:`a\\left(z\\right)` and :math:`b\\left(z\\right)` are piecewise</span>
<span class="sd">    linear functions with respect to :math:`z`, that within a layer are defined by:</span>

<span class="sd">    .. math:: a\\left(z\\right) = a_t+\\frac{a_b-a_t}{z_b-z_t}\\left(z-z_t\\right)</span>

<span class="sd">    with :math:`t` and :math:`b` subscripts representing &#39;top&#39; and &#39;bottom&#39; of</span>
<span class="sd">    each layer respectively.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    geotecha.speccon.integrals.dim1sin_abf_linear : Resulting function.</span>
<span class="sd">    geotecha.speccon.integrals.pdim1sin_abf_linear : Resulting function with PolyLine</span>
<span class="sd">        inputs.</span>
<span class="sd">    geotecha.speccon.ext_integrals.dim1sin_abf_linear : Resulting fortran function.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">SympyVarsFor1DSpectralDerivation</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
    <span class="n">integ_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

    <span class="n">phi_i</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">mi</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
    <span class="n">phi_j</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">mj</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

<span class="c1">#    fdiag = sympy.integrate(p[&#39;a&#39;] * p[&#39;b&#39;] * phi_i * phi_i, z)</span>
    <span class="n">fdiag</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">b</span> <span class="o">*</span> <span class="n">phi_i</span> <span class="o">*</span> <span class="n">phi_i</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="o">**</span><span class="n">integ_kwargs</span><span class="p">)</span>
    <span class="n">fdiag_loops</span> <span class="o">=</span> <span class="n">fdiag</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">fdiag</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">fdiag_loops</span> <span class="o">=</span> <span class="n">fdiag_loops</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span>
    <span class="n">fdiag_vector</span> <span class="o">=</span> <span class="n">fdiag</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">fdiag</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">fdiag_vector</span> <span class="o">=</span> <span class="n">fdiag_vector</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_top_to_t_bot_to_b</span><span class="p">)</span>

<span class="c1">#    foff = sympy.integrate(p[&#39;a&#39;] * p[&#39;b&#39;] * phi_j * phi_i, z)</span>
    <span class="n">foff</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">b</span> <span class="o">*</span> <span class="n">phi_j</span> <span class="o">*</span> <span class="n">phi_i</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="o">**</span><span class="n">integ_kwargs</span><span class="p">)</span>
    <span class="n">foff_loops</span> <span class="o">=</span> <span class="n">foff</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">foff</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">foff_loops</span> <span class="o">=</span> <span class="n">foff_loops</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span>
    <span class="n">foff_vector</span> <span class="o">=</span> <span class="n">foff</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">foff</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">foff_vector</span> <span class="o">=</span> <span class="n">foff_vector</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_top_to_t_bot_to_b</span><span class="p">)</span>

    <span class="n">text_python</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;def dim1sin_abf_linear(m, at, ab, bt, bb,  zt, zb, implementation=&#39;vectorized&#39;):</span>

<span class="s2">    #import numpy as np #import this at module level</span>
<span class="s2">    #import math #import this at module level</span>

<span class="s2">    m = np.asarray(m)</span>
<span class="s2">    at = np.asarray(at)</span>
<span class="s2">    ab = np.asarray(ab)</span>
<span class="s2">    bt = np.asarray(bt)</span>
<span class="s2">    bb = np.asarray(bb)</span>
<span class="s2">    zt = np.asarray(zt)</span>
<span class="s2">    zb = np.asarray(zb)</span>

<span class="s2">    neig = len(m)</span>

<span class="s2">    if implementation == &#39;scalar&#39;:</span>
<span class="s2">        sin = math.sin</span>
<span class="s2">        cos = math.cos</span>
<span class="s2">        A = np.zeros([neig, neig], float)</span>
<span class="s2">        nlayers = len(zt)</span>
<span class="s2">        for layer in range(nlayers):</span>
<span class="s2">            a_slope = (ab[layer] - at[layer]) / (zb[layer] - zt[layer])</span>
<span class="s2">            b_slope = (bb[layer] - bt[layer]) / (zb[layer] - zt[layer])</span>
<span class="s2">            for i in range(neig):</span>
<span class="s2">                A[i, i] += (</span><span class="si">{0}</span><span class="s2">)</span>
<span class="s2">            for i in range(neig-1):</span>
<span class="s2">                for j in range(i + 1, neig):</span>
<span class="s2">                    A[i, j] += (</span><span class="si">{1}</span><span class="s2">)</span>

<span class="s2">        #A is symmetric</span>
<span class="s2">        for i in range(neig - 1):</span>
<span class="s2">            for j in range(i + 1, neig):</span>
<span class="s2">                A[j, i] = A[i, j]</span>

<span class="s2">    elif implementation == &#39;fortran&#39;:</span>
<span class="s2">        if MUST_TRY_FORTRAN:</span>
<span class="s2">            import geotecha.speccon.ext_integrals as ext_integ</span>
<span class="s2">            A = ext_integ.dim1sin_abf_linear(m, at, ab, bt, bb, zt, zb)</span>
<span class="s2">        else:</span>
<span class="s2">            try:</span>
<span class="s2">                import geotecha.speccon.ext_integrals as ext_integ</span>
<span class="s2">                A = ext_integ.dim1sin_abf_linear(m, at, ab, bt, bb, zt, zb)</span>
<span class="s2">            except ImportError:</span>
<span class="s2">                A = dim1sin_abf_linear(m, at, ab, bt, bb, zt, zb, implementation=&#39;vectorized&#39;)</span>

<span class="s2">    else:#default is &#39;vectorized&#39; using numpy</span>
<span class="s2">        sin = np.sin</span>
<span class="s2">        cos = np.cos</span>
<span class="s2">        A = np.zeros([neig, neig], float)</span>

<span class="s2">        diag =  np.diag_indices(neig)</span>
<span class="s2">        triu = np.triu_indices(neig, k = 1)</span>
<span class="s2">        tril = (triu[1], triu[0])</span>

<span class="s2">        a_slope = (ab - at) / (zb - zt)</span>
<span class="s2">        b_slope = (bb - bt) / (zb - zt)</span>

<span class="s2">        mi = m[:, np.newaxis]</span>
<span class="s2">        A[diag] = np.sum(</span><span class="si">{2}</span><span class="s2">, axis=1)</span>

<span class="s2">        mi = m[triu[0]][:, np.newaxis]</span>
<span class="s2">        mj = m[triu[1]][:, np.newaxis]</span>
<span class="s2">        A[triu] = np.sum(</span><span class="si">{3}</span><span class="s2">, axis=1)</span>
<span class="s2">        #A is symmetric</span>
<span class="s2">        A[tril] = A[triu]</span>

<span class="s2">    return A&quot;&quot;&quot;</span>


<span class="c1">#    note the the i=j part in the fortran loop  below is because</span>
<span class="c1">#      I changed the loop order from layer, i,j to layer, j,i which is</span>
<span class="c1">#      i think faster as first index of a fortran array loops faster</span>
<span class="c1">#      my sympy code is mased on m[i], hence the need for i=j.</span>
    <span class="n">text_fortran</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">      SUBROUTINE dim1sin_abf_linear(m, at, ab, bt, bb, zt, zb, a, &amp;</span>
<span class="s2">                                    neig, nlayers)</span>
<span class="s2">        USE types</span>
<span class="s2">        IMPLICIT NONE</span>

<span class="s2">        INTEGER, intent(in) :: neig</span>
<span class="s2">        INTEGER, intent(in) :: nlayers</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:neig-1) ::m</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nlayers-1) :: at,ab,bt,bb,zt,zb</span>
<span class="s2">!        REAL(DP), intent(in), dimension(0:nlayers-1) :: at</span>
<span class="s2">!        REAL(DP), intent(in), dimension(0:nlayers-1) :: ab</span>
<span class="s2">!        REAL(DP), intent(in), dimension(0:nlayers-1) :: bt</span>
<span class="s2">!        REAL(DP), intent(in), dimension(0:nlayers-1) :: bb</span>
<span class="s2">!        REAL(DP), intent(in), dimension(0:nlayers-1) :: zt</span>
<span class="s2">!        REAL(DP), intent(in), dimension(0:nlayers-1) :: zb</span>
<span class="s2">        REAL(DP), intent(out), dimension(0:neig-1, 0:neig-1) :: a</span>
<span class="s2">        INTEGER :: i , j, layer</span>
<span class="s2">        REAL(DP) :: a_slope, b_slope</span>


<span class="s2">        a=0.0D0</span>
<span class="s2">        DO layer = 0, nlayers-1</span>
<span class="s2">          a_slope = (ab(layer) - at(layer)) / (zb(layer) - zt(layer))</span>
<span class="s2">          b_slope = (bb(layer) - bt(layer)) / (zb(layer) - zt(layer))</span>
<span class="s2">          DO j = 0, neig-1</span>
<span class="s2">              i=j</span>
<span class="si">{0}</span><span class="s2"></span>
<span class="s2">            DO i = j+1, neig-1</span>
<span class="si">{1}</span><span class="s2"></span>
<span class="s2">            END DO</span>
<span class="s2">          END DO</span>
<span class="s2">        END DO</span>

<span class="s2">        DO j = 0, neig -2</span>
<span class="s2">          DO i = j + 1, neig-1</span>
<span class="s2">            a(j,i) = a(i, j)</span>
<span class="s2">          END DO</span>
<span class="s2">        END DO</span>

<span class="s2">      END SUBROUTINE&quot;&quot;&quot;</span>





    <span class="n">fn</span> <span class="o">=</span> <span class="n">text_python</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tw</span><span class="p">(</span><span class="n">fdiag_loops</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">foff_loops</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">fdiag_vector</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">foff_vector</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">fn2</span> <span class="o">=</span> <span class="n">text_fortran</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">fdiag_loops</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, i) = a(i, i) + &#39;</span><span class="p">),</span>
                 <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">foff_loops</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fn2</span></div>


<div class="viewcode-block" id="dim1sin_D_aDf_linear_implementations"><a class="viewcode-back" href="../../../api/geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.dim1sin_D_aDf_linear_implementations">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_D_aDf_linear_implementations</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Code generation for Integration of sin(mi * z) * D[a(z) * D[sin(mj * z),z],z]</span>
<span class="sd">    between ztop and zbot where a(z) is piecewise linear functions of z.</span>


<span class="sd">    Code is generated that will produce a square array with the</span>
<span class="sd">    appropriate integrals at each location.</span>

<span class="sd">    Paste the resulting code (at least the loops) into `dim1sin_abf_linear`.</span>

<span class="sd">    Creates three implementations:</span>

<span class="sd">     - &#39;scalar&#39;, python loops (slowest).</span>
<span class="sd">     - &#39;vectorized&#39;, numpy (much faster than scalar).</span>
<span class="sd">     - &#39;fortran&#39;, fortran loops (fastest).  Needs to be compiled and interfaced</span>
<span class="sd">       with f2py.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fn : string</span>
<span class="sd">        Python code with scalar (loops) and vectorized (numpy) implementations</span>
<span class="sd">        also calls the fortran version.</span>
<span class="sd">    fn2 : string</span>
<span class="sd">        Fortran code.  Needs to be compiled with f2py.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    geotecha.speccon.integrals.dim1sin_D_aDf_linear : Resulting function.</span>
<span class="sd">    geotecha.speccon.integrals.pdim1sin_D_aDf_linear : Resulting function with PolyLine</span>
<span class="sd">        inputs.</span>
<span class="sd">    geotecha.speccon.ext_integrals.dim1sin_d_adf_linear : Resulting fortran function.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The `dim1sin_D_aDf_linear` matrix, :math:`A` is given by:</span>

<span class="sd">    .. math:: \\mathbf{A}_{i,j}=\\int_{0}^1{\\frac{d}{dz}\\left({a\\left(z\\right)}\\frac{d\\phi_j}{dz}\\right)\\phi_i\\,dz}</span>

<span class="sd">    where the basis function :math:`\\phi_i` is given by:</span>

<span class="sd">    .. math:: \\phi_i\\left(z\\right)=\\sin\\left({m_i}z\\right)</span>

<span class="sd">    and :math:`a\\left(z\\right)` is a piecewise</span>
<span class="sd">    linear functions with respect to :math:`z`, that within a layer is defined by:</span>

<span class="sd">    .. math:: a\\left(z\\right) = a_t+\\frac{a_b-a_t}{z_b-z_t}\\left(z-z_t\\right)</span>

<span class="sd">    with :math:`t` and :math:`b` subscripts representing &#39;top&#39; and &#39;bottom&#39; of</span>
<span class="sd">    each layer respectively.</span>

<span class="sd">    To make the above integration simpler we integate by parts to get:</span>

<span class="sd">    .. math:: \\mathbf{A}_{i,j}= \\left.\\phi_i{a\\left(z\\right)}\\frac{d\\phi_j}{dz}\\right|_{z=0}^{z=1} -\\int_{0}^1{{a\\left(z\\right)}\\frac{d\\phi_j}{dz}\\frac{d\\phi_i}{dz}\\,dz}</span>

<span class="sd">    In this case the sine basis functions means the left term in the above</span>
<span class="sd">    equation is zero, leaving us with</span>

<span class="sd">    .. math:: \\mathbf{A}_{i,j}= -\\int_{0}^1{{a\\left(z\\right)}\\frac{d\\phi_j}{dz}\\frac{d\\phi_i}{dz}\\,dz}</span>


<span class="sd">    &quot;&quot;&quot;</span>

<span class="c1">#    NOTE: remember that fortran does not distinguish between upper and lower</span>
<span class="c1">#        case.  When f2py wraps a fortran function with upper case letters then</span>
<span class="c1">#        upper case letters will be converted to lower case. e.g. Therefore when</span>
<span class="c1">#        calling a fortran function called if fortran fn is</span>
<span class="c1">#        &#39;dim1sin_D_aDf_linear&#39; f2py will wrap it as &#39;dim1sin_d_adf_linear&#39;</span>



    <span class="n">v</span> <span class="o">=</span> <span class="n">SympyVarsFor1DSpectralDerivation</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
    <span class="n">integ_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

    <span class="n">phi_i</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">mi</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
    <span class="n">phi_j</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">mj</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

    <span class="n">fdiag</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="o">-</span><span class="n">sympy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">phi_i</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">*</span>
                            <span class="n">v</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span>
                            <span class="n">sympy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">phi_i</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">),</span>
                            <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="o">**</span><span class="n">integ_kwargs</span><span class="p">)</span>
    <span class="n">fdiag_loops</span> <span class="o">=</span> <span class="n">fdiag</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">fdiag</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">fdiag_loops</span> <span class="o">=</span> <span class="n">fdiag_loops</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span>
    <span class="n">fdiag_vector</span> <span class="o">=</span> <span class="n">fdiag</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">fdiag</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">fdiag_vector</span> <span class="o">=</span> <span class="n">fdiag_vector</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_top_to_t_bot_to_b</span><span class="p">)</span>

    <span class="n">foff</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="o">-</span><span class="n">sympy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">phi_i</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">*</span>
                           <span class="n">v</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span>
                           <span class="n">sympy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">phi_j</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">),</span>
                           <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="o">**</span><span class="n">integ_kwargs</span><span class="p">)</span>
    <span class="n">foff_loops</span> <span class="o">=</span> <span class="n">foff</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">foff</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">foff_loops</span> <span class="o">=</span> <span class="n">foff_loops</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span>
    <span class="n">foff_vector</span> <span class="o">=</span> <span class="n">foff</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">foff</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">foff_vector</span> <span class="o">=</span> <span class="n">foff_vector</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_top_to_t_bot_to_b</span><span class="p">)</span>




    <span class="n">text_python</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;def dim1sin_D_aDf_linear(m, at, ab, zt, zb, implementation=&#39;vectorized&#39;):</span>

<span class="s2">    #import numpy as np #import this at module level</span>
<span class="s2">    #import math #import this at module level</span>

<span class="s2">    m = np.asarray(m)</span>
<span class="s2">    at = np.asarray(at)</span>
<span class="s2">    ab = np.asarray(ab)</span>
<span class="s2">    zt = np.asarray(zt)</span>
<span class="s2">    zb = np.asarray(zb)</span>

<span class="s2">    neig = len(m)</span>

<span class="s2">    if implementation == &#39;scalar&#39;:</span>
<span class="s2">        sin = math.sin</span>
<span class="s2">        cos = math.cos</span>
<span class="s2">        A = np.zeros([neig, neig], float)</span>
<span class="s2">        nlayers = len(zt)</span>
<span class="s2">        for layer in range(nlayers):</span>
<span class="s2">            a_slope = (ab[layer] - at[layer]) / (zb[layer] - zt[layer])</span>
<span class="s2">            for i in range(neig):</span>
<span class="s2">                A[i, i] += (</span><span class="si">{0}</span><span class="s2">)</span>
<span class="s2">            for i in range(neig-1):</span>
<span class="s2">                for j in range(i + 1, neig):</span>
<span class="s2">                    A[i, j] += (</span><span class="si">{1}</span><span class="s2">)</span>

<span class="s2">        #A is symmetric</span>
<span class="s2">        for i in range(neig - 1):</span>
<span class="s2">            for j in range(i + 1, neig):</span>
<span class="s2">                A[j, i] = A[i, j]</span>

<span class="s2">    elif implementation == &#39;fortran&#39;:</span>
<span class="s2">        if MUST_TRY_FORTRAN:</span>
<span class="s2">            import geotecha.speccon.ext_integrals as ext_integ</span>
<span class="s2">            A = ext_integ.dim1sin_d_adf_linear(m, at, ab, zt, zb)</span>
<span class="s2">        else:</span>
<span class="s2">            try:</span>
<span class="s2">                import geotecha.speccon.ext_integrals as ext_integ</span>
<span class="s2">                A = ext_integ.dim1sin_d_adf_linear(m, at, ab, zt, zb)</span>
<span class="s2">            except ImportError:</span>
<span class="s2">                A = dim1sin_D_aDf_linear(m, at, ab, zt, zb, implementation=&#39;vectorized&#39;)</span>

<span class="s2">    else:#default is &#39;vectorized&#39; using numpy</span>
<span class="s2">        sin = np.sin</span>
<span class="s2">        cos = np.cos</span>
<span class="s2">        A = np.zeros([neig, neig], float)</span>

<span class="s2">        diag =  np.diag_indices(neig)</span>
<span class="s2">        triu = np.triu_indices(neig, k = 1)</span>
<span class="s2">        tril = (triu[1], triu[0])</span>

<span class="s2">        a_slope = (ab - at) / (zb - zt)</span>

<span class="s2">        mi = m[:, np.newaxis]</span>
<span class="s2">        A[diag] = np.sum(</span><span class="si">{2}</span><span class="s2">, axis=1)</span>

<span class="s2">        mi = m[triu[0]][:, np.newaxis]</span>
<span class="s2">        mj = m[triu[1]][:, np.newaxis]</span>
<span class="s2">        A[triu] = np.sum(</span><span class="si">{3}</span><span class="s2">, axis=1)</span>
<span class="s2">        #A is symmetric</span>
<span class="s2">        A[tril] = A[triu]</span>

<span class="s2">    return A&quot;&quot;&quot;</span>


<span class="c1">#    note the the i=j part in the fortran loop  below is because</span>
<span class="c1">#      I changed the loop order from layer, i,j to layer, j,i which is</span>
<span class="c1">#      i think faster as first index of a fortran array loops faster</span>
<span class="c1">#      my sympy code is mased on m[i], hence the need for i=j.</span>
    <span class="n">text_fortran</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;      SUBROUTINE dim1sin_D_aDf_linear(m, at, ab, zt, zb, a, neig, nlayers)</span>
<span class="s2">        USE types</span>
<span class="s2">        IMPLICIT NONE</span>

<span class="s2">        INTEGER, intent(in) :: neig</span>
<span class="s2">        INTEGER, intent(in) :: nlayers</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:neig-1) ::m</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nlayers-1) :: at</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nlayers-1) :: ab</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nlayers-1) :: zt</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nlayers-1) :: zb</span>
<span class="s2">        REAL(DP), intent(out), dimension(0:neig-1, 0:neig-1) :: a</span>
<span class="s2">        INTEGER :: i , j, layer</span>
<span class="s2">        REAL(DP) :: a_slope</span>

<span class="s2">        a=0.0D0</span>
<span class="s2">        DO layer = 0, nlayers-1</span>
<span class="s2">          a_slope = (ab(layer) - at(layer)) / (zb(layer) - zt(layer))</span>
<span class="s2">          DO j = 0, neig-1</span>
<span class="s2">              i=j</span>
<span class="si">{0}</span><span class="s2"></span>
<span class="s2">            DO i = j+1, neig-1</span>
<span class="si">{1}</span><span class="s2"></span>
<span class="s2">            END DO</span>
<span class="s2">          END DO</span>
<span class="s2">        END DO</span>

<span class="s2">        DO j = 0, neig -2</span>
<span class="s2">          DO i = j + 1, neig-1</span>
<span class="s2">            a(j,i) = a(i, j)</span>
<span class="s2">          END DO</span>
<span class="s2">        END DO</span>

<span class="s2">      END SUBROUTINE&quot;&quot;&quot;</span>





    <span class="n">fn</span> <span class="o">=</span> <span class="n">text_python</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tw</span><span class="p">(</span><span class="n">fdiag_loops</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">foff_loops</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">fdiag_vector</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">foff_vector</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">fn2</span> <span class="o">=</span> <span class="n">text_fortran</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">fdiag_loops</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, i) = a(i, i) + &#39;</span><span class="p">),</span>
                 <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">foff_loops</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fn2</span></div>


<div class="viewcode-block" id="dim1sin_ab_linear_implementations"><a class="viewcode-back" href="../../../api/geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.dim1sin_ab_linear_implementations">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_ab_linear_implementations</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Code generation for Integration of sin(mi * z) * a(z) * b(z)</span>
<span class="sd">    between ztop and zbot where a(z) and b(z) are piecewise linear functions of z.</span>


<span class="sd">    Code is generated that will produce a square array with the</span>
<span class="sd">    appropriate integrals at each location.</span>

<span class="sd">    Paste the resulting code (at least the loops) into `dim1sin_ab_linear`.</span>

<span class="sd">    Creates three implementations:</span>

<span class="sd">     - &#39;scalar&#39;, python loops (slowest).</span>
<span class="sd">     - &#39;vectorized&#39;, numpy (much faster than scalar).</span>
<span class="sd">     - &#39;fortran&#39;, fortran loops (fastest).  Needs to be compiled and interfaced</span>
<span class="sd">       with f2py.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fn : string</span>
<span class="sd">        Python code with scalar (loops) and vectorized (numpy) implementations</span>
<span class="sd">        also calls the fortran version.</span>
<span class="sd">    fn2 : string</span>
<span class="sd">        Fortran code.  Needs to be compiled with f2py.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    geotecha.speccon.integrals.dim1sin_ab_linear : Resulting function.</span>
<span class="sd">    geotecha.speccon.integrals.pdim1sin_ab_linear : Resulting function with PolyLine</span>
<span class="sd">        inputs.</span>
<span class="sd">    geotecha.speccon.ext_integrals.dim1sin_ab_linear : Resulting fortran function.</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The `dim1sin_ab_linear` which should be treated as a column vector,</span>
<span class="sd">    :math:`A` is given by:</span>

<span class="sd">    .. math:: \\mathbf{A}_{i}=\\int_{0}^1{{a\\left(z\\right)}{b\\left(z\\right)}\\phi_i\\,dz}</span>

<span class="sd">    where the basis function :math:`\\phi_i` is given by:</span>

<span class="sd">    .. math:: \\phi_i\\left(z\\right)=\\sin\\left({m_i}z\\right)</span>

<span class="sd">    and :math:`a\\left(z\\right)` and :math:`b\\left(z\\right)` are piecewise</span>
<span class="sd">    linear functions with respect to :math:`z`, that within a layer are defined by:</span>

<span class="sd">    .. math:: a\\left(z\\right) = a_t+\\frac{a_b-a_t}{z_b-z_t}\\left(z-z_t\\right)</span>

<span class="sd">    with :math:`t` and :math:`b` subscripts representing &#39;top&#39; and &#39;bottom&#39; of</span>
<span class="sd">    each layer respectively.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">SympyVarsFor1DSpectralDerivation</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
    <span class="n">integ_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

    <span class="n">phi_i</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">mi</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
<span class="c1">#    phi_j = sympy.sin(v.mj * v.z)</span>

    <span class="n">fcol</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">b</span> <span class="o">*</span> <span class="n">phi_i</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="o">**</span><span class="n">integ_kwargs</span><span class="p">)</span>
    <span class="n">fcol_loops</span> <span class="o">=</span> <span class="n">fcol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">fcol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">fcol_loops</span> <span class="o">=</span> <span class="n">fcol_loops</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span>
    <span class="n">fcol_vector</span> <span class="o">=</span> <span class="n">fcol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">fcol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">fcol_vector</span> <span class="o">=</span> <span class="n">fcol_vector</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_top_to_t_bot_to_b</span><span class="p">)</span>



<span class="c1">#    mpv, p = create_layer_sympy_var_and_maps_vectorized(layer_prop=[&#39;z&#39;,&#39;a&#39;, &#39;b&#39;])</span>
<span class="c1">#    mp, p = create_layer_sympy_var_and_maps(layer_prop=[&#39;z&#39;,&#39;a&#39;,&#39;b&#39;])</span>
<span class="c1">#</span>
<span class="c1">#    phi_i = sympy.sin(mi * z)</span>


<span class="c1">#    fcol = sympy.integrate(p[&#39;a&#39;] * p[&#39;b&#39;] * phi_i, z)</span>
<span class="c1">#    fcol_loops = fcol.subs(z, mp[&#39;zbot&#39;]) - fcol.subs(z, mp[&#39;ztop&#39;])</span>
<span class="c1">#    fcol_loops = fcol_loops.subs(mp)</span>
<span class="c1">#    fcol_vector = fcol.subs(z, mpv[&#39;zbot&#39;]) - fcol.subs(z, mpv[&#39;ztop&#39;])</span>
<span class="c1">#    fcol_vector = fcol_vector.subs(mpv)</span>

    <span class="n">text_python</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;def dim1sin_ab_linear(m, at, ab, bt, bb,  zt, zb, implementation=&#39;vectorized&#39;):</span>

<span class="s2">    #import numpy as np #import this at module level</span>
<span class="s2">    #import math #import this at module level</span>

<span class="s2">    m = np.asarray(m)</span>
<span class="s2">    at = np.asarray(at)</span>
<span class="s2">    ab = np.asarray(ab)</span>
<span class="s2">    bt = np.asarray(bt)</span>
<span class="s2">    bb = np.asarray(bb)</span>
<span class="s2">    zt = np.asarray(zt)</span>
<span class="s2">    zb = np.asarray(zb)</span>

<span class="s2">    neig = len(m)</span>

<span class="s2">    if implementation == &#39;scalar&#39;:</span>
<span class="s2">        sin = math.sin</span>
<span class="s2">        cos = math.cos</span>
<span class="s2">        A = np.zeros(neig, float)</span>

<span class="s2">        nlayers = len(zt)</span>
<span class="s2">        for layer in range(nlayers):</span>
<span class="s2">            a_slope = (ab[layer] - at[layer]) / (zb[layer] - zt[layer])</span>
<span class="s2">            b_slope = (bb[layer] - bt[layer]) / (zb[layer] - zt[layer])</span>
<span class="s2">            for i in range(neig):</span>
<span class="s2">                A[i] += (</span><span class="si">{0}</span><span class="s2">)</span>

<span class="s2">    elif implementation == &#39;fortran&#39;:</span>
<span class="s2">        if MUST_TRY_FORTRAN:</span>
<span class="s2">            import geotecha.speccon.ext_integrals as ext_integ</span>
<span class="s2">            A = ext_integ.dim1sin_ab_linear(m, at, ab, bt, bb, zt, zb)</span>
<span class="s2">        else:</span>
<span class="s2">            try:</span>
<span class="s2">                import geotecha.speccon.ext_integrals as ext_integ</span>
<span class="s2">                A = ext_integ.dim1sin_ab_linear(m, at, ab, bt, bb, zt, zb)</span>
<span class="s2">            except ImportError:</span>
<span class="s2">                A = dim1sin_ab_linear(m, at, ab, bt, bb, zt, zb, implementation=&#39;vectorized&#39;)</span>

<span class="s2">    else:#default is &#39;vectorized&#39; using numpy</span>
<span class="s2">        sin = np.sin</span>
<span class="s2">        cos = np.cos</span>
<span class="s2">        A = np.zeros(neig, float)</span>

<span class="s2">        a_slope = (ab - at) / (zb - zt)</span>
<span class="s2">        b_slope = (bb - bt) / (zb - zt)</span>
<span class="s2">        mi = m[:, np.newaxis]</span>
<span class="s2">        A[:] = np.sum(</span><span class="si">{1}</span><span class="s2">, axis=1)</span>


<span class="s2">    return A&quot;&quot;&quot;</span>


<span class="c1">#    note the the i=j part in the fortran loop  below is because</span>
<span class="c1">#      I changed the loop order from layer, i,j to layer, j,i which is</span>
<span class="c1">#      i think faster as first index of a fortran array loops faster</span>
<span class="c1">#      my sympy code is mased on m[i], hence the need for i=j.</span>
    <span class="n">text_fortran</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">      SUBROUTINE dim1sin_ab_linear(m, at, ab, bt, bb, zt, zb, &amp;</span>
<span class="s2">                                   a, neig, nlayers)</span>
<span class="s2">        USE types</span>
<span class="s2">        IMPLICIT NONE</span>

<span class="s2">        INTEGER, intent(in) :: neig</span>
<span class="s2">        INTEGER, intent(in) :: nlayers</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:neig-1) ::m</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nlayers-1) :: at,ab,bt,bb,zt,zb</span>
<span class="s2">        REAL(DP), intent(out), dimension(0:neig-1) :: a</span>
<span class="s2">        INTEGER :: i, layer</span>
<span class="s2">        REAL(DP) :: a_slope, b_slope</span>
<span class="s2">        a=0.0D0</span>
<span class="s2">        DO layer = 0, nlayers-1</span>
<span class="s2">          a_slope = (ab(layer) - at(layer)) / (zb(layer) - zt(layer))</span>
<span class="s2">          b_slope = (bb(layer) - bt(layer)) / (zb(layer) - zt(layer))</span>
<span class="s2">          DO i = 0, neig-1</span>
<span class="si">{0}</span><span class="s2"></span>
<span class="s2">          END DO</span>
<span class="s2">        END DO</span>

<span class="s2">      END SUBROUTINE&quot;&quot;&quot;</span>





    <span class="n">fn</span> <span class="o">=</span> <span class="n">text_python</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tw</span><span class="p">(</span><span class="n">fcol_loops</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">fcol_vector</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">fn2</span> <span class="o">=</span> <span class="n">text_fortran</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">fcol_loops</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i) = a(i) + &#39;</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fn2</span></div>


<div class="viewcode-block" id="dim1sin_abc_linear_implementations"><a class="viewcode-back" href="../../../api/geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.dim1sin_abc_linear_implementations">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_abc_linear_implementations</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Code generation for Integrations of sin(mi * z) * a(z) * b(z) * c(z)</span>
<span class="sd">    between ztop and zbot where a(z), b(z), c(z) are piecewise linear functions of z.</span>

<span class="sd">    Code is generated that will produce a 1d array with the appropriate</span>
<span class="sd">    integrals at each location.</span>

<span class="sd">    Paste the resulting code (at least the loops) into `dim1sin_abc_linear`.</span>

<span class="sd">    Creates three implementations:</span>

<span class="sd">     - &#39;scalar&#39;, python loops (slowest).</span>
<span class="sd">     - &#39;vectorized&#39;, numpy (much faster than scalar).</span>
<span class="sd">     - &#39;fortran&#39;, fortran loops (fastest).  Needs to be compiled and interfaced</span>
<span class="sd">       with f2py.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fn : string</span>
<span class="sd">        Python code with scalar (loops) and vectorized (numpy) implementations</span>
<span class="sd">        also calls the fortran version.</span>
<span class="sd">    fn2 : string</span>
<span class="sd">        Fortran code.  Needs to be compiled with f2py.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    geotecha.speccon.integrals.dim1sin_abc_linear : Resulting function.</span>
<span class="sd">    geotecha.speccon.integrals.pdim1sin_abc_linear : Resulting function with PolyLine</span>
<span class="sd">        inputs.</span>
<span class="sd">    geotecha.speccon.ext_integrals.dim1sin_abc_linear : Resulting fortran function.</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The `dim1sin_abc_linear` which should be treated as a column vector,</span>
<span class="sd">    :math:`A` is given by:</span>

<span class="sd">    .. math:: \\mathbf{A}_{i}=\\int_{0}^1{{a\\left(z\\right)}{b\\left(z\\right)}{c\\left(z\\right)}\\phi_i\\,dz}</span>

<span class="sd">    where the basis function :math:`\\phi_i` is given by:</span>

<span class="sd">    .. math:: \\phi_i\\left(z\\right)=\\sin\\left({m_i}z\\right)</span>

<span class="sd">    and :math:`a\\left(z\\right)`, :math:`b\\left(z\\right)`, and</span>
<span class="sd">    :math:`c\\left(z\\right)` are piecewise linear functions</span>
<span class="sd">    with respect to :math:`z`, that within a layer are defined by:</span>

<span class="sd">    .. math:: a\\left(z\\right) = a_t+\\frac{a_b-a_t}{z_b-z_t}\\left(z-z_t\\right)</span>

<span class="sd">    with :math:`t` and :math:`b` subscripts representing &#39;top&#39; and &#39;bottom&#39; of</span>
<span class="sd">    each layer respectively.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">SympyVarsFor1DSpectralDerivation</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
    <span class="n">integ_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

    <span class="n">phi_i</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">mi</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

    <span class="n">fcol</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">b</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">c</span><span class="o">*</span> <span class="n">phi_i</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="o">**</span><span class="n">integ_kwargs</span><span class="p">)</span>
    <span class="n">fcol_loops</span> <span class="o">=</span> <span class="n">fcol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">fcol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">fcol_loops</span> <span class="o">=</span> <span class="n">fcol_loops</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span>
    <span class="n">fcol_vector</span> <span class="o">=</span> <span class="n">fcol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">fcol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">fcol_vector</span> <span class="o">=</span> <span class="n">fcol_vector</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_top_to_t_bot_to_b</span><span class="p">)</span>


    <span class="n">text_python</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;def dim1sin_abc_linear(m, at, ab, bt, bb, ct, cb, zt, zb, implementation=&#39;vectorized&#39;):</span>

<span class="s2">    #import numpy as np #import this at module level</span>
<span class="s2">    #import math #import this at module level</span>

<span class="s2">    m = np.asarray(m)</span>
<span class="s2">    at = np.asarray(at)</span>
<span class="s2">    ab = np.asarray(ab)</span>
<span class="s2">    bt = np.asarray(bt)</span>
<span class="s2">    bb = np.asarray(bb)</span>
<span class="s2">    ct = np.asarray(ct)</span>
<span class="s2">    cb = np.asarray(cb)</span>
<span class="s2">    zt = np.asarray(zt)</span>
<span class="s2">    zb = np.asarray(zb)</span>

<span class="s2">    neig = len(m)</span>

<span class="s2">    if implementation == &#39;scalar&#39;:</span>
<span class="s2">        sin = math.sin</span>
<span class="s2">        cos = math.cos</span>
<span class="s2">        A = np.zeros(neig, float)</span>
<span class="s2">        nlayers = len(zt)</span>
<span class="s2">        for layer in range(nlayers):</span>
<span class="s2">            a_slope = (ab[layer] - at[layer]) / (zb[layer] - zt[layer])</span>
<span class="s2">            b_slope = (bb[layer] - bt[layer]) / (zb[layer] - zt[layer])</span>
<span class="s2">            c_slope = (cb[layer] - ct[layer]) / (zb[layer] - zt[layer])</span>
<span class="s2">            for i in range(neig):</span>
<span class="s2">                A[i] += (</span><span class="si">{0}</span><span class="s2">)</span>

<span class="s2">    elif implementation == &#39;fortran&#39;:</span>
<span class="s2">        if MUST_TRY_FORTRAN:</span>
<span class="s2">            import geotecha.speccon.ext_integrals as ext_integ</span>
<span class="s2">            A = ext_integ.dim1sin_abc_linear(m, at, ab, bt, bb,  ct, cb, zt, zb)</span>
<span class="s2">        else:</span>
<span class="s2">            try:</span>
<span class="s2">                import geotecha.speccon.ext_integrals as ext_integ</span>
<span class="s2">                A = ext_integ.dim1sin_abc_linear(m, at, ab, bt, bb,  ct, cb, zt, zb)</span>
<span class="s2">            except ImportError:</span>
<span class="s2">                A = dim1sin_abc_linear(m, at, ab, bt, bb,  ct, cb, zt, zb, implementation=&#39;vectorized&#39;)</span>

<span class="s2">    else:#default is &#39;vectorized&#39; using numpy</span>
<span class="s2">        sin = np.sin</span>
<span class="s2">        cos = np.cos</span>
<span class="s2">        A = np.zeros(neig, float)</span>


<span class="s2">        a_slope = (ab - at) / (zb - zt)</span>
<span class="s2">        b_slope = (bb - bt) / (zb - zt)</span>
<span class="s2">        c_slope = (cb - ct) / (zb - zt)</span>

<span class="s2">        mi = m[:, np.newaxis]</span>
<span class="s2">        A[:] = np.sum(</span><span class="si">{1}</span><span class="s2">, axis=1)</span>


<span class="s2">    return A&quot;&quot;&quot;</span>


<span class="c1">#    note the the i=j part in the fortran loop  below is because</span>
<span class="c1">#      I changed the loop order from layer, i,j to layer, j,i which is</span>
<span class="c1">#      i think faster as first index of a fortran array loops faster</span>
<span class="c1">#      my sympy code is mased on m[i], hence the need for i=j.</span>
    <span class="n">text_fortran</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">      SUBROUTINE dim1sin_abc_linear(m, at, ab, bt, bb, ct, cb, &amp;</span>
<span class="s2">                                    zt, zb, a, neig, nlayers)</span>
<span class="s2">        USE types</span>
<span class="s2">        IMPLICIT NONE</span>

<span class="s2">        INTEGER, intent(in) :: neig</span>
<span class="s2">        INTEGER, intent(in) :: nlayers</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:neig-1) ::m</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nlayers-1) :: at,ab,bt,bb, &amp;</span>
<span class="s2">                                                        ct,cb,zt,zb</span>
<span class="s2">        REAL(DP), intent(out), dimension(0:neig-1) :: a</span>
<span class="s2">        INTEGER :: i, layer</span>
<span class="s2">        REAL(DP) :: a_slope, b_slope, c_slope</span>
<span class="s2">        a=0.0D0</span>
<span class="s2">        DO layer = 0, nlayers-1</span>
<span class="s2">          a_slope = (ab(layer) - at(layer)) / (zb(layer) - zt(layer))</span>
<span class="s2">          b_slope = (bb(layer) - bt(layer)) / (zb(layer) - zt(layer))</span>
<span class="s2">          c_slope = (cb(layer) - ct(layer)) / (zb(layer) - zt(layer))</span>
<span class="s2">          DO i = 0, neig-1</span>
<span class="si">{0}</span><span class="s2"></span>
<span class="s2">          END DO</span>
<span class="s2">        END DO</span>

<span class="s2">      END SUBROUTINE&quot;&quot;&quot;</span>





    <span class="n">fn</span> <span class="o">=</span> <span class="n">text_python</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tw</span><span class="p">(</span><span class="n">fcol_loops</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">fcol_vector</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">fn2</span> <span class="o">=</span> <span class="n">text_fortran</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">fcol_loops</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i) = a(i) + &#39;</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fn2</span></div>


<div class="viewcode-block" id="dim1sin_D_aDb_linear_implementations"><a class="viewcode-back" href="../../../api/geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.dim1sin_D_aDb_linear_implementations">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_D_aDb_linear_implementations</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Code generation for Integrations of `sin(mi * z) * D[a(z) * D[b(z), z], z]`</span>
<span class="sd">    between ztop and zbot where a(z) is a piecewisepiecewise linear function of z,</span>
<span class="sd">    and b(z) is a linear function of z.</span>

<span class="sd">    Code is generated that will produce a 1d array with the appropriate</span>
<span class="sd">    integrals at each location.</span>

<span class="sd">    Paste the resulting code (at least the loops) into `dim1sin_D_aDb_linear`.</span>

<span class="sd">    Creates three implementations:</span>

<span class="sd">     - &#39;scalar&#39;, python loops (slowest).</span>
<span class="sd">     - &#39;vectorized&#39;, numpy (much faster than scalar).</span>
<span class="sd">     - &#39;fortran&#39;, fortran loops (fastest).  Needs to be compiled and interfaced</span>
<span class="sd">       with f2py.</span>


<span class="sd">    .. warning::</span>
<span class="sd">        The functions produced are set up to accept the b(z) input as</span>
<span class="sd">        piecewise linear, i.e. zt, zb, bt, bb etc. It is up to the user to</span>
<span class="sd">        ensure that the bt and bb are such that they define a continuous</span>
<span class="sd">        linear function. eg. to define b(z)=z+1 then use</span>
<span class="sd">        zt=[0,0.4], zb=[0.4, 1], bt=[1,1.4], bb=[1.4,2].</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fn : string</span>
<span class="sd">        Python code with scalar (loops) and vectorized (numpy) implementations</span>
<span class="sd">        also calls the fortran version.</span>
<span class="sd">    fn2 : string</span>
<span class="sd">        Fortran code.  Needs to be compiled with f2py.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    geotecha.speccon.integrals.dim1sin_D_aDb_linear : Resulting function.</span>
<span class="sd">    geotecha.speccon.integrals.pdim1sin_D_aDb_linear : Resulting function with PolyLine</span>
<span class="sd">        inputs.</span>
<span class="sd">    geotecha.speccon.ext_integrals.dim1sin_D_aDb_linear : Resulting fortran function.</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The `dim1sin_D_aDb_linear` which should be treated as a column vector,</span>
<span class="sd">    :math:`A` is given by:</span>

<span class="sd">    .. math:: \\mathbf{A}_{i}=\\int_{0}^1{\\frac{d}{dz}\\left({a\\left(z\\right)}\\frac{d}{dz}{b\\left(z\\right)}\\right)\\phi_i\\,dz}</span>

<span class="sd">    where the basis function :math:`\\phi_i` is given by:</span>

<span class="sd">    .. math:: \\phi_i\\left(z\\right)=\\sin\\left({m_i}z\\right)</span>

<span class="sd">    and :math:`a\\left(z\\right)` is a piecewise</span>
<span class="sd">    linear functions with respect to :math:`z`, that within a layer is defined by:</span>

<span class="sd">    .. math:: a\\left(z\\right) = a_t+\\frac{a_b-a_t}{z_b-z_t}\\left(z-z_t\\right)</span>

<span class="sd">    with :math:`t` and :math:`b` subscripts representing &#39;top&#39; and &#39;bottom&#39; of</span>
<span class="sd">    each layer respectively.</span>

<span class="sd">    :math:`b\\left(z\\right)` is a linear function of :math:`z` defined by</span>

<span class="sd">    .. math:: b\\left(z\\right) = b_t+\\left({b_b-b_t}\\right)z</span>

<span class="sd">    with :math:`t` and :math:`b` subscripts now representing &#39;top&#39; and</span>
<span class="sd">    &#39;bottom&#39; of the profile respectively.</span>

<span class="sd">    Using the product rule for differentiation the above integral can be split</span>
<span class="sd">    into:</span>

<span class="sd">    .. math:: \\mathbf{A}_{i}=\\int_{0}^1{\\frac{da\\left(z\\right)}{dz}\\frac{db\\left(z\\right)}{dz}\\phi_i\\,dz} +</span>
<span class="sd">                              \\int_{0}^1{a\\left(z\\right)\\frac{d^2b\\left(z\\right)}{dz^2}\\phi_i\\,dz}</span>

<span class="sd">    The right hand term is zero because :math:`b\\left(z\\right)` is a</span>
<span class="sd">    continuous linear function so it&#39;s second derivative is zero.  The</span>
<span class="sd">    first derivative of :math:`b\\left(z\\right)` is a constant so the</span>
<span class="sd">    left term can be integrated by parts to give:</span>

<span class="sd">    .. math:: \\mathbf{A}_{i}=\\frac{db\\left(z\\right)}{dz}\\left(</span>
<span class="sd">                \\left.\\phi_i{a\\left(z\\right)}\\right|_{z=0}^{z=1} -</span>
<span class="sd">                -\\int_{0}^1{{a\\left(z\\right)}\\frac{d\\phi_i}{dz}\\,dz}</span>
<span class="sd">                \\right)</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">SympyVarsFor1DSpectralDerivation</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
    <span class="n">integ_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

    <span class="n">phi_i</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">mi</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

    <span class="n">fcol</span> <span class="o">=</span> <span class="o">-</span> <span class="n">sympy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">*</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">phi_i</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">*</span>
                                                    <span class="n">v</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span>
                                                    <span class="o">**</span><span class="n">integ_kwargs</span><span class="p">)</span>
    <span class="n">fcol_loops</span> <span class="o">=</span> <span class="n">fcol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">fcol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">fcol_loops</span> <span class="o">=</span> <span class="n">fcol_loops</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span>
    <span class="n">fcol_vector</span> <span class="o">=</span> <span class="n">fcol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">fcol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">fcol_vector</span> <span class="o">=</span> <span class="n">fcol_vector</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_top_to_t_bot_to_b</span><span class="p">)</span>


    <span class="n">v</span> <span class="o">=</span> <span class="n">SympyVarsFor1DSpectralDerivation</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">slope</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">fend</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi_i</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">a</span>

    <span class="n">fbot</span> <span class="o">=</span> <span class="n">fend</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span>
    <span class="n">fbot_loops</span> <span class="o">=</span> <span class="n">fbot</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span>
    <span class="n">nlayers</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;nlayers&#39;</span><span class="p">)</span>
    <span class="n">fbot_loops</span> <span class="o">=</span> <span class="n">fbot_loops</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">v</span><span class="o">.</span><span class="n">layer</span><span class="p">,</span> <span class="n">nlayers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)])</span>
    <span class="n">fbot_vector</span> <span class="o">=</span> <span class="n">fbot</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
    <span class="n">fbot_vector</span> <span class="o">=</span> <span class="n">fbot_vector</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">v</span><span class="o">.</span><span class="n">layer</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)])</span>

    <span class="n">ftop</span> <span class="o">=</span> <span class="n">fend</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">ftop_loops</span> <span class="o">=</span> <span class="n">ftop</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span>
    <span class="n">ftop_loops</span> <span class="o">=</span> <span class="n">ftop_loops</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">v</span><span class="o">.</span><span class="n">layer</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
    <span class="n">ftop_vector</span> <span class="o">=</span> <span class="n">ftop</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
    <span class="n">ftop_vector</span> <span class="o">=</span> <span class="n">ftop_vector</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">v</span><span class="o">.</span><span class="n">layer</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>

    <span class="n">fends_loops</span> <span class="o">=</span> <span class="n">fbot_loops</span> <span class="o">-</span> <span class="n">ftop_loops</span>
    <span class="n">fends_vector</span> <span class="o">=</span> <span class="n">fbot_vector</span> <span class="o">-</span> <span class="n">ftop_vector</span>

    <span class="n">text_python</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;def dim1sin_D_aDb_linear(m, at, ab, bt, bb,  zt, zb, implementation=&#39;vectorized&#39;):</span>

<span class="s2">    #import numpy as np #import this at module level</span>
<span class="s2">    #import math #import this at module level</span>

<span class="s2">    m = np.asarray(m)</span>
<span class="s2">    at = np.asarray(at)</span>
<span class="s2">    ab = np.asarray(ab)</span>
<span class="s2">    bt = np.asarray(bt)</span>
<span class="s2">    bb = np.asarray(bb)</span>
<span class="s2">    zt = np.asarray(zt)</span>
<span class="s2">    zb = np.asarray(zb)</span>

<span class="s2">    neig = len(m)</span>

<span class="s2">    if implementation == &#39;scalar&#39;:</span>
<span class="s2">        sin = math.sin</span>
<span class="s2">        cos = math.cos</span>
<span class="s2">        A = np.zeros(neig, float)</span>
<span class="s2">        nlayers = len(zt)</span>
<span class="s2">        for layer in range(nlayers):</span>
<span class="s2">            a_slope = (ab[layer] - at[layer]) / (zb[layer] - zt[layer])</span>
<span class="s2">            b_slope = (bb[layer] - bt[layer]) / (zb[layer] - zt[layer])</span>
<span class="s2">            for i in range(neig):</span>
<span class="s2">                A[i] += (</span><span class="si">{0}</span><span class="s2">)</span>

<span class="s2">        for i in range(neig):</span>
<span class="s2">            A[i] += (</span><span class="si">{1}</span><span class="s2">)</span>
<span class="s2">    elif implementation == &#39;fortran&#39;:</span>
<span class="s2">        if MUST_TRY_FORTRAN:</span>
<span class="s2">            import geotecha.speccon.ext_integrals as ext_integ</span>
<span class="s2">            A = ext_integ.dim1sin_d_adb_linear(m, at, ab, bt, bb, zt, zb)</span>
<span class="s2">        else:</span>
<span class="s2">            try:</span>
<span class="s2">                import geotecha.speccon.ext_integrals as ext_integ</span>
<span class="s2">                A = ext_integ.dim1sin_d_adb_linear(m, at, ab, bt, bb, zt, zb)</span>
<span class="s2">            except ImportError:</span>
<span class="s2">                A = dim1sin_D_aDb_linear(m, at, ab, bt, bb, zt, zb, implementation=&#39;vectorized&#39;)</span>

<span class="s2">    else:#default is &#39;vectorized&#39; using numpy</span>
<span class="s2">        sin = np.sin</span>
<span class="s2">        cos = np.cos</span>
<span class="s2">        A = np.zeros(neig, float)</span>

<span class="s2">        a_slope = (ab - at) / (zb - zt)</span>
<span class="s2">        b_slope = (bb - bt) / (zb - zt)</span>
<span class="s2">        mi = m[:, np.newaxis]</span>
<span class="s2">        A[:] = np.sum(</span><span class="si">{2}</span><span class="s2">, axis=1)</span>
<span class="s2">        mi = m</span>
<span class="s2">        A[:]+= (</span><span class="si">{3}</span><span class="s2">)</span>
<span class="s2">    return A&quot;&quot;&quot;</span>


<span class="c1">#    note the the i=j part in the fortran loop  below is because</span>
<span class="c1">#      I changed the loop order from layer, i,j to layer, j,i which is</span>
<span class="c1">#      i think faster as first index of a fortran array loops faster</span>
<span class="c1">#      my sympy code is mased on m[i], hence the need for i=j.</span>
    <span class="n">text_fortran</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">      SUBROUTINE dim1sin_D_aDb_linear(m, at, ab, bt, bb, zt, zb, &amp;</span>
<span class="s2">                                      a, neig, nlayers)</span>
<span class="s2">        USE types</span>
<span class="s2">        IMPLICIT NONE</span>

<span class="s2">        INTEGER, intent(in) :: neig</span>
<span class="s2">        INTEGER, intent(in) :: nlayers</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:neig-1) ::m</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nlayers-1) :: at,ab,bt,bb,zt,zb</span>
<span class="s2">        REAL(DP), intent(out), dimension(0:neig-1) :: a</span>
<span class="s2">        INTEGER :: i, layer</span>
<span class="s2">        REAL(DP) :: a_slope, b_slope</span>
<span class="s2">        a=0.0D0</span>
<span class="s2">        DO layer = 0, nlayers-1</span>
<span class="s2">          a_slope = (ab(layer) - at(layer)) / (zb(layer) - zt(layer))</span>
<span class="s2">          b_slope = (bb(layer) - bt(layer)) / (zb(layer) - zt(layer))</span>
<span class="s2">          DO i = 0, neig-1</span>
<span class="si">{0}</span><span class="s2"></span>
<span class="s2">          END DO</span>
<span class="s2">        END DO</span>

<span class="s2">        DO i = 0, neig-1</span>
<span class="si">{1}</span><span class="s2"></span>
<span class="s2">        END DO</span>

<span class="s2">      END SUBROUTINE&quot;&quot;&quot;</span>





    <span class="n">fn</span> <span class="o">=</span> <span class="n">text_python</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tw</span><span class="p">(</span><span class="n">fcol_loops</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">fends_loops</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">fcol_vector</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">fends_vector</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">fn2</span> <span class="o">=</span> <span class="n">text_fortran</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">fcol_loops</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i) = a(i) + &#39;</span><span class="p">),</span>
                              <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">fends_loops</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i) = a(i) + &#39;</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fn2</span></div>


<div class="viewcode-block" id="dim1sin_a_linear_between"><a class="viewcode-back" href="../../../api/geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.dim1sin_a_linear_between">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_a_linear_between</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Code generation for Integrations of `sin(mi * z) * a(z)`</span>
<span class="sd">    between [z1, z2] where a(z) is a piecewise linear functions of z.</span>

<span class="sd">    Calculates array A[len(z), len(m)].</span>

<span class="sd">    Paste the resulting code into `dim1sin_a_linear_between`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fn : string</span>
<span class="sd">        Python code with scalar (loops) implementation.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    geotecha.speccon.integrals.dim1sin_a_linear_between : Resulting function.</span>
<span class="sd">    geotecha.speccon.integrals.pdim1sin_a_linear_between : Resulting function with PolyLine</span>
<span class="sd">        inputs.</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The `dim1sin_a_linear_between`, :math:`A`, is given by:</span>

<span class="sd">    .. math:: \\mathbf{A}_{i,j}=</span>
<span class="sd">                \\int_{z_1}^{z_2}{{a\\left(z\\right)}\\phi_j\\,dz}</span>

<span class="sd">    where the basis function :math:`\\phi_j` is given by:</span>

<span class="sd">    .. math:: \\phi_j\\left(z\\right)=\\sin\\left({m_j}z\\right)</span>

<span class="sd">    and :math:`a\\left(z\\right)` is a piecewise</span>
<span class="sd">    linear functions with respect to :math:`z`, that within a layer are defined by:</span>

<span class="sd">    .. math:: a\\left(z\\right) = a_t+\\frac{a_b-a_t}{z_b-z_t}\\left(z-z_t\\right)</span>

<span class="sd">    with :math:`t` and :math:`b` subscripts representing &#39;top&#39; and &#39;bottom&#39; of</span>
<span class="sd">    each layer respectively.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">SympyVarsFor1DSpectralDerivation</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">slope</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">integ_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">v</span><span class="o">.</span><span class="n">z1</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;z1&#39;</span><span class="p">)</span>
    <span class="n">v</span><span class="o">.</span><span class="n">z2</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;z2&#39;</span><span class="p">)</span>


    <span class="n">phi_j</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">mj</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">phi_j</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="o">**</span><span class="n">integ_kwargs</span><span class="p">)</span>

    <span class="n">both</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z2</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z1</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">i</span><span class="p">])</span>
    <span class="n">both</span> <span class="o">=</span> <span class="n">both</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span>

    <span class="n">between</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">between</span> <span class="o">=</span> <span class="n">between</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span>

    <span class="n">z1_only</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z1</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">i</span><span class="p">])</span>
    <span class="n">z1_only</span> <span class="o">=</span> <span class="n">z1_only</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span>

    <span class="n">z2_only</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z2</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">z2_only</span> <span class="o">=</span> <span class="n">z2_only</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span>


    <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;dim1sin_a_linear_between(m, at, ab, zt, zb, z):</span>
<span class="s2">    #import numpy as np #import this globally</span>
<span class="s2">    #import math #import this globally</span>

<span class="s2">    sin=math.sin</span>
<span class="s2">    cos=math.cos</span>
<span class="s2">    m = np.asarray(m)</span>
<span class="s2">    at = np.asarray(at)</span>
<span class="s2">    ab = np.asarray(ab)</span>
<span class="s2">    zt = np.asarray(zt)</span>
<span class="s2">    zb = np.asarray(zb)</span>

<span class="s2">    z = np.atleast_2d(z)</span>

<span class="s2">    z1 = z[:,0]</span>
<span class="s2">    z2 = z[:,1]</span>

<span class="s2">    z_for_interp = np.zeros(len(zt)+1)</span>
<span class="s2">    z_for_interp[:-1] = zt[:]</span>
<span class="s2">    z_for_interp[-1]=zb[-1]</span>


<span class="s2">    (segment_both,</span>
<span class="s2">     segment_z1_only,</span>
<span class="s2">     segment_z2_only,</span>
<span class="s2">     segments_between) = segments_between_xi_and_xj(z_for_interp, z1, z2)</span>

<span class="s2">    nz = len(z)</span>
<span class="s2">    neig = len(m)</span>

<span class="s2">    A = np.zeros((nz,neig), dtype=float)</span>
<span class="s2">    for i in range(nz):</span>
<span class="s2">        for layer in segment_both[i]:</span>
<span class="s2">            a_slope = (ab[layer] - at[layer]) / (zb[layer] - zt[layer])</span>
<span class="s2">            for j in range(neig):</span>
<span class="s2">                A[i,j] += (</span><span class="si">{0}</span><span class="s2">)</span>
<span class="s2">        for layer in segment_z1_only[i]:</span>
<span class="s2">            a_slope = (ab[layer] - at[layer]) / (zb[layer] - zt[layer])</span>
<span class="s2">            for j in range(neig):</span>
<span class="s2">                A[i,j] += (</span><span class="si">{1}</span><span class="s2">)</span>
<span class="s2">        for layer in segments_between[i]:</span>
<span class="s2">            a_slope = (ab[layer] - at[layer]) / (zb[layer] - zt[layer])</span>
<span class="s2">            for j in range(neig):</span>
<span class="s2">                A[i,j] += (</span><span class="si">{2}</span><span class="s2">)</span>
<span class="s2">        for layer in segment_z2_only[i]:</span>
<span class="s2">            a_slope = (ab[layer] - at[layer]) / (zb[layer] - zt[layer])</span>
<span class="s2">            for j in range(neig):</span>
<span class="s2">                A[i,j] += (</span><span class="si">{3}</span><span class="s2">)</span>
<span class="s2">    return A&quot;&quot;&quot;</span>


    <span class="n">fn</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tw</span><span class="p">(</span><span class="n">both</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">z1_only</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">between</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">z2_only</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">fn</span></div>


<div class="viewcode-block" id="dim1_ab_linear_between"><a class="viewcode-back" href="../../../api/geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.dim1_ab_linear_between">[docs]</a><span class="k">def</span> <span class="nf">dim1_ab_linear_between</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Code generation for Integrations of `a(z) * b(z)`</span>
<span class="sd">    between [z1, z2] where a(z) is a piecewise linear functions of z.</span>


<span class="sd">    Calculates array A[len(z)]</span>

<span class="sd">    Paste the resulting code (at least the loops) into</span>
<span class="sd">    `piecewise_linear_1d.integrate_x1a_x2a_y1a_y2a_multiply_x1b_x2b_y1b_y2b_between`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fn : string</span>
<span class="sd">        Python code with scalar (loops) implementation.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    geotecha.piecewise.piecewise_linear_1d.integrate_x1a_x2a_y1a_y2a_multiply_x1b_x2b_y1b_y2b_between : Resulting function.</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The `dim1sin_ab_linear_between`, :math:`A`, is given by:</span>

<span class="sd">    .. math:: \\mathbf{A}_{i}=\\int_{z_1}^{z_2}{{a\\left(z\\right)}{b\\left(z\\right)}\\,dz}</span>

<span class="sd">    where :math:`a\\left(z\\right)` and :math:`b\\left(z\\right)` are piecewise</span>
<span class="sd">    linear functions with respect to :math:`z`, that within a layer are defined by:</span>

<span class="sd">    .. math:: a\\left(z\\right) = a_t+\\frac{a_b-a_t}{z_b-z_t}\\left(z-z_t\\right)</span>

<span class="sd">    with :math:`t` and :math:`b` subscripts representing &#39;top&#39; and &#39;bottom&#39; of</span>
<span class="sd">    each layer respectively.</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c1"># Because this integration goes into</span>
    <span class="c1"># geotecha.piecewise.piecewise_linear_1d rather than</span>
    <span class="c1"># speccon.integrals I have had to use a separate map function to massage</span>
    <span class="c1"># the variable names into a naming convention consistent with</span>
    <span class="c1"># piecewise_linear_1d (this is m2 below).</span>
    <span class="c1"># As such don&#39;t base anything off this funciton unless you know what</span>
    <span class="c1"># you are doing.</span>


    <span class="n">v</span> <span class="o">=</span> <span class="n">SympyVarsFor1DSpectralDerivation</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">slope</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">integ_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">v</span><span class="o">.</span><span class="n">z1</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;z1&#39;</span><span class="p">)</span>
    <span class="n">v</span><span class="o">.</span><span class="n">z2</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;z2&#39;</span><span class="p">)</span>

    <span class="n">seg</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;seg&#39;</span><span class="p">)</span>
    <span class="n">x1a</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;x1a&#39;</span><span class="p">)</span>
    <span class="n">x2a</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;x2a&#39;</span><span class="p">)</span>
    <span class="n">y1a</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;y1a&#39;</span><span class="p">)</span>
    <span class="n">y2a</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;y2a&#39;</span><span class="p">)</span>
    <span class="n">y1b</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;y1b&#39;</span><span class="p">)</span>
    <span class="n">y2b</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;y2b&#39;</span><span class="p">)</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;xi&#39;</span><span class="p">)</span>
    <span class="n">xj</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;xj&#39;</span><span class="p">)</span>
    <span class="n">mp2</span> <span class="o">=</span> <span class="p">[(</span><span class="n">v</span><span class="o">.</span><span class="n">zb</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">layer</span><span class="p">],</span> <span class="n">x2a</span><span class="p">[</span><span class="n">seg</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">zt</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">layer</span><span class="p">],</span> <span class="n">x1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">ab</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">layer</span><span class="p">],</span> <span class="n">y2a</span><span class="p">[</span><span class="n">seg</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">layer</span><span class="p">],</span> <span class="n">y1a</span><span class="p">[</span><span class="n">seg</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">bb</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">layer</span><span class="p">],</span> <span class="n">y2b</span><span class="p">[</span><span class="n">seg</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">bt</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">layer</span><span class="p">],</span> <span class="n">y1b</span><span class="p">[</span><span class="n">seg</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z1</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">i</span><span class="p">],</span> <span class="n">xi</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">i</span><span class="p">]),</span>
           <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z2</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">i</span><span class="p">],</span> <span class="n">xj</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">i</span><span class="p">])]</span>


    <span class="n">f</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="o">**</span><span class="n">integ_kwargs</span><span class="p">)</span>

    <span class="n">both</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z2</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z1</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">i</span><span class="p">])</span>
    <span class="n">both</span> <span class="o">=</span> <span class="n">both</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>

    <span class="n">between</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">between</span> <span class="o">=</span> <span class="n">between</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>

    <span class="n">z1_only</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z1</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">i</span><span class="p">])</span>
    <span class="n">z1_only</span> <span class="o">=</span> <span class="n">z1_only</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>

    <span class="n">z2_only</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z2</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">z2_only</span> <span class="o">=</span> <span class="n">z2_only</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mp2</span><span class="p">)</span>


    <span class="c1">######################</span>







<span class="c1">#    mp, p = create_layer_sympy_var_and_maps(layer_prop=[&#39;z&#39;, &#39;a&#39;, &#39;b&#39;])</span>
<span class="c1">#    sympy.var(&#39;z1, z2&#39;)</span>
<span class="c1">#</span>
<span class="c1">#    z1 = sympy.tensor.IndexedBase(&#39;z1&#39;)</span>
<span class="c1">#    z2 = sympy.tensor.IndexedBase(&#39;z2&#39;)</span>
<span class="c1">#    i = sympy.tensor.Idx(&#39;i&#39;)</span>
<span class="c1">#    j = sympy.tensor.Idx(&#39;j&#39;)</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#    sympy.var(&#39;x1a, x2a, y1a, y2a, x1b, x2b, y1b, y2b&#39;)</span>
<span class="c1">#    seg = sympy.tensor.Idx(&#39;seg&#39;)</span>
<span class="c1">#    x1a = sympy.tensor.IndexedBase(&#39;x1a&#39;)</span>
<span class="c1">#    x2a = sympy.tensor.IndexedBase(&#39;x2a&#39;)</span>
<span class="c1">#    y1a = sympy.tensor.IndexedBase(&#39;y1a&#39;)</span>
<span class="c1">#    y2a = sympy.tensor.IndexedBase(&#39;y2a&#39;)</span>
<span class="c1">#    y1b = sympy.tensor.IndexedBase(&#39;y1b&#39;)</span>
<span class="c1">#    y2b = sympy.tensor.IndexedBase(&#39;y2b&#39;)</span>
<span class="c1">#    xi = sympy.tensor.IndexedBase(&#39;xi&#39;)</span>
<span class="c1">#    xj = sympy.tensor.IndexedBase(&#39;xj&#39;)</span>
<span class="c1">#    #mp2 = {&#39;zb[layer]&#39;: x2a[seg]}</span>
<span class="c1">#    mp2 = [(mp[&#39;zbot&#39;], x2a[seg]),</span>
<span class="c1">#           (mp[&#39;ztop&#39;], x1a[seg]),</span>
<span class="c1">#           (mp[&#39;abot&#39;], y2a[seg]),</span>
<span class="c1">#           (mp[&#39;atop&#39;], y1a[seg]),</span>
<span class="c1">#           (mp[&#39;bbot&#39;], y2b[seg]),</span>
<span class="c1">#           (mp[&#39;btop&#39;], y1b[seg]),</span>
<span class="c1">#           (z1[i], xi[i]),</span>
<span class="c1">#           (z2[i], xj[i])]</span>
<span class="c1">#    #phi_j = sympy.sin(mj * z)</span>
<span class="c1">#</span>
<span class="c1">#    f = sympy.integrate(p[&#39;a&#39;] * p[&#39;b&#39;], z)</span>
<span class="c1">#</span>
<span class="c1">#    both = f.subs(z, z2[i]) - f.subs(z, z1[i])</span>
<span class="c1">#    both = both.subs(mp).subs(mp2)</span>
<span class="c1">#</span>
<span class="c1">#    between = f.subs(z, mp[&#39;zbot&#39;]) - f.subs(z, mp[&#39;ztop&#39;])</span>
<span class="c1">#    between = between.subs(mp).subs(mp2)</span>
<span class="c1">#</span>
<span class="c1">#    z1_only = f.subs(z, mp[&#39;zbot&#39;]) - f.subs(z, z1[i])</span>
<span class="c1">#    z1_only = z1_only.subs(mp).subs(mp2)</span>
<span class="c1">#</span>
<span class="c1">#    z2_only = f.subs(z, z2[i]) - f.subs(z, mp[&#39;ztop&#39;])</span>
<span class="c1">#    z2_only = z2_only.subs(mp).subs(mp2)</span>

<span class="c1">#    text = &quot;&quot;&quot;A = np.zeros(len(xi))</span>
<span class="c1">#    for i in range(len(xi)):</span>
<span class="c1">#        for seg in segment_both[i]:</span>
<span class="c1">#            A[i] += {}</span>
<span class="c1">#        for seg in segment_xi_only[i]:</span>
<span class="c1">#            A[i] += {}</span>
<span class="c1">#        for seg in segments_between[i]:</span>
<span class="c1">#            A[i] += {}</span>
<span class="c1">#        for seg in segment_xj_only[i]:</span>
<span class="c1">#            A[i] += {}</span>
<span class="c1">#</span>
<span class="c1">#    return A&quot;&quot;&quot;</span>


    <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;integrate_x1a_x2a_y1a_y2a_multiply_x1b_x2b_y1b_y2b_between(x1a, x2a,</span>
<span class="s2">                                                               y1a, y2a,</span>
<span class="s2">                                                               x1b, x2b,</span>
<span class="s2">                                                               y1b, y2b,</span>
<span class="s2">                                                               xi, xj):</span>

<span class="s2">    x1a = np.asarray(x1a)</span>
<span class="s2">    x2a = np.asarray(x2a)</span>
<span class="s2">    y1a = np.asarray(y1a)</span>
<span class="s2">    y2a = np.asarray(y2a)</span>
<span class="s2">    x1b = np.asarray(x1b)</span>
<span class="s2">    x2b = np.asarray(x2b)</span>
<span class="s2">    y1b = np.asarray(y1b)</span>
<span class="s2">    y2b = np.asarray(y2b)</span>

<span class="s2">    if (not np.allclose(x1a, x1b)) or (not np.allclose(x2a, x2b)): #they may be different sizes</span>
<span class="s2">        raise ValueError (&quot;x values are different; they must be the same: </span><span class="se">\\</span><span class="s2">nx1a = {{0}}</span><span class="se">\\</span><span class="s2">nx1b = {{1}}</span><span class="se">\\</span><span class="s2">nx2a = {{2}}</span><span class="se">\\</span><span class="s2">nx2b = {{3}}&quot;.format(x1a,x1b, x2a, x2b))</span>
<span class="s2">        #sys.exit(0)</span>

<span class="s2">    xi = np.atleast_1d(xi)</span>
<span class="s2">    xj = np.atleast_1d(xj)</span>

<span class="s2">    x_for_interp = np.zeros(len(x1a)+1)</span>
<span class="s2">    x_for_interp[:-1] = x1a[:]</span>
<span class="s2">    x_for_interp[-1] = x2a[-1]</span>


<span class="s2">    (segment_both,</span>
<span class="s2">     segment_xi_only,</span>
<span class="s2">     segment_xj_only,</span>
<span class="s2">     segments_between) = segments_between_xi_and_xj(x_for_interp, xi, xj)</span>


<span class="s2">    A = np.zeros(len(xi))</span>
<span class="s2">    for i in range(len(xi)):</span>
<span class="s2">        for seg in segment_both[i]:</span>
<span class="s2">            a_slope = (y2a[seg] - y1a[seg]) / (x2a[seg] - x1a[seg])</span>
<span class="s2">            b_slope = (y2b[seg] - y1b[seg]) / (x2b[seg] - x1b[seg])</span>
<span class="s2">            A[i] += (</span><span class="si">{0}</span><span class="s2">)</span>
<span class="s2">        for seg in segment_xi_only[i]:</span>
<span class="s2">            a_slope = (y2a[seg] - y1a[seg]) / (x2a[seg] - x1a[seg])</span>
<span class="s2">            b_slope = (y2b[seg] - y1b[seg]) / (x2b[seg] - x1b[seg])</span>
<span class="s2">            A[i] += (</span><span class="si">{1}</span><span class="s2">)</span>
<span class="s2">        for seg in segments_between[i]:</span>
<span class="s2">            a_slope = (y2a[seg] - y1a[seg]) / (x2a[seg] - x1a[seg])</span>
<span class="s2">            b_slope = (y2b[seg] - y1b[seg]) / (x2b[seg] - x1b[seg])</span>
<span class="s2">            A[i] += (</span><span class="si">{2}</span><span class="s2">)</span>
<span class="s2">        for seg in segment_xj_only[i]:</span>
<span class="s2">            a_slope = (y2a[seg] - y1a[seg]) / (x2a[seg] - x1a[seg])</span>
<span class="s2">            b_slope = (y2b[seg] - y1b[seg]) / (x2b[seg] - x1b[seg])</span>
<span class="s2">            A[i] += (</span><span class="si">{3}</span><span class="s2">)</span>

<span class="s2">    return A</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="n">fn</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tw</span><span class="p">(</span><span class="n">both</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">z1_only</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">between</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">z2_only</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">fn</span></div>

<div class="viewcode-block" id="dim1sin_DD_abDDf_linear_implementations"><a class="viewcode-back" href="../../../api/geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.dim1sin_DD_abDDf_linear_implementations">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_DD_abDDf_linear_implementations</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Code generation for Integration of sin(mi * z) * D[a(z) * b(z) D[sin(mj * z),z,2],z,2]</span>
<span class="sd">    between ztop and zbot where a(z) and b(z) is piecewise linear functions of z.</span>


<span class="sd">    Code is generated that will produce a square array with the</span>
<span class="sd">    appropriate integrals at each location.</span>

<span class="sd">    Paste the resulting code (at least the loops) into `dim1sin_abf_linear`.</span>

<span class="sd">    Creates three implementations:</span>

<span class="sd">     - &#39;scalar&#39;, python loops (slowest).</span>
<span class="sd">     - &#39;vectorized&#39;, numpy (much faster than scalar).</span>
<span class="sd">     - &#39;fortran&#39;, fortran loops (fastest).  Needs to be compiled and interfaced</span>
<span class="sd">       with f2py.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fn : string</span>
<span class="sd">        Python code with scalar (loops) and vectorized (numpy) implementations</span>
<span class="sd">        also calls the fortran version.</span>
<span class="sd">    fn2 : string</span>
<span class="sd">        Fortran code.  Needs to be compiled with f2py.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    geotecha.speccon.integrals.dim1sin_DD_abDDf_linear : Resulting function.</span>
<span class="sd">    geotecha.speccon.integrals.pdim1sin_DD_abDDf_linear : Resulting function with PolyLine</span>
<span class="sd">        inputs.</span>
<span class="sd">    geotecha.speccon.ext_integrals.dim1sin_dd_abDddf_linear : Resulting fortran function.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    the resulting code will produce matrixes of complex values.</span>


<span class="sd">    The `dim1sin_DD_abDDf_linear` matrix, :math:`A` is given by:</span>

<span class="sd">    .. math:: \\mathbf{A}_{i,j}=\\int_{0}^1{\\frac{d^2}{dz^2}\\left({a\\left(z\\right)}{b\\left(z\\right)}\\frac{d^2\\phi_j}{dz^2}\\right)\\phi_i\\,dz}</span>

<span class="sd">    where the basis function :math:`\\phi_i` is given by:</span>

<span class="sd">    .. math:: \\phi_i\\left(z\\right)=\\sin\\left({m_i}z\\right)</span>

<span class="sd">    and :math:`a\\left(z\\right)` and :math:`b\\left(z\\right)` are piecewise</span>
<span class="sd">    linear functions with respect to :math:`z`, that within a layer is defined by:</span>

<span class="sd">    .. math:: a\\left(z\\right) = a_t+\\frac{a_b-a_t}{z_b-z_t}\\left(z-z_t\\right)</span>

<span class="sd">    with :math:`t` and :math:`b` subscripts representing &#39;top&#39; and &#39;bottom&#39; of</span>
<span class="sd">    each layer respectively.</span>

<span class="sd">    To make the above integration simpler we integate by parts to get:</span>

<span class="sd">    .. math:: \\mathbf{A}_{i,j}= \\left.{\\frac{d}{dz}\\left({a\\left(z\\right)}{b\\left(z\\right)}\\frac{d^2\\phi_j}{dz^2}\\right)\\phi_i}\\right|_{z=0}^{z=1}</span>
<span class="sd">                    - \\left.{{a\\left(z\\right)}{b\\left(z\\right)}\\frac{d^2\\phi_j}{dz^2}\\frac{d\\phi_i}{dz}}\\right|_{z=0}^{z=1}</span>
<span class="sd">               +\\int_{0}^1{{a\\left(z\\right)}{b\\left(z\\right)}\\frac{d^2\\phi_j}{dz^2}\\frac{d^2\\phi_i}{dz^2}\\,dz}</span>

<span class="sd">    In this case the sine basis functions means the end point terms in the above</span>
<span class="sd">    equation are zero, leaving us with</span>

<span class="sd">    .. math:: \\mathbf{A}_{i,j}= \\int_{0}^1{{a\\left(z\\right)}{b\\left(z\\right)}\\frac{d^2\\phi_j}{dz^2}\\frac{d^2\\phi_i}{dz^2}\\,dz}</span>


<span class="sd">    &quot;&quot;&quot;</span>

<span class="c1">#    NOTE: remember that fortran does not distinguish between upper and lower</span>
<span class="c1">#        case.  When f2py wraps a fortran function with upper case letters then</span>
<span class="c1">#        upper case letters will be converted to lower case. e.g. Therefore when</span>
<span class="c1">#        calling a fortran function called if fortran fn is</span>
<span class="c1">#        &#39;dim1sin_DD_abDDf_linear&#39; f2py will wrap it as &#39;dim1sin_dd_abddf_linear&#39;</span>



    <span class="n">v</span> <span class="o">=</span> <span class="n">SympyVarsFor1DSpectralDerivation</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
    <span class="n">integ_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

    <span class="n">phi_i</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">mi</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
    <span class="n">phi_j</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">mj</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

    <span class="n">fdiag</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">phi_i</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span>
                            <span class="n">v</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">b</span> <span class="o">*</span>
                            <span class="n">sympy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">phi_i</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
                            <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="o">**</span><span class="n">integ_kwargs</span><span class="p">)</span>
    <span class="n">fdiag_loops</span> <span class="o">=</span> <span class="n">fdiag</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">fdiag</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">fdiag_loops</span> <span class="o">=</span> <span class="n">fdiag_loops</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span>
    <span class="n">fdiag_vector</span> <span class="o">=</span> <span class="n">fdiag</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">fdiag</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">fdiag_vector</span> <span class="o">=</span> <span class="n">fdiag_vector</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_top_to_t_bot_to_b</span><span class="p">)</span>

    <span class="n">foff</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">phi_i</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span>
                           <span class="n">v</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">b</span> <span class="o">*</span>
                           <span class="n">sympy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">phi_j</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
                           <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="o">**</span><span class="n">integ_kwargs</span><span class="p">)</span>
    <span class="n">foff_loops</span> <span class="o">=</span> <span class="n">foff</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">foff</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">foff_loops</span> <span class="o">=</span> <span class="n">foff_loops</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_to_add_index</span><span class="p">)</span>
    <span class="n">foff_vector</span> <span class="o">=</span> <span class="n">foff</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">zbot</span><span class="p">)</span> <span class="o">-</span> <span class="n">foff</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
    <span class="n">foff_vector</span> <span class="o">=</span> <span class="n">foff_vector</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">map_top_to_t_bot_to_b</span><span class="p">)</span>




    <span class="n">text_python</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;def dim1sin_DD_abDDf_linear(m, at, ab, bt, bb,  zt, zb, implementation=&#39;vectorized&#39;):</span>

<span class="s2">    #import numpy as np #import this at module level</span>
<span class="s2">    #import math #import this at module level</span>

<span class="s2">    m = np.asarray(m)</span>
<span class="s2">    at = np.asarray(at)</span>
<span class="s2">    ab = np.asarray(ab)</span>
<span class="s2">    bt = np.asarray(bt)</span>
<span class="s2">    bb = np.asarray(bb)</span>
<span class="s2">    zt = np.asarray(zt)</span>
<span class="s2">    zb = np.asarray(zb)</span>

<span class="s2">    neig = len(m)</span>

<span class="s2">    if implementation == &#39;scalar&#39;:</span>
<span class="s2">        sin = math.sin</span>
<span class="s2">        cos = math.cos</span>
<span class="s2">        A = np.zeros([neig, neig], float)</span>
<span class="s2">        nlayers = len(zt)</span>
<span class="s2">        for layer in range(nlayers):</span>
<span class="s2">            a_slope = (ab[layer] - at[layer]) / (zb[layer] - zt[layer])</span>
<span class="s2">            b_slope = (bb[layer] - bt[layer]) / (zb[layer] - zt[layer])</span>
<span class="s2">            for i in range(neig):</span>
<span class="s2">                A[i, i] += (</span><span class="si">{0}</span><span class="s2">)</span>
<span class="s2">            for i in range(neig-1):</span>
<span class="s2">                for j in range(i + 1, neig):</span>
<span class="s2">                    A[i, j] += (</span><span class="si">{1}</span><span class="s2">)</span>

<span class="s2">        #A is symmetric</span>
<span class="s2">        for i in range(neig - 1):</span>
<span class="s2">            for j in range(i + 1, neig):</span>
<span class="s2">                A[j, i] = A[i, j]</span>

<span class="s2">    elif implementation == &#39;fortran&#39;:</span>
<span class="s2">        if MUST_TRY_FORTRAN:</span>
<span class="s2">            import geotecha.speccon.ext_integrals as ext_integ</span>
<span class="s2">            A = ext_integ.dim1sin_dd_abddf_linear(m, at, ab, bt, bb, zt, zb)</span>
<span class="s2">        else:</span>
<span class="s2">            try:</span>
<span class="s2">                import geotecha.speccon.ext_integrals as ext_integ</span>
<span class="s2">                A = ext_integ.dim1sin_dd_abddf_linear(m, at, ab, bt, bb, zt, zb)</span>
<span class="s2">            except ImportError:</span>
<span class="s2">                A = dim1sin_DD_abDDf_linear(m, at, ab, bt, bb, zt, zb, implementation=&#39;vectorized&#39;)</span>

<span class="s2">    else:#default is &#39;vectorized&#39; using numpy</span>
<span class="s2">        sin = np.sin</span>
<span class="s2">        cos = np.cos</span>
<span class="s2">        A = np.zeros([neig, neig], float)</span>

<span class="s2">        diag =  np.diag_indices(neig)</span>
<span class="s2">        triu = np.triu_indices(neig, k = 1)</span>
<span class="s2">        tril = (triu[1], triu[0])</span>

<span class="s2">        a_slope = (ab - at) / (zb - zt)</span>
<span class="s2">        b_slope = (bb - bt) / (zb - zt)</span>

<span class="s2">        mi = m[:, np.newaxis]</span>
<span class="s2">        A[diag] = np.sum(</span><span class="si">{2}</span><span class="s2">, axis=1)</span>

<span class="s2">        mi = m[triu[0]][:, np.newaxis]</span>
<span class="s2">        mj = m[triu[1]][:, np.newaxis]</span>
<span class="s2">        A[triu] = np.sum(</span><span class="si">{3}</span><span class="s2">, axis=1)</span>
<span class="s2">        #A is symmetric</span>
<span class="s2">        A[tril] = A[triu]</span>

<span class="s2">    return A&quot;&quot;&quot;</span>


<span class="c1">#    note the the i=j part in the fortran loop  below is because</span>
<span class="c1">#      I changed the loop order from layer, i,j to layer, j,i which is</span>
<span class="c1">#      i think faster as first index of a fortran array loops faster</span>
<span class="c1">#      my sympy code is mased on m[i], hence the need for i=j.</span>
    <span class="n">text_fortran</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">      SUBROUTINE dim1sin_dd_abddf_linear(m, at, ab, bt, bb, zt, zb, a, &amp;</span>
<span class="s2">                                    neig, nlayers)</span>
<span class="s2">        USE types</span>
<span class="s2">        IMPLICIT NONE</span>

<span class="s2">        INTEGER, intent(in) :: neig</span>
<span class="s2">        INTEGER, intent(in) :: nlayers</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:neig-1) ::m</span>
<span class="s2">        REAL(DP), intent(in), dimension(0:nlayers-1) :: at,ab,bt,bb,zt,zb</span>
<span class="s2">        REAL(DP), intent(out), dimension(0:neig-1, 0:neig-1) :: a</span>
<span class="s2">        INTEGER :: i , j, layer</span>
<span class="s2">        REAL(DP) :: a_slope, b_slope</span>


<span class="s2">        a=0.0D0</span>
<span class="s2">        DO layer = 0, nlayers-1</span>
<span class="s2">          a_slope = (ab(layer) - at(layer)) / (zb(layer) - zt(layer))</span>
<span class="s2">          b_slope = (bb(layer) - bt(layer)) / (zb(layer) - zt(layer))</span>
<span class="s2">          DO j = 0, neig-1</span>
<span class="s2">              i=j</span>
<span class="si">{0}</span><span class="s2"></span>
<span class="s2">            DO i = j+1, neig-1</span>
<span class="si">{1}</span><span class="s2"></span>
<span class="s2">            END DO</span>
<span class="s2">          END DO</span>
<span class="s2">        END DO</span>

<span class="s2">        DO j = 0, neig -2</span>
<span class="s2">          DO i = j + 1, neig-1</span>
<span class="s2">            a(j,i) = a(i, j)</span>
<span class="s2">          END DO</span>
<span class="s2">        END DO</span>

<span class="s2">      END SUBROUTINE&quot;&quot;&quot;</span>





    <span class="n">fn</span> <span class="o">=</span> <span class="n">text_python</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tw</span><span class="p">(</span><span class="n">fdiag_loops</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">foff_loops</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">fdiag_vector</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">tw</span><span class="p">(</span><span class="n">foff_vector</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">fn2</span> <span class="o">=</span> <span class="n">text_fortran</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">fdiag_loops</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, i) = a(i, i) + &#39;</span><span class="p">),</span>
                 <span class="n">fcode_one_large_expr</span><span class="p">(</span><span class="n">foff_loops</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="s1">&#39;a(i, j) = a(i, j) + &#39;</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fn2</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">pass</span>
    <span class="kn">import</span> <span class="nn">nose</span>
<span class="c1">#    nose.runmodule(argv=[&#39;nose&#39;, &#39;--verbosity=3&#39;, &#39;--with-doctest&#39;])</span>
<span class="c1">#    nose.runmodule(argv=[&#39;nose&#39;, &#39;--verbosity=3&#39;])</span>

<span class="c1">#    fn, fn2=Eload_linear_implementations();print(fn);print(&#39;#&#39;*40); print(fn2)</span>
<span class="c1">#    fn, fn2=EDload_linear_implementations();print(fn);print(&#39;#&#39;*40); print(fn2)</span>
<span class="c1">#    fn, fn2=Eload_coslinear_implementations();print(fn);print(&#39;#&#39;*40); print(fn2)</span>
<span class="c1">#    fn, fn2=EDload_coslinear_implementations();print(fn);print(&#39;#&#39;*40); print(fn2)</span>
<span class="c1">#    fn, fn2=dim1sin_af_linear_implementations();print(fn);print(&#39;#&#39;*40); print(fn2)</span>
<span class="c1">#    fn, fn2=dim1sin_abf_linear_implementations();print(fn);print(&#39;#&#39;*40); print(fn2)</span>
<span class="c1">#    fn, fn2=dim1sin_D_aDf_linear_implementations();print(fn);print(&#39;#&#39;*40); print(fn2)</span>
<span class="c1">#    fn, fn2=dim1sin_ab_linear_implementations();print(fn);print(&#39;#&#39;*40); print(fn2)</span>
<span class="c1">#    fn, fn2=dim1sin_abc_linear_implementations();print(fn);print(&#39;#&#39;*40); print(fn2)</span>
<span class="c1">#    fn, fn2=dim1sin_D_aDb_linear_implementations();print(fn);print(&#39;#&#39;*40); print(fn2)</span>
<span class="c1">#    fn, fn2=dim1sin_DD_abDDf_linear_implementations();print(fn);print(&#39;#&#39;*40); print(fn2)</span>
    <span class="n">fn</span><span class="p">,</span> <span class="n">fn2</span><span class="o">=</span><span class="n">Eload_sinlinear_implementations</span><span class="p">();</span><span class="nb">print</span><span class="p">(</span><span class="n">fn</span><span class="p">);</span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="o">*</span><span class="mi">40</span><span class="p">);</span> <span class="nb">print</span><span class="p">(</span><span class="n">fn2</span><span class="p">)</span>
<span class="c1">#    print(dim1sin_a_linear_between())</span>
<span class="c1">#    print(dim1_ab_linear_between())</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;C:</span><span class="se">\\</span><span class="s2">temp</span><span class="se">\\</span><span class="s2">temp_py.txt&quot;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;C:</span><span class="se">\\</span><span class="s2">temp</span><span class="se">\\</span><span class="s2">temp_for.txt&quot;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">fn2</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2014, Rohan Walker.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>