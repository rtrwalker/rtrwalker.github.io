
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>geotecha.speccon.speccon1d &#8212; geotecha 0.2.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../../index.html"><img src="../../../_static/logo.png" border="0" alt="py4sci"/></a>
</div>



      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for geotecha.speccon.speccon1d</h1><div class="highlight"><pre>
<span></span><span class="c1"># geotecha - A software suite for geotechncial engineering</span>
<span class="c1"># Copyright (C) 2018  Rohan T. Walker (rtrwalker@gmail.com)</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see http://www.gnu.org/licenses/gpl.html.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module has functions classes and common functionality for one dimensinal</span>
<span class="sd">Spectral Galerkin methods.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">import</span> <span class="nn">geotecha.inputoutput.inputoutput</span> <span class="k">as</span> <span class="nn">inputoutput</span>
<span class="kn">import</span> <span class="nn">geotecha.piecewise.piecewise_linear_1d</span> <span class="k">as</span> <span class="nn">pwise</span>
<span class="kn">from</span> <span class="nn">geotecha.piecewise.piecewise_linear_1d</span> <span class="k">import</span> <span class="n">PolyLine</span>
<span class="kn">import</span> <span class="nn">geotecha.speccon.integrals</span> <span class="k">as</span> <span class="nn">integ</span>



<div class="viewcode-block" id="Speccon1d"><a class="viewcode-back" href="../../../api/geotecha.speccon.speccon1d.html#geotecha.speccon.speccon1d.Speccon1d">[docs]</a><span class="k">class</span> <span class="nc">Speccon1d</span><span class="p">(</span><span class="n">inputoutput</span><span class="o">.</span><span class="n">InputFileLoaderCheckerSaver</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve 1D parabolic partial differential equation using spectral method.</span>

<span class="sd">    Basically a base class to provide a broad template for one dimensional</span>
<span class="sd">    spectral method consolidation problems.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    geotecha.inputoutput.InputFileLoaderCheckerSaver : Details on how to</span>
<span class="sd">        initialize the object and attribute checks.</span>


<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Speccon1d.make_all"><a class="viewcode-back" href="../../../api/geotecha.speccon.speccon1d.html#geotecha.speccon.speccon1d.Speccon1d.make_all">[docs]</a>    <span class="k">def</span> <span class="nf">make_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run checks, make all arrays, make output</span>

<span class="sd">        Generally run this after attributes have been entered</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        check_input_attributes</span>
<span class="sd">        make_time_independent_arrays</span>
<span class="sd">        make_time_dependent_arrays</span>
<span class="sd">        make_output</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_input_attributes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">make_time_independent_arrays</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">make_time_dependent_arrays</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">make_output</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;save_data_to_file&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_data</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;save_figures_to_file&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;show_figures&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">produce_plots</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;save_figures_to_file&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_save_figures</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;show_figures&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="Speccon1d.make_time_independent_arrays"><a class="viewcode-back" href="../../../api/geotecha.speccon.speccon1d.html#geotecha.speccon.speccon1d.Speccon1d.make_time_independent_arrays">[docs]</a>    <span class="k">def</span> <span class="nf">make_time_independent_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make all time-independent arrays; To be overridden in subclasses.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;make_time_independent_arrays&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Speccon1d.make_time_dependent_arrays"><a class="viewcode-back" href="../../../api/geotecha.speccon.speccon1d.html#geotecha.speccon.speccon1d.Speccon1d.make_time_dependent_arrays">[docs]</a>    <span class="k">def</span> <span class="nf">make_time_dependent_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make all time-independent arrays; To be overridden in subclasses.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;make_time_dependent_arrays&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Speccon1d.make_output"><a class="viewcode-back" href="../../../api/geotecha.speccon.speccon1d.html#geotecha.speccon.speccon1d.Speccon1d.make_output">[docs]</a>    <span class="k">def</span> <span class="nf">make_output</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make all output i.e. data tables; To be overridden in subclasses.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;make_output&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="dim1sin_f"><a class="viewcode-back" href="../../../api/geotecha.speccon.speccon1d.html#geotecha.speccon.speccon1d.dim1sin_f">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_f</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
              <span class="n">outz</span><span class="p">,</span>
              <span class="n">tvals</span><span class="p">,</span>
              <span class="n">v_E_Igamv_the</span><span class="p">,</span>
              <span class="n">drn</span><span class="p">,</span>
              <span class="n">top_vs_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">bot_vs_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">top_omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">bot_omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Assemble output u(Z,t) = phi * v_E_Igam_v_the + utop(t) * (1-Z) + ubot(t)*Z.</span>

<span class="sd">    Basically calculates the phi part for each outz value, then dot product</span>
<span class="sd">    with v_E_Igamv_the (which has elsewhere been calculated at each tvals</span>
<span class="sd">    value).  Then account for non-zero boundary conditions by</span>
<span class="sd">    adding utop(t)*(1-Z) and ubot(t)*Z parts for each outz, tvals pair.</span>

<span class="sd">    Use sin(m*Z) for the phi part.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : ``list`` of ``float``</span>
<span class="sd">        Eigenvalues of BVP, the m in sin(m*Z). Generate with</span>
<span class="sd">        geotecha.speccon.m_from_sin_mx.</span>
<span class="sd">    outz : 1d numpy.ndarray</span>
<span class="sd">        Depths to evaluate at.</span>
<span class="sd">    tvals : 1d numpy.ndarray</span>
<span class="sd">        Time values to evaluate at</span>
<span class="sd">    eigs : 1d numpy.ndarray</span>
<span class="sd">        List of eigenvalues of the spectral matrix i.e. Eigenvalues of the</span>
<span class="sd">        square Igam_psi matrix.</span>
<span class="sd">    tvals : 1d numpy.ndarray`</span>
<span class="sd">        List of time values to evaluate E matrix at.</span>
<span class="sd">    v_E_Igamv_the : ndarray of size (neig, len(tvals))</span>
<span class="sd">        Speccon matrix.</span>
<span class="sd">    drn : [0,1]</span>
<span class="sd">        Drainage condition,</span>
<span class="sd">        drn=0 for Pervious top pervious bottom (PTPB).</span>
<span class="sd">        drn=1 for Pervious top impoervious bottom (PTIB).</span>
<span class="sd">    top_vs_time, bot_vs_time : list of PolyLine</span>
<span class="sd">        Piecewise linear magnitude vs time for the top and bottom boundary.</span>
<span class="sd">        Use ``None`` if there is no variation.</span>
<span class="sd">    top_omega_phase, bot_omega_phase : list of 2 element tuples, optional</span>
<span class="sd">        (omega, phase) for use in cos(omega * t + phase) * mag_vs_time</span>
<span class="sd">        if omega_phase is None then mag_vs_time will not be multiplied by a</span>
<span class="sd">        cosine.  If any element of omega_phase is None then in that particular</span>
<span class="sd">        loading combo, mag_vs_time will not be multiplied by a cosine.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    u : np.ndarray</span>
<span class="sd">        Pore pressure at depth and time. Array of size (len(outz), len(tvals)).</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The :math:`\\phi` term is simply: :math:`\\sin\\left({m Z}\\right)`</span>
<span class="sd">    evaluated at each required depth.</span>



<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">phi</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">dim1sin</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">outz</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">v_E_Igamv_the</span><span class="p">)</span>
    <span class="c1">#top part</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">top_vs_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">top_omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">top_omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">top_vs_time</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">mag_vs_time</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">top_vs_time</span><span class="p">,</span> <span class="n">top_omega_phase</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
                <span class="n">mult</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span> <span class="o">*</span> <span class="n">tvals</span> <span class="o">+</span> <span class="n">phase</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mult</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">drn</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">u</span> <span class="o">+=</span> <span class="n">pwise</span><span class="o">.</span><span class="n">pinterp_x_y</span><span class="p">(</span><span class="n">mag_vs_time</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">choose_max</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">mult</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">u</span> <span class="o">+=</span> <span class="n">pwise</span><span class="o">.</span><span class="n">pinterp_xa_ya_multipy_x1b_x2b_y1b_y2b</span><span class="p">(</span><span class="n">mag_vs_time</span><span class="p">,</span> <span class="n">PolyLine</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">outz</span><span class="p">,</span> <span class="n">achoose_max</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">mult</span>
    <span class="c1">#bot part</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">bot_vs_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bot_omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bot_omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bot_vs_time</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">mag_vs_time</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bot_vs_time</span><span class="p">,</span> <span class="n">bot_omega_phase</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
                <span class="n">mult</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span> <span class="o">*</span> <span class="n">tvals</span> <span class="o">+</span> <span class="n">phase</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mult</span><span class="o">=</span><span class="mi">1</span>
            <span class="n">u</span> <span class="o">+=</span> <span class="n">pwise</span><span class="o">.</span><span class="n">pinterp_xa_ya_multipy_x1b_x2b_y1b_y2b</span><span class="p">(</span><span class="n">mag_vs_time</span><span class="p">,</span> <span class="n">PolyLine</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">outz</span><span class="p">,</span> <span class="n">achoose_max</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">mult</span>
    <span class="k">return</span> <span class="n">u</span></div>


<div class="viewcode-block" id="dim1sin_avgf"><a class="viewcode-back" href="../../../api/geotecha.speccon.speccon1d.html#geotecha.speccon.speccon1d.dim1sin_avgf">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_avgf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
                 <span class="n">z</span><span class="p">,</span>
                 <span class="n">tvals</span><span class="p">,</span>
                 <span class="n">v_E_Igamv_the</span><span class="p">,</span>
                 <span class="n">drn</span><span class="p">,</span>
                 <span class="n">top_vs_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">bot_vs_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">top_omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">bot_omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Average u(Z,t) between Z1 and Z2 where</span>
<span class="sd">    u(Z,t) = phi * v_E_Igam_v_the + utop(t) * (1-Z) + ubot(t)*Z.</span>

<span class="sd">    Basically calculates the average phi part for each z pair value, then dot product</span>
<span class="sd">    with v_E_Igamv_the (which has elsewhere been calculated at each tvals</span>
<span class="sd">    value).  Then account for non-zero boundary conditions by</span>
<span class="sd">    adding average of utop(t)*(1-Z) and ubot(t)*Z parts for each z, tvals pair.</span>

<span class="sd">    Use sin(m*Z) for the phi part.</span>


<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    ----------</span>
<span class="sd">    m : ``list`` of ``float``</span>
<span class="sd">        Eigenvalues of BVP, the m in sin(m*Z). Generate with</span>
<span class="sd">        geotecha.speccon.m_from_sin_mx.</span>
<span class="sd">    z : size (n, 2) 2d numpy.ndarray</span>
<span class="sd">        Depths to evaluate average between.</span>
<span class="sd">    tvals : 1d numpy.ndarray</span>
<span class="sd">        Time values to evaluate at.</span>
<span class="sd">    eigs : 1d numpy.ndarray</span>
<span class="sd">        List of eigenvalues of the spectral matrix i.e. Eigenvalues of the</span>
<span class="sd">        square Igam_psi matrix.</span>
<span class="sd">    tvals : 1d numpy.ndarray`</span>
<span class="sd">        List of time values to evaluate E matrix at.</span>
<span class="sd">    v_E_Igamv_the : ndarray of size (neig, len(tvals))</span>
<span class="sd">        Speccon matrix.</span>
<span class="sd">    drn : [0,1]</span>
<span class="sd">        Drainage condition,</span>
<span class="sd">        drn=0 for Pervious top pervious bottom (PTPB).</span>
<span class="sd">        drn=1 for Pervious top impoervious bottom (PTIB).</span>
<span class="sd">    top_vs_time, bot_vs_time : list of PolyLine</span>
<span class="sd">        Piecewise linear magnitude vs time for the top and bottom boundary.</span>
<span class="sd">        Use ``None`` if there is no variation.</span>
<span class="sd">    top_omega_phase, bot_omega_phase : list of 2 element tuples, optional</span>
<span class="sd">        (omega, phase) for use in cos(omega * t + phase) * mag_vs_time</span>
<span class="sd">        if omega_phase is None then mag_vs_time will not be multiplied by a</span>
<span class="sd">        cosine.  If any element of omega_phase is None then in that particular</span>
<span class="sd">        loading combo, mag_vs_time will not be multiplied by a cosine.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    uavg : np.ndarray</span>
<span class="sd">        Average pore pressure between depths at each time.</span>
<span class="sd">        Array of size (len(z), len(tvals)).</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The average of the :math:`\\phi` term is:</span>

<span class="sd">    .. math:: \\mathbf{\\phi}_{i\\textrm{average}}=</span>
<span class="sd">                \\frac{1}{Z_2-Z_1}</span>
<span class="sd">                \\int_{z_1}^{z_2}{\\sin\\left({m_i Z}\\right)\\,dZ}</span>



<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">phi</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">dim1sin_avg_between</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>


    <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">v_E_Igamv_the</span><span class="p">)</span>

    <span class="n">z1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">z</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">z2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">z</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1">#top part</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">top_vs_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">top_omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">top_omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">top_vs_time</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">mag_vs_time</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">top_vs_time</span><span class="p">,</span> <span class="n">top_omega_phase</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
                <span class="n">mult</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span> <span class="o">*</span> <span class="n">tvals</span> <span class="o">+</span> <span class="n">phase</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mult</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">drn</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1">#bottom part</span>
                <span class="n">avg</span> <span class="o">+=</span> <span class="n">pwise</span><span class="o">.</span><span class="n">pinterp_x_y</span><span class="p">(</span><span class="n">mag_vs_time</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">choose_max</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">*</span><span class="n">mult</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">avg</span> <span class="o">+=</span> <span class="n">pwise</span><span class="o">.</span><span class="n">pxa_ya_multipy_avg_x1b_x2b_y1b_y2b_between</span><span class="p">(</span><span class="n">mag_vs_time</span><span class="p">,</span>
                                                                        <span class="n">PolyLine</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                                                        <span class="n">tvals</span><span class="p">,</span> <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">,</span> <span class="n">achoose_max</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">*</span><span class="n">mult</span>
    <span class="c1">#bottom part</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">bot_vs_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bot_omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bot_omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bot_vs_time</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">mag_vs_time</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bot_vs_time</span><span class="p">,</span> <span class="n">bot_omega_phase</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
                <span class="n">mult</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span> <span class="o">*</span> <span class="n">tvals</span> <span class="o">+</span> <span class="n">phase</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mult</span><span class="o">=</span><span class="mi">1</span>
            <span class="n">avg</span> <span class="o">+=</span> <span class="n">pwise</span><span class="o">.</span><span class="n">pxa_ya_multipy_avg_x1b_x2b_y1b_y2b_between</span><span class="p">(</span><span class="n">mag_vs_time</span><span class="p">,</span>
                                                                        <span class="n">PolyLine</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                                                        <span class="n">tvals</span><span class="p">,</span> <span class="n">z1</span><span class="p">,</span><span class="n">z2</span><span class="p">,</span> <span class="n">achoose_max</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">mult</span>

    <span class="k">return</span> <span class="n">avg</span></div>


<div class="viewcode-block" id="dim1sin_integrate_af"><a class="viewcode-back" href="../../../api/geotecha.speccon.speccon1d.html#geotecha.speccon.speccon1d.dim1sin_integrate_af">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_integrate_af</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
                         <span class="n">z</span><span class="p">,</span>
                         <span class="n">tvals</span><span class="p">,</span>
                         <span class="n">v_E_Igamv_the</span><span class="p">,</span>
                         <span class="n">drn</span><span class="p">,</span>
                         <span class="n">a</span><span class="p">,</span>
                         <span class="n">top_vs_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">bot_vs_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">top_omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">bot_omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Integrate u(Z,t) between Z1 and Z2 where</span>
<span class="sd">    u(Z,t) = phi * v_E_Igam_v_the + utop(t) * (1-Z) + ubot(t)*Z.</span>

<span class="sd">    Basically calculates the integral phi part for each z pair value, then dot product</span>
<span class="sd">    with v_E_Igamv_the (which has elsewhere been calculated at each tvals</span>
<span class="sd">    value).  Then account for non-zero boundary conditions by</span>
<span class="sd">    adding average of utop(t)*(1-Z) and ubot(t)*Z parts for each z, tvals pair.</span>

<span class="sd">    Use sin(m*Z) for the phi part.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : ``list`` of ``float``</span>
<span class="sd">        Eigenvalues of BVP, the m in sin(m*Z). Generate with</span>
<span class="sd">        geotecha.speccon.m_from_sin_mx.</span>
<span class="sd">    z : size (n, 2) 2d numpy.ndarray</span>
<span class="sd">        Depths to evaluate integral between.</span>
<span class="sd">    tvals : 1d numpy.ndarray</span>
<span class="sd">        Time values to evaluate at.</span>
<span class="sd">    eigs : 1d numpy.ndarray</span>
<span class="sd">        List of eigenvalues of the spectral matrix i.e. Eigenvalues of the</span>
<span class="sd">        square Igam_psi matrix.</span>
<span class="sd">    tvals : 1d numpy.ndarray`</span>
<span class="sd">        List of time values to evaluate E matrix at.</span>
<span class="sd">    v_E_Igamv_the : ndarray of size (neig, len(tvals))</span>
<span class="sd">        Speccon matrix.</span>
<span class="sd">    drn : [0,1]</span>
<span class="sd">        Drainage condition,</span>
<span class="sd">        drn=0 for Pervious top pervious bottom (PTPB).</span>
<span class="sd">        drn=1 for Pervious top impoervious bottom (PTIB).</span>
<span class="sd">    top_vs_time, bot_vs_time : list of PolyLine</span>
<span class="sd">        Piecewise linear magnitude vs time for the top and bottom boundary.</span>
<span class="sd">        Use ``None`` if there is no variation.</span>
<span class="sd">    top_omega_phase, bot_omega_phase : list of 2 element tuples, optional</span>
<span class="sd">        (omega, phase) for use in cos(omega * t + phase) * mag_vs_time</span>
<span class="sd">        if omega_phase is None then mag_vs_time will not be multiplied by a</span>
<span class="sd">        cosine.  If any element of omega_phase is None then in that particular</span>
<span class="sd">        loading combo, mag_vs_time will not be multiplied by a cosine.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    uintegral : np.ndarray</span>
<span class="sd">        Integral of pore pressure between depths at each time.</span>
<span class="sd">        Array of size (len(z), len(tvals)).</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The integral of the :math:`\\phi` term is:</span>

<span class="sd">    .. math:: \\mathbf{\\phi}_{i\\textrm{integral}}=</span>
<span class="sd">                \\int_{z_1}^{z_2}{\\sin\\left({m_i Z}\\right)\\,dZ}</span>




<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">z1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">z2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1">#a*u part</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pdim1sin_a_linear_between</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">v_E_Igamv_the</span><span class="p">)</span>

    <span class="c1">#top part</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">top_vs_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">top_omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">top_omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">top_vs_time</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">mag_vs_time</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">top_vs_time</span><span class="p">,</span> <span class="n">top_omega_phase</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
                <span class="n">mult</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span> <span class="o">*</span> <span class="n">tvals</span> <span class="o">+</span> <span class="n">phase</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mult</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">drn</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="n">mult</span> <span class="o">*</span> <span class="n">pwise</span><span class="o">.</span><span class="n">pxa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between</span><span class="p">(</span>
                    <span class="n">mag_vs_time</span><span class="p">,</span>
                    <span class="n">a</span><span class="p">,</span>
                    <span class="n">PolyLine</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">)),</span>
                    <span class="n">tvals</span><span class="p">,</span> <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">,</span> <span class="n">achoose_max</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="n">mult</span> <span class="o">*</span> <span class="n">pwise</span><span class="o">.</span><span class="n">pxa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between</span><span class="p">(</span>
                    <span class="n">mag_vs_time</span><span class="p">,</span>
                    <span class="n">a</span><span class="p">,</span>
                    <span class="n">PolyLine</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">),</span>
                    <span class="n">tvals</span><span class="p">,</span> <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">,</span> <span class="n">achoose_max</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


    <span class="c1">#bot part</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">bot_vs_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bot_omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bot_omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bot_vs_time</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">mag_vs_time</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bot_vs_time</span><span class="p">,</span> <span class="n">bot_omega_phase</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
                <span class="n">mult</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span> <span class="o">*</span> <span class="n">tvals</span> <span class="o">+</span> <span class="n">phase</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mult</span><span class="o">=</span><span class="mi">1</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="n">mult</span> <span class="o">*</span> <span class="n">pwise</span><span class="o">.</span><span class="n">pxa_ya_multiply_integrate_x1b_x2b_y1b_y2b_multiply_x1c_x2c_y1c_y2c_between</span><span class="p">(</span>
                    <span class="n">mag_vs_time</span><span class="p">,</span>
                    <span class="n">a</span><span class="p">,</span>
                    <span class="n">PolyLine</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">),</span>
                    <span class="n">tvals</span><span class="p">,</span> <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">,</span> <span class="n">achoose_max</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1">#self.set *= self.H * self.mvref</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="dim1sin_E_Igamv_the_BC_aDfDt_linear"><a class="viewcode-back" href="../../../api/geotecha.speccon.speccon1d.html#geotecha.speccon.speccon1d.dim1sin_E_Igamv_the_BC_aDfDt_linear">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_E_Igamv_the_BC_aDfDt_linear</span><span class="p">(</span><span class="n">drn</span><span class="p">,</span>
                                        <span class="n">m</span><span class="p">,</span>
                                        <span class="n">eigs</span><span class="p">,</span>
                                        <span class="n">tvals</span><span class="p">,</span>
                                        <span class="n">Igamv</span><span class="p">,</span>
                                        <span class="n">a</span><span class="p">,</span>
                                        <span class="n">top_vs_time</span><span class="p">,</span>
                                        <span class="n">bot_vs_time</span><span class="p">,</span>
                                        <span class="n">top_omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">bot_omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">dT</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                        <span class="n">theta_zero_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">implementation</span><span class="o">=</span><span class="s1">&#39;vectorized&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate E and theta parts and assemble E_Igamv_the matrix that arises</span>
<span class="sd">    from homogenising a(Z)*D[u(Z, t), t] for non_zero top and bottom boundary</span>
<span class="sd">    conditions.</span>

<span class="sd">    When accounting for non-zero boundary conditions we homogenise the</span>
<span class="sd">    governing equation by letting u(Z,t) = v(Z,t) + utop(t)*(1-Z) + ubot(t)*Z</span>
<span class="sd">    and solving for v(Z, t).  This function calculates the time dependent</span>
<span class="sd">    E part, the depth dependent theta part, and then assembles</span>
<span class="sd">    E*inverse(gam*v)*theta which forms part of solution</span>
<span class="sd">    v(Z,t)=phi*v*E*inverse(gam*v)*theta.  The E and theta parts arise</span>
<span class="sd">    by subbing the boundary conditions into into governing equation terms of</span>
<span class="sd">    the form a(z)*D[u(Z,t), t].</span>

<span class="sd">    The contribution of each `mag_vs_time`-`omega_phase` pairing</span>
<span class="sd">    are superposed.    The result is an array</span>
<span class="sd">    of size (neig, len(tvals)). So each column is the are the column vector</span>
<span class="sd">    E*inverse(gam*v)*theta calculated at each output time.  This will allow</span>
<span class="sd">    us later to do v(Z,t) = phi*v*E_Igamv_the.</span>

<span class="sd">    Uses sin(m*z) in the calculation of theta.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    drn : [0,1]</span>
<span class="sd">        Drainage condition,</span>
<span class="sd">        drn=0 for Pervious top pervious bottom (PTPB).</span>
<span class="sd">        drn=1 for Pervious top impoervious bottom (PTIB).</span>
<span class="sd">    m : ``list`` of ``float``</span>
<span class="sd">        Eigenvalues of BVP, the m in sin(m*Z). Generate with</span>
<span class="sd">        geotecha.speccon.m_from_sin_mx.</span>
<span class="sd">    eigs : 1d numpy.ndarray</span>
<span class="sd">        List of eigenvalues of the spectral matrix i.e. Eigenvalues of the</span>
<span class="sd">        square Igam_psi matrix.</span>
<span class="sd">    tvals : 1d numpy.ndarray`</span>
<span class="sd">        List of time values to evaluate E matrix at.</span>
<span class="sd">    Igamv : ndarray</span>
<span class="sd">        Speccon matrix.  Igamv = inverse of [gam * v])</span>
<span class="sd">    a : PolyLine</span>
<span class="sd">        Piewcewise linear function.  e.g. for 1d consolidation surcharge</span>
<span class="sd">        loading term is mv*D[sigma(z, t), t] so `a` would be mv.</span>
<span class="sd">    top_vs_time, bot_vs_time : list of PolyLine</span>
<span class="sd">        Piecewise linear magnitude vs time for the top and bottom boundary.</span>
<span class="sd">        Use ``None`` if there is no variation.</span>
<span class="sd">    top_omega_phase, bot_omega_phase : list of 2 element tuples, optional</span>
<span class="sd">        (omega, phase) for use in cos(omega * t + phase) * mag_vs_time</span>
<span class="sd">        if omega_phase is None then mag_vs_time will not be multiplied by a</span>
<span class="sd">        cosine.  If any element of omega_phase is None then in that particular</span>
<span class="sd">        loading combo, mag_vs_time will not be multiplied by a cosine.</span>
<span class="sd">    dT : ``float``, optional</span>
<span class="sd">        Time factor multiple for numerical convieniece. Default dT=1.0.</span>
<span class="sd">    theta_zero_indexes : slice/list etc., optional</span>
<span class="sd">        A slice object, list, etc that can be used for numpy fancy indexing.</span>
<span class="sd">        Any specified index of the theta vector will be set to zero.  This is</span>
<span class="sd">        useful when using the spectral method with block matrices and the</span>
<span class="sd">        loading term only refers to a subset of the equations.  When using</span>
<span class="sd">        block matrices m should be the same size as the block matrix.</span>
<span class="sd">        Default theta_zero_indexes=None i.e. no elements of theta will be</span>
<span class="sd">        set to zero.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    E_Igamv_the : ndarray</span>
<span class="sd">        Loading matrix of size (neig, len(tvals)).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Assuming the loads are formulated as the product of separate time and depth</span>
<span class="sd">    dependant functions as well as a cyclic component:</span>

<span class="sd">    .. math:: \\sigma\\left({Z,t}\\right)=</span>
<span class="sd">                \\sigma\\left({Z}\\right)</span>
<span class="sd">                \\sigma\\left({t}\\right)</span>
<span class="sd">                \\cos\\left(\\omega t + \\phi\\right)</span>

<span class="sd">    the solution to the consolidation equation using the spectral method has</span>
<span class="sd">    the form:</span>

<span class="sd">    .. math:: u\\left(Z,t\\right)=</span>
<span class="sd">                \\mathbf{\\phi v E}</span>
<span class="sd">                \\left(\\mathbf{\\Gamma v}\\right)^{-1}</span>
<span class="sd">                \\mathbf{\\theta}</span>


<span class="sd">    When we consider non-zero boundary conditions, additional loading terms are</span>
<span class="sd">    created when we sub in the following into the original governing equation.</span>

<span class="sd">    .. math:: u\\left({Z,t}\\right)=</span>
<span class="sd">                v\\left({Z,t}\\right) +</span>
<span class="sd">                u_{top}\\left({t}\\right)\\left({1-Z}\\right) +</span>
<span class="sd">                u_{bot}\\left({b}\\right)Z</span>

<span class="sd">    Two additional loading terms are created with each substitution, one</span>
<span class="sd">    for the top boundary condition and one for the bottom boundary condition.</span>

<span class="sd">    This function calculates :math:`\\mathbf{E}\\left(\\mathbf{\\Gamma v}\\right)^{-1}\\mathbf{\\theta}`</span>
<span class="sd">    when substitutions are made in terms of the following form:</span>


<span class="sd">    .. math:: a\\left({Z}\\right)\\frac{\\partial u}{\\partial t}</span>

<span class="sd">    It is assumed that :math:`u_{top}\\left({t}\\right)` and</span>
<span class="sd">    :math:`u_{bot}\\left({t}\\right)` are piecewise linear</span>
<span class="sd">    in time with a cyclic component, and that multiple functions are</span>
<span class="sd">    superposed.  Also :math:`a\\left(Z\\right)`</span>
<span class="sd">    is a piecewise linear function w.r.t. :math:`Z`</span>


<span class="sd">    For this particular function the :math:`\\mathbf{\\theta}` vector for</span>
<span class="sd">    each load is given by:</span>

<span class="sd">    .. math:: \\mathbf{\\theta}_{i}=</span>
<span class="sd">                \\int_{0}^1{</span>
<span class="sd">                  {a\\left(Z\\right)}</span>
<span class="sd">                  {\\sigma\\left(Z\\right)}</span>
<span class="sd">                  f\\left({Z}\\right)</span>
<span class="sd">                  \\phi_i\\,dZ}</span>

<span class="sd">    Where :math:`f\\left({Z}\\right)` is the appropriate z-dependent term</span>
<span class="sd">    corresponding to either :math:`u_{top}` or :math:`u_{bot}` homogenisations.</span>


<span class="sd">    The :math:`\\mathbf{E}` matrix for each load is given by:</span>

<span class="sd">    .. math:: \\mathbf{E}_{i,j}=</span>
<span class="sd">                \\int_{0}^{t_j}{</span>
<span class="sd">                  \\frac{d{</span>
<span class="sd">                    {\\cos\\left(\\omega\\tau+\\textrm{phase}\\right)}</span>
<span class="sd">                    \\sigma\\left(\\tau\\right)}}</span>
<span class="sd">                    {d\\tau}</span>
<span class="sd">                  {\\exp\\left({(dT\\left(t-\\tau\\right)\\lambda_i}\\right)}</span>
<span class="sd">                  \\,d\\tau}</span>


<span class="sd">    where</span>

<span class="sd">     - :math:`\\lambda_i` is the `ith` eigenvalue of the problem,</span>
<span class="sd">     - :math:`dT` is a time factor for numerical convienience,</span>
<span class="sd">     - :math:`\\sigma\left(\\tau\\right)` is the piecewise linear time</span>
<span class="sd">       dependant load.</span>


<span class="sd">    Note that the listed equations above are in terms of normalised depth Z,</span>
<span class="sd">    with depth integrations between [0, 1].  However, IF YOU KNOW WHAT YOU</span>
<span class="sd">    ARE DOING the integrations can be done using non-normalised depths.</span>
<span class="sd">    The first z value in the piecewise definition a(z) must still be 0</span>
<span class="sd">    however the end point for integration will be the final z value in the</span>
<span class="sd">    definition of a(z).  If you are doing this then your `m` values will</span>
<span class="sd">    include the normalising Factor. e.g. m = [pi/2/H, 3*pi/2/H] and a(z) is</span>
<span class="sd">    defined in two layers [0, z1], [z1, zend] as opposed to</span>
<span class="sd">    m = [pi/2, 3*pi/2] and a(Z) is two layers [0, z1/H], [z1/H, zend/H].</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">E_Igamv_the</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tvals</span><span class="p">)))</span>




    <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">drn</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">zdist</span> <span class="o">=</span> <span class="n">PolyLine</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">))</span>
            <span class="c1">#bot_vs_time=None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zdist</span> <span class="o">=</span> <span class="n">PolyLine</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">)</span>


        <span class="k">if</span> <span class="ow">not</span> <span class="n">top_vs_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">top_omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">top_omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">top_vs_time</span><span class="p">)</span>

            <span class="n">theta</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pdim1sin_ab_linear</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">zdist</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">theta_zero_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">theta</span><span class="p">[</span><span class="n">theta_zero_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">top_vs_t</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">top_vs_time</span><span class="p">,</span> <span class="n">top_omega_phase</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
                    <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEDload_coslinear</span><span class="p">(</span><span class="n">top_vs_t</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEDload_linear</span><span class="p">(</span><span class="n">top_vs_t</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
                <span class="n">E_Igamv_the</span> <span class="o">+=</span> <span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Igamv</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>


        <span class="k">if</span> <span class="ow">not</span> <span class="n">bot_vs_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bot_omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bot_omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bot_vs_time</span><span class="p">)</span>

            <span class="n">theta</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pdim1sin_ab_linear</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">PolyLine</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">theta_zero_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">theta</span><span class="p">[</span><span class="n">theta_zero_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">bot_vs_t</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bot_vs_time</span><span class="p">,</span> <span class="n">bot_omega_phase</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
                    <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEDload_coslinear</span><span class="p">(</span><span class="n">bot_vs_t</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEDload_linear</span><span class="p">(</span><span class="n">bot_vs_t</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
                <span class="n">E_Igamv_the</span> <span class="o">+=</span> <span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Igamv</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="c1">#theta is 1d array, Igamv is nieg by neig array, np.dot(Igamv, theta)</span>
    <span class="c1">#and np.dot(theta, Igamv) will give differetn 1d arrays.</span>
    <span class="c1">#Basically np.dot(Igamv, theta) gives us what we want i.e.</span>
    <span class="c1">#theta was treated as a column array.  The alternative</span>
    <span class="c1">#np.dot(theta, Igamv) would have treated theta as a row vector.</span>
    <span class="k">return</span> <span class="n">E_Igamv_the</span></div>


<div class="viewcode-block" id="dim1sin_E_Igamv_the_BC_abf_linear"><a class="viewcode-back" href="../../../api/geotecha.speccon.speccon1d.html#geotecha.speccon.speccon1d.dim1sin_E_Igamv_the_BC_abf_linear">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_E_Igamv_the_BC_abf_linear</span><span class="p">(</span><span class="n">drn</span><span class="p">,</span>
                                      <span class="n">m</span><span class="p">,</span>
                                      <span class="n">eigs</span><span class="p">,</span>
                                      <span class="n">tvals</span><span class="p">,</span>
                                      <span class="n">Igamv</span><span class="p">,</span>
                                      <span class="n">a</span><span class="p">,</span>
                                      <span class="n">b</span><span class="p">,</span>
                                      <span class="n">top_vs_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">bot_vs_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">top_omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">bot_omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">dT</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                      <span class="n">theta_zero_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">implementation</span><span class="o">=</span><span class="s1">&#39;vectorized&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate E and theta parts and assemble E_Igamv_the matrix that arises</span>
<span class="sd">    from homogenising a(Z)*b(Z)*u(Z,t) for non_zero top and bottom boundary</span>
<span class="sd">    conditions.</span>

<span class="sd">    When accounting for non-zero boundary conditions we homogenise the</span>
<span class="sd">    governing equation by letting u(Z,t) = v(Z,t) + utop(t)*(1-Z) + ubot(t)*Z</span>
<span class="sd">    and solving for v(Z, t).  This function calculates the time dependent</span>
<span class="sd">    E part, the depth dependent theta part, and then assembles</span>
<span class="sd">    E*inverse(gam*v)*theta which forms part of solution</span>
<span class="sd">    v(Z,t)=phi*v*E*inverse(gam*v)*theta.  The E and theta parts arise</span>
<span class="sd">    by subbing the boundary conditions into into governing equation terms of</span>
<span class="sd">    the form a(z)*b(z)*u(Z,t)</span>

<span class="sd">    The contribution of each `mag_vs_time`-`omega_phase` pairing</span>
<span class="sd">    are superposed.    The result is an array</span>
<span class="sd">    of size (neig, len(tvals)). So each column is the are the column vector</span>
<span class="sd">    E*inverse(gam*v)*theta calculated at each output time.  This will allow</span>
<span class="sd">    us later to do v(Z,t) = phi*v*E_Igamv_the.</span>

<span class="sd">    Uses sin(m*z) in the calculation of theta.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    drn : [0,1]</span>
<span class="sd">        Drainage condition,</span>
<span class="sd">        drn=0 for Pervious top pervious bottom (PTPB).</span>
<span class="sd">        drn=1 for Pervious top impoervious bottom (PTIB).</span>
<span class="sd">    m : ``list`` of ``float``</span>
<span class="sd">        Eigenvalues of BVP, the m in sin(m*Z). Generate with</span>
<span class="sd">        geotecha.speccon.m_from_sin_mx.</span>
<span class="sd">    eigs : 1d numpy.ndarray</span>
<span class="sd">        List of eigenvalues of the spectral matrix i.e. Eigenvalues of the</span>
<span class="sd">        square Igam_psi matrix.</span>
<span class="sd">    tvals : 1d numpy.ndarray`</span>
<span class="sd">        List of time values to evaluate E matrix at.</span>
<span class="sd">    Igamv : ndarray</span>
<span class="sd">        Speccon matrix.  Igamv = inverse of [gam * v])</span>
<span class="sd">    a, b : PolyLine</span>
<span class="sd">        Piewcewise linear function.  e.g. for 1d consolidation surcharge</span>
<span class="sd">        radial draiange term is dTh*kh*et*u(Z,t) `a` would be kh, `b` would</span>
<span class="sd">        be et.</span>
<span class="sd">    top_vs_time, bot_vs_time : list of PolyLine</span>
<span class="sd">        Piecewise linear magnitude vs time for the top and bottom boundary.</span>
<span class="sd">        Use ``None`` if there is no variation.</span>
<span class="sd">    top_omega_phase, bot_omega_phase : list of 2 element tuples, optional</span>
<span class="sd">        (omega, phase) for use in cos(omega * t + phase) * mag_vs_time</span>
<span class="sd">        if omega_phase is None then mag_vs_time will not be multiplied by a</span>
<span class="sd">        cosine.  If any element of omega_phase is None then in that particular</span>
<span class="sd">        loading combo, mag_vs_time will not be multiplied by a cosine.</span>
<span class="sd">    dT : ``float``, optional</span>
<span class="sd">        Time factor multiple for numerical convieniece. Default dT=1.0.</span>
<span class="sd">    theta_zero_indexes : slice/list etc., optional</span>
<span class="sd">        A slice object, list, etc that can be used for numpy fancy indexing.</span>
<span class="sd">        Any specified index of the theta vector will be set to zero.  This is</span>
<span class="sd">        useful when using the spectral method with block matrices and the</span>
<span class="sd">        loading term only refers to a subset of the equations.  When using</span>
<span class="sd">        block matrices m should be the same size as the block matrix.</span>
<span class="sd">        Default theta_zero_indexes=None i.e. no elements of theta will be</span>
<span class="sd">        set to zero.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    E_Igamv_the : ndarray</span>
<span class="sd">        Loading matrix of size (neig, len(tvals)).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Assuming the loads are formulated as the product of separate time and depth</span>
<span class="sd">    dependant functions as well as a cyclic component:</span>

<span class="sd">    .. math:: \\sigma\\left({Z,t}\\right)=</span>
<span class="sd">                \\sigma\\left({Z}\\right)</span>
<span class="sd">                \\sigma\\left({t}\\right)</span>
<span class="sd">                \\cos\\left(\\omega t + \\phi\\right)</span>

<span class="sd">    the solution to the consolidation equation using the spectral method has</span>
<span class="sd">    the form:</span>

<span class="sd">    .. math:: u\\left(Z,t\\right)=</span>
<span class="sd">                \\mathbf{\\phi v E}</span>
<span class="sd">                \\left(\\mathbf{\\Gamma v}\\right)^{-1}</span>
<span class="sd">                \\mathbf{\\theta}</span>


<span class="sd">    When we consider non-zero boundary conditions, additional loading terms are</span>
<span class="sd">    created when we sub in the following into the original governing equation.</span>

<span class="sd">    .. math:: u\\left({Z,t}\\right)=</span>
<span class="sd">                v\\left({Z,t}\\right) +</span>
<span class="sd">                u_{top}\\left({t}\\right)\\left({1-Z}\\right) +</span>
<span class="sd">                u_{bot}\\left({b}\\right)Z</span>

<span class="sd">    Two additional loading terms are created with each substitution, one</span>
<span class="sd">    for the top boundary condition and one for the bottom boundary condition.</span>

<span class="sd">    This function calculates :math:`\\mathbf{E}\\left(\\mathbf{\\Gamma v}\\right)^{-1}\\mathbf{\\theta}`</span>
<span class="sd">    when substitutions are made in terms of the following form:</span>


<span class="sd">    .. math:: a\\left({Z}\\right)</span>
<span class="sd">              b\\left({Z}\\right)</span>
<span class="sd">              u\\left({Z,t}\\right)</span>

<span class="sd">    It is assumed that :math:`u_{top}\\left({t}\\right)` and</span>
<span class="sd">    :math:`u_{bot}\\left({t}\\right)` are piecewise linear</span>
<span class="sd">    in time with a cyclic component, and that multiple functions are</span>
<span class="sd">    superposed.  Also :math:`a\\left(Z\\right)` and :math:`b\\left(Z\\right)`</span>
<span class="sd">    are piecewise linear functions with respect to :math:`Z`</span>


<span class="sd">    For this particular function the :math:`\\mathbf{\\theta}` vector for</span>
<span class="sd">    each load is given by:</span>

<span class="sd">    .. math:: \\mathbf{\\theta}_{i}=</span>
<span class="sd">                \\int_{0}^1{</span>
<span class="sd">                  {a\\left(Z\\right)}</span>
<span class="sd">                  {b\\left(Z\\right)}</span>
<span class="sd">                  {\\sigma\\left(Z\\right)}</span>
<span class="sd">                  f\\left({Z}\\right)</span>
<span class="sd">                  \\phi_i\\,dZ}</span>

<span class="sd">    Where :math:`f\\left({Z}\\right)` is the appropriate z-dependent term</span>
<span class="sd">    corresponding to either :math:`u_{top}` or :math:`u_{bot}` homogenisations.</span>


<span class="sd">    The :math:`\\mathbf{E}` matrix for each load is given by:</span>

<span class="sd">    .. math:: \\mathbf{E}_{i,j}=</span>
<span class="sd">                \\int_{0}^{t_j}{</span>
<span class="sd">                  {\\cos\\left(\\omega\\tau+\\textrm{phase}\\right)}</span>
<span class="sd">                  {\\sigma\\left(\\tau\\right)}</span>
<span class="sd">                  {\\exp\\left({(dT\\left(t-\\tau\\right)\\lambda_i}\\right)}</span>
<span class="sd">                  \\,d\\tau}</span>


<span class="sd">    where</span>

<span class="sd">     - :math:`\\lambda_i` is the `ith` eigenvalue of the problem,</span>
<span class="sd">     - :math:`dT` is a time factor for numerical convienience,</span>
<span class="sd">     - :math:`\\sigma\left(\\tau\\right)` is the piecewise linear time</span>
<span class="sd">       dependant load.</span>


<span class="sd">    Note that the listed equations above are in terms of normalised depth Z,</span>
<span class="sd">    with depth integrations between [0, 1].  However, IF YOU KNOW WHAT YOU</span>
<span class="sd">    ARE DOING the integrations can be done using non-normalised depths.</span>
<span class="sd">    The first z value in the piecewise definition a(z) must still be 0</span>
<span class="sd">    however the end point for integration will be the final z value in the</span>
<span class="sd">    definition of a(z).  If you are doing this then your `m` values will</span>
<span class="sd">    include the normalising Factor. e.g. m = [pi/2/H, 3*pi/2/H] and a(z) is</span>
<span class="sd">    defined in two layers [0, z1], [z1, zend] as opposed to</span>
<span class="sd">    m = [pi/2, 3*pi/2] and a(Z) is two layers [0, z1/H], [z1/H, zend/H].</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">E_Igamv_the</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tvals</span><span class="p">)))</span>

    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">pwise</span><span class="o">.</span><span class="n">polyline_make_x_common</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">drn</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">zdist</span> <span class="o">=</span> <span class="n">PolyLine</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">))</span>
            <span class="c1">#bot_vs_time=None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zdist</span> <span class="o">=</span> <span class="n">PolyLine</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">top_vs_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">top_omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">top_omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">top_vs_time</span><span class="p">)</span>

            <span class="n">theta</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pdim1sin_abc_linear</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">zdist</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">theta_zero_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">theta</span><span class="p">[</span><span class="n">theta_zero_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">top_vs_t</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">top_vs_time</span><span class="p">,</span> <span class="n">top_omega_phase</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
                    <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEload_coslinear</span><span class="p">(</span><span class="n">top_vs_t</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEload_linear</span><span class="p">(</span><span class="n">top_vs_t</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
<span class="c1">#                E_Igamv_the += (E*np.dot(Igamv, theta)).T</span>
                <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">E_Igamv_the</span><span class="p">,</span> <span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Igamv</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">E_Igamv_the</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">bot_vs_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bot_omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bot_omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bot_vs_time</span><span class="p">)</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pdim1sin_abc_linear</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">PolyLine</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">theta_zero_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">theta</span><span class="p">[</span><span class="n">theta_zero_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">bot_vs_t</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bot_vs_time</span><span class="p">,</span> <span class="n">bot_omega_phase</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
                    <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEload_coslinear</span><span class="p">(</span><span class="n">bot_vs_t</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEload_linear</span><span class="p">(</span><span class="n">bot_vs_t</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
                <span class="c1">#E_Igamv_the += (E*np.dot(Igamv, theta)).T</span>
                <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">E_Igamv_the</span><span class="p">,</span> <span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Igamv</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">E_Igamv_the</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>

    <span class="c1">#theta is 1d array, Igamv is nieg by neig array, np.dot(Igamv, theta)</span>
    <span class="c1">#and np.dot(theta, Igamv) will give differetn 1d arrays.</span>
    <span class="c1">#Basically np.dot(Igamv, theta) gives us what we want i.e.</span>
    <span class="c1">#theta was treated as a column array.  The alternative</span>
    <span class="c1">#np.dot(theta, Igamv) would have treated theta as a row vector.</span>
    <span class="k">return</span> <span class="n">E_Igamv_the</span></div>


<div class="viewcode-block" id="dim1sin_E_Igamv_the_BC_abDfDt_linear"><a class="viewcode-back" href="../../../api/geotecha.speccon.speccon1d.html#geotecha.speccon.speccon1d.dim1sin_E_Igamv_the_BC_abDfDt_linear">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_E_Igamv_the_BC_abDfDt_linear</span><span class="p">(</span><span class="n">drn</span><span class="p">,</span>
                                         <span class="n">m</span><span class="p">,</span>
                                         <span class="n">eigs</span><span class="p">,</span>
                                         <span class="n">tvals</span><span class="p">,</span>
                                         <span class="n">Igamv</span><span class="p">,</span>
                                         <span class="n">a</span><span class="p">,</span>
                                         <span class="n">b</span><span class="p">,</span>
                                         <span class="n">top_vs_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">bot_vs_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">top_omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">bot_omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">dT</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                         <span class="n">theta_zero_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">implementation</span><span class="o">=</span><span class="s1">&#39;vectorized&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate E and theta parts and assemble E_Igamv_the matrix that arises</span>
<span class="sd">    from homogenising a(Z)*b(Z)*D[u(Z, t), t] for non_zero top and bottom</span>
<span class="sd">    boundary conditions.</span>

<span class="sd">    When accounting for non-zero boundary conditions we homogenise the</span>
<span class="sd">    governing equation by letting u(Z,t) = v(Z,t) + utop(t)*(1-Z) + ubot(t)*Z</span>
<span class="sd">    and solving for v(Z, t).  This function calculates the time dependent</span>
<span class="sd">    E part, the depth dependent theta part, and then assembles</span>
<span class="sd">    E*inverse(gam*v)*theta which forms part of solution</span>
<span class="sd">    v(Z,t)=phi*v*E*inverse(gam*v)*theta.  The E and theta parts arise</span>
<span class="sd">    by subbing the boundary conditions into into governing equation terms of</span>
<span class="sd">    the form a(Z)*b(Z)*D[u(Z,t), t].</span>

<span class="sd">    The contribution of each `mag_vs_time`-`omega_phase` pairing</span>
<span class="sd">    are superposed.    The result is an array</span>
<span class="sd">    of size (neig, len(tvals)). So each column is the are the column vector</span>
<span class="sd">    E*inverse(gam*v)*theta calculated at each output time.  This will allow</span>
<span class="sd">    us later to do v(Z,t) = phi*v*E_Igamv_the.</span>

<span class="sd">    Uses sin(m*Z) in the calculation of theta.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    drn : [0,1]</span>
<span class="sd">        Drainage condition,</span>
<span class="sd">        drn=0 for Pervious top pervious bottom (PTPB).</span>
<span class="sd">        drn=1 for Pervious top impoervious bottom (PTIB).</span>
<span class="sd">    m : ``list`` of ``float``</span>
<span class="sd">        Eigenvalues of BVP, the m in sin(m*Z). Generate with</span>
<span class="sd">        geotecha.speccon.m_from_sin_mx.</span>
<span class="sd">    eigs : 1d numpy.ndarray</span>
<span class="sd">        List of eigenvalues of the spectral matrix i.e. Eigenvalues of the</span>
<span class="sd">        square Igam_psi matrix.</span>
<span class="sd">    tvals : 1d numpy.ndarray`</span>
<span class="sd">        List of time values to evaluate E matrix at.</span>
<span class="sd">    Igamv : ndarray</span>
<span class="sd">        Speccon matrix.  Igamv = inverse of [gam * v])</span>
<span class="sd">    a, b : PolyLine</span>
<span class="sd">        Piewcewise linear function.  e.g. for 1d consolidation surcharge</span>
<span class="sd">        radial draiange term is dTh*kh*et*u(Z,t) `a` would be kh, `b` would</span>
<span class="sd">        be et.</span>
<span class="sd">    top_vs_time, bot_vs_time : list of PolyLine</span>
<span class="sd">        Piecewise linear magnitude vs time for the top and bottom boundary.</span>
<span class="sd">        Use ``None`` if there is no variation.</span>
<span class="sd">    top_omega_phase, bot_omega_phase : list of 2 element tuples, optional</span>
<span class="sd">        (omega, phase) for use in cos(omega * t + phase) * mag_vs_time</span>
<span class="sd">        if omega_phase is None then mag_vs_time will not be multiplied by a</span>
<span class="sd">        cosine.  If any element of omega_phase is None then in that particular</span>
<span class="sd">        loading combo, mag_vs_time will not be multiplied by a cosine.</span>
<span class="sd">    dT : ``float``, optional</span>
<span class="sd">        Time factor multiple for numerical convieniece. Default dT=1.0.</span>
<span class="sd">    theta_zero_indexes : slice/list etc., optional</span>
<span class="sd">        A slice object, list, etc that can be used for numpy fancy indexing.</span>
<span class="sd">        Any specified index of the theta vector will be set to zero.  This is</span>
<span class="sd">        useful when using the spectral method with block matrices and the</span>
<span class="sd">        loading term only refers to a subset of the equations.  When using</span>
<span class="sd">        block matrices m should be the same size as the block matrix.</span>
<span class="sd">        Default theta_zero_indexes=None i.e. no elements of theta will be</span>
<span class="sd">        set to zero.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    E_Igamv_the : ndarray</span>
<span class="sd">        Loading matrix of size (neig, len(tvals)).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Assuming the loads are formulated as the product of separate time and depth</span>
<span class="sd">    dependant functions as well as a cyclic component:</span>

<span class="sd">    .. math:: \\sigma\\left({Z,t}\\right)=</span>
<span class="sd">                \\sigma\\left({Z}\\right)</span>
<span class="sd">                \\sigma\\left({t}\\right)</span>
<span class="sd">                \\cos\\left(\\omega t + \\phi\\right)</span>

<span class="sd">    the solution to the consolidation equation using the spectral method has</span>
<span class="sd">    the form:</span>

<span class="sd">    .. math:: u\\left(Z,t\\right)=</span>
<span class="sd">                \\mathbf{\\phi v E}</span>
<span class="sd">                \\left(\\mathbf{\\Gamma v}\\right)^{-1}</span>
<span class="sd">                \\mathbf{\\theta}</span>


<span class="sd">    When we consider non-zero boundary conditions, additional loading terms are</span>
<span class="sd">    created when we sub in the following into the original governing equation.</span>

<span class="sd">    .. math:: u\\left({Z,t}\\right)=</span>
<span class="sd">                v\\left({Z,t}\\right) +</span>
<span class="sd">                u_{top}\\left({t}\\right)\\left({1-Z}\\right) +</span>
<span class="sd">                u_{bot}\\left({b}\\right)Z</span>

<span class="sd">    Two additional loading terms are created with each substitution, one</span>
<span class="sd">    for the top boundary condition and one for the bottom boundary condition.</span>

<span class="sd">    This function calculates :math:`\\mathbf{E}\\left(\\mathbf{\\Gamma v}\\right)^{-1}\\mathbf{\\theta}`</span>
<span class="sd">    when substitutions are made in terms of the following form:</span>


<span class="sd">    .. math:: a\\left({Z}\\right)</span>
<span class="sd">              b\\left({Z}\\right)</span>
<span class="sd">              \\frac{\\partial u}{\\partial t}</span>

<span class="sd">    It is assumed that :math:`u_{top}\\left({t}\\right)` and</span>
<span class="sd">    :math:`u_{bot}\\left({t}\\right)` are piecewise linear</span>
<span class="sd">    in time with a cyclic component, and that multiple functions are</span>
<span class="sd">    superposed.  Also :math:`a\\left(Z\\right)` and :math:`b\\left(Z\\right)`</span>
<span class="sd">    are piecewise linear functions w.r.t. :math:`Z`</span>


<span class="sd">    For this particular function the :math:`\\mathbf{\\theta}` vector for</span>
<span class="sd">    each load is given by:</span>

<span class="sd">    .. math:: \\mathbf{\\theta}_{i}=</span>
<span class="sd">                \\int_{0}^1{</span>
<span class="sd">                  {a\\left(Z\\right)}</span>
<span class="sd">                  {b\\left(Z\\right)}</span>
<span class="sd">                  {\\sigma\\left(Z\\right)}</span>
<span class="sd">                  f\\left({Z}\\right)</span>
<span class="sd">                  \\phi_i\\,dZ}</span>

<span class="sd">    Where :math:`f\\left({Z}\\right)` is the appropriate z-dependent term</span>
<span class="sd">    corresponding to either :math:`u_{top}` or :math:`u_{bot}` homogenisations.</span>


<span class="sd">    The :math:`\\mathbf{E}` matrix for each load is given by:</span>

<span class="sd">    .. math:: \\mathbf{E}_{i,j}=</span>
<span class="sd">                \\int_{0}^{t_j}{</span>
<span class="sd">                  \\frac{d{</span>
<span class="sd">                    {\\cos\\left(\\omega\\tau+\\textrm{phase}\\right)}</span>
<span class="sd">                    \\sigma\\left(\\tau\\right)}}</span>
<span class="sd">                    {d\\tau}</span>
<span class="sd">                  {\\exp\\left({(dT\\left(t-\\tau\\right)\\lambda_i}\\right)}</span>
<span class="sd">                  \\,d\\tau}</span>


<span class="sd">    where</span>

<span class="sd">     - :math:`\\lambda_i` is the `ith` eigenvalue of the problem,</span>
<span class="sd">     - :math:`dT` is a time factor for numerical convienience,</span>
<span class="sd">     - :math:`\\sigma\left(\\tau\\right)` is the piecewise linear time</span>
<span class="sd">       dependant load.</span>


<span class="sd">    Note that the listed equations above are in terms of normalised depth Z,</span>
<span class="sd">    with depth integrations between [0, 1].  However, IF YOU KNOW WHAT YOU</span>
<span class="sd">    ARE DOING the integrations can be done using non-normalised depths.</span>
<span class="sd">    The first z value in the piecewise definition a(z) must still be 0</span>
<span class="sd">    however the end point for integration will be the final z value in the</span>
<span class="sd">    definition of a(z).  If you are doing this then your `m` values will</span>
<span class="sd">    include the normalising Factor. e.g. m = [pi/2/H, 3*pi/2/H] and a(z) is</span>
<span class="sd">    defined in two layers [0, z1], [z1, zend] as opposed to</span>
<span class="sd">    m = [pi/2, 3*pi/2] and a(Z) is two layers [0, z1/H], [z1/H, zend/H].</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">E_Igamv_the</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tvals</span><span class="p">)))</span>

    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">pwise</span><span class="o">.</span><span class="n">polyline_make_x_common</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">drn</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">zdist</span> <span class="o">=</span> <span class="n">PolyLine</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">))</span>
            <span class="c1">#bot_vs_time=None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zdist</span> <span class="o">=</span> <span class="n">PolyLine</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">top_vs_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">top_omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">top_omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">top_vs_time</span><span class="p">)</span>

            <span class="n">theta</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pdim1sin_abc_linear</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">zdist</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">theta_zero_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">theta</span><span class="p">[</span><span class="n">theta_zero_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">top_vs_t</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">top_vs_time</span><span class="p">,</span> <span class="n">top_omega_phase</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
                    <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEDload_coslinear</span><span class="p">(</span><span class="n">top_vs_t</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEDload_linear</span><span class="p">(</span><span class="n">top_vs_t</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
                <span class="n">E_Igamv_the</span> <span class="o">+=</span> <span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Igamv</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">bot_vs_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bot_omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bot_omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bot_vs_time</span><span class="p">)</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pdim1sin_abc_linear</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">PolyLine</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">theta_zero_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">theta</span><span class="p">[</span><span class="n">theta_zero_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">bot_vs_t</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bot_vs_time</span><span class="p">,</span> <span class="n">bot_omega_phase</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
                    <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEDload_coslinear</span><span class="p">(</span><span class="n">bot_vs_t</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEDload_linear</span><span class="p">(</span><span class="n">bot_vs_t</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
                <span class="n">E_Igamv_the</span> <span class="o">+=</span> <span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Igamv</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="c1">#theta is 1d array, Igamv is nieg by neig array, np.dot(Igamv, theta)</span>
    <span class="c1">#and np.dot(theta, Igamv) will give differetn 1d arrays.</span>
    <span class="c1">#Basically np.dot(Igamv, theta) gives us what we want i.e.</span>
    <span class="c1">#theta was treated as a column array.  The alternative</span>
    <span class="c1">#np.dot(theta, Igamv) would have treated theta as a row vector.</span>
    <span class="k">return</span> <span class="n">E_Igamv_the</span></div>


<div class="viewcode-block" id="dim1sin_E_Igamv_the_BC_D_aDf_linear"><a class="viewcode-back" href="../../../api/geotecha.speccon.speccon1d.html#geotecha.speccon.speccon1d.dim1sin_E_Igamv_the_BC_D_aDf_linear">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_E_Igamv_the_BC_D_aDf_linear</span><span class="p">(</span><span class="n">drn</span><span class="p">,</span>
                                        <span class="n">m</span><span class="p">,</span>
                                        <span class="n">eigs</span><span class="p">,</span>
                                        <span class="n">tvals</span><span class="p">,</span>
                                        <span class="n">Igamv</span><span class="p">,</span>
                                        <span class="n">a</span><span class="p">,</span>
                                        <span class="n">top_vs_time</span><span class="p">,</span>
                                        <span class="n">bot_vs_time</span><span class="p">,</span>
                                        <span class="n">top_omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">bot_omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">dT</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                        <span class="n">theta_zero_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">implementation</span><span class="o">=</span><span class="s1">&#39;vectorized&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate E and theta parts and assemble E_Igamv_the matrix that arises</span>
<span class="sd">    from homogenising D[a(Z)*D[u(Z, t),Z],Z] for non_zero top and bottom</span>
<span class="sd">    boundary conditions.</span>

<span class="sd">    When accounting for non-zero boundary conditions we homogenise the</span>
<span class="sd">    governing equation by letting u(Z,t) = v(Z,t) + utop(t)*(1-Z) + ubot(t)*Z</span>
<span class="sd">    and solving for v(Z, t).  This function calculates the time dependent</span>
<span class="sd">    E part, the depth dependent theta part, and then assembles</span>
<span class="sd">    E*inverse(gam*v)*theta which forms part of solution</span>
<span class="sd">    v(Z,t)=phi*v*E*inverse(gam*v)*theta.  The E and theta parts arise</span>
<span class="sd">    by subbing the boundary conditions into into governing equation terms of</span>
<span class="sd">    the form D[a(Z)*D[u(Z, t),Z],Z].</span>

<span class="sd">    The contribution of each `mag_vs_time`-`omega_phase` pairing</span>
<span class="sd">    are superposed.    The result is an array</span>
<span class="sd">    of size (neig, len(tvals)). So each column is the are the column vector</span>
<span class="sd">    E*inverse(gam*v)*theta calculated at each output time.  This will allow</span>
<span class="sd">    us later to do v(Z,t) = phi*v*E_Igamv_the.</span>

<span class="sd">    Uses sin(m*z) in the calculation of theta.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    drn : [0,1]</span>
<span class="sd">        Drainage condition,</span>
<span class="sd">        drn=0 for Pervious top pervious bottom (PTPB).</span>
<span class="sd">        drn=1 for Pervious top impoervious bottom (PTIB).</span>
<span class="sd">    m : ``list`` of ``float``</span>
<span class="sd">        Eigenvalues of BVP, the m in sin(m*Z). Generate with</span>
<span class="sd">        geotecha.speccon.m_from_sin_mx.</span>
<span class="sd">    eigs : 1d numpy.ndarray</span>
<span class="sd">        List of eigenvalues of the spectral matrix i.e. Eigenvalues of the</span>
<span class="sd">        square Igam_psi matrix.</span>
<span class="sd">    tvals : 1d numpy.ndarray`</span>
<span class="sd">        List of time values to evaluate E matrix at.</span>
<span class="sd">    Igamv : ndarray</span>
<span class="sd">        Speccon matrix.  Igamv = inverse of [gam * v])</span>
<span class="sd">    a : PolyLine</span>
<span class="sd">        Piewcewise linear function.  e.g. for 1d consolidation surcharge</span>
<span class="sd">        radial draiange term is D[kv(z)*D[u(Z,t), Z],Z] so `a` would be kv.</span>
<span class="sd">        be et.</span>
<span class="sd">    top_vs_time, bot_vs_time : list of PolyLine</span>
<span class="sd">        Piecewise linear magnitude vs time for the top and bottom boundary.</span>
<span class="sd">        Use ``None`` if there is no variation.</span>
<span class="sd">    top_omega_phase, bot_omega_phase : list of 2 element tuples, optional</span>
<span class="sd">        (omega, phase) for use in cos(omega * t + phase) * mag_vs_time</span>
<span class="sd">        if omega_phase is None then mag_vs_time will not be multiplied by a</span>
<span class="sd">        cosine.  If any element of omega_phase is None then in that particular</span>
<span class="sd">        loading combo, mag_vs_time will not be multiplied by a cosine.</span>
<span class="sd">    dT : ``float``, optional</span>
<span class="sd">        Time factor multiple for numerical convieniece. Default dT=1.0.</span>
<span class="sd">    theta_zero_indexes : slice/list etc., optional</span>
<span class="sd">        A slice object, list, etc that can be used for numpy fancy indexing.</span>
<span class="sd">        Any specified index of the theta vector will be set to zero.  This is</span>
<span class="sd">        useful when using the spectral method with block matrices and the</span>
<span class="sd">        loading term only refers to a subset of the equations.  When using</span>
<span class="sd">        block matrices m should be the same size as the block matrix.</span>
<span class="sd">        Default theta_zero_indexes=None i.e. no elements of theta will be</span>
<span class="sd">        set to zero.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    E_Igamv_the : ndarray</span>
<span class="sd">        Loading matrix of size (neig, len(tvals)).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Assuming the loads are formulated as the product of separate time and depth</span>
<span class="sd">    dependant functions as well as a cyclic component:</span>

<span class="sd">    .. math:: \\sigma\\left({Z,t}\\right)=</span>
<span class="sd">                \\sigma\\left({Z}\\right)</span>
<span class="sd">                \\sigma\\left({t}\\right)</span>
<span class="sd">                \\cos\\left(\\omega t + \\phi\\right)</span>

<span class="sd">    the solution to the consolidation equation using the spectral method has</span>
<span class="sd">    the form:</span>

<span class="sd">    .. math:: u\\left(Z,t\\right)=</span>
<span class="sd">                \\mathbf{\\phi} \\mathbf{v} \\mathbf{E}</span>
<span class="sd">                \\left(\\mathbf{\\Gamma v}\\right)^{-1}</span>
<span class="sd">                \\mathbf{\\theta}</span>


<span class="sd">    When we consider non-zero boundary conditions, additional loading terms are</span>
<span class="sd">    created when we sub in the following into the original governing equation.</span>

<span class="sd">    .. math:: u\\left({Z,t}\\right)=</span>
<span class="sd">                v\\left({Z,t}\\right) +</span>
<span class="sd">                u_{top}\\left({t}\\right)\\left({1-Z}\\right) +</span>
<span class="sd">                u_{bot}\\left({b}\\right)Z</span>

<span class="sd">    Two additional loading terms are created with each substitution, one</span>
<span class="sd">    for the top boundary condition and one for the bottom boundary condition.</span>

<span class="sd">    This function calculates :math:`\\mathbf{E}\\left(\\mathbf{\\Gamma v}\\right)^{-1}\\mathbf{\\theta}`</span>
<span class="sd">    when substitutions are made in terms of the following form:</span>

<span class="sd">    .. math:: \\frac{\\partial}{\\partial Z}</span>
<span class="sd">                \\left(</span>
<span class="sd">                  {a\\left({Z}\\right)</span>
<span class="sd">                  \\frac{\\partial u\\left({Z,t}\\right)}{\\partial Z}}</span>
<span class="sd">                \\right)</span>


<span class="sd">    It is assumed that :math:`u_{top}\\left({t}\\right)` and</span>
<span class="sd">    :math:`u_{bot}\\left({t}\\right)` are piecewise linear</span>
<span class="sd">    in time with a cyclic component, and that multiple functions are</span>
<span class="sd">    superposed.  Also :math:`a\\left(Z\\right)`</span>
<span class="sd">    is a piecewise linear function with respect to :math:`Z`</span>


<span class="sd">    For this particular function the :math:`\\mathbf{\\theta}` vector for</span>
<span class="sd">    each load is given by:</span>

<span class="sd">    .. math:: \\mathbf{\\theta}_{i}=</span>
<span class="sd">                \\int_{0}^1{</span>
<span class="sd">                  \\frac{\\partial}{\\partial Z}</span>
<span class="sd">                  \\left(</span>
<span class="sd">                    {a\\left({Z}\\right)</span>
<span class="sd">                    \\frac{\\partial \\sigma\\left({Z}\\right)}{\\partial Z}}</span>
<span class="sd">                  \\right)</span>
<span class="sd">                  f\\left({Z}\\right)</span>
<span class="sd">                  \\phi_i\\,dZ}</span>

<span class="sd">    Where :math:`f\\left({Z}\\right)` is the appropriate z-dependent term</span>
<span class="sd">    corresponding to either :math:`u_{top}` or :math:`u_{bot}` homogenisations.</span>


<span class="sd">    The :math:`\\mathbf{E}` matrix for each load is given by:</span>

<span class="sd">    .. math:: \\mathbf{E}_{i,j}=</span>
<span class="sd">                \\int_{0}^{t_j}{</span>
<span class="sd">                  {\\cos\\left(\\omega\\tau+\\textrm{phase}\\right)}</span>
<span class="sd">                  {\\sigma\\left(\\tau\\right)}</span>
<span class="sd">                  {\\exp\\left({(dT\\left(t-\\tau\\right)\\lambda_i}\\right)}</span>
<span class="sd">                  \\,d\\tau}</span>


<span class="sd">    where</span>

<span class="sd">     - :math:`\\lambda_i` is the `ith` eigenvalue of the problem,</span>
<span class="sd">     - :math:`dT` is a time factor for numerical convienience,</span>
<span class="sd">     - :math:`\\sigma\left(\\tau\\right)` is the piecewise linear time</span>
<span class="sd">       dependant load.</span>


<span class="sd">    Note that the listed equations above are in terms of normalised depth Z,</span>
<span class="sd">    with depth integrations between [0, 1].  However, IF YOU KNOW WHAT YOU</span>
<span class="sd">    ARE DOING the integrations can be done using non-normalised depths.</span>
<span class="sd">    The first z value in the piecewise definition a(z) must still be 0</span>
<span class="sd">    however the end point for integration will be the final z value in the</span>
<span class="sd">    definition of a(z).  If you are doing this then your `m` values will</span>
<span class="sd">    include the normalising Factor. e.g. m = [pi/2/H, 3*pi/2/H] and a(z) is</span>
<span class="sd">    defined in two layers [0, z1], [z1, zend] as opposed to</span>
<span class="sd">    m = [pi/2, 3*pi/2] and a(Z) is two layers [0, z1/H], [z1/H, zend/H].</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">E_Igamv_the</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tvals</span><span class="p">)))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">drn</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">zdist</span> <span class="o">=</span> <span class="n">PolyLine</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">))</span>
            <span class="c1">#bot_vs_time=None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zdist</span> <span class="o">=</span> <span class="n">PolyLine</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">top_vs_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">top_omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">top_omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">top_vs_time</span><span class="p">)</span>

            <span class="n">theta</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pdim1sin_D_aDb_linear</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">zdist</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">theta_zero_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">theta</span><span class="p">[</span><span class="n">theta_zero_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">top_vs_t</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">top_vs_time</span><span class="p">,</span> <span class="n">top_omega_phase</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
                    <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEload_coslinear</span><span class="p">(</span><span class="n">top_vs_t</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEload_linear</span><span class="p">(</span><span class="n">top_vs_t</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
<span class="c1">#                E_Igamv_the += (E*np.dot(Igamv, theta)).T</span>
                <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">E_Igamv_the</span><span class="p">,</span> <span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Igamv</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">E_Igamv_the</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">bot_vs_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bot_omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bot_omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bot_vs_time</span><span class="p">)</span>

            <span class="n">theta</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pdim1sin_D_aDb_linear</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">PolyLine</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">theta_zero_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">theta</span><span class="p">[</span><span class="n">theta_zero_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">bot_vs_t</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bot_vs_time</span><span class="p">,</span> <span class="n">bot_omega_phase</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
                    <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEload_coslinear</span><span class="p">(</span><span class="n">bot_vs_t</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEload_linear</span><span class="p">(</span><span class="n">bot_vs_t</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">E_Igamv_the</span><span class="p">,</span> <span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Igamv</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">E_Igamv_the</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>
<span class="c1">#                E_Igamv_the += (E*np.dot(Igamv, theta)).T</span>

    <span class="c1">#theta is 1d array, Igamv is nieg by neig array, np.dot(Igamv, theta)</span>
    <span class="c1">#and np.dot(theta, Igamv) will give differetn 1d arrays.</span>
    <span class="c1">#Basically np.dot(Igamv, theta) gives us what we want i.e.</span>
    <span class="c1">#theta was treated as a column array.  The alternative</span>
    <span class="c1">#np.dot(theta, Igamv) would have treated theta as a row vector.</span>
    <span class="k">return</span> <span class="n">E_Igamv_the</span></div>


<div class="viewcode-block" id="dim1sin_E_Igamv_the_BC_deltaf_linear"><a class="viewcode-back" href="../../../api/geotecha.speccon.speccon1d.html#geotecha.speccon.speccon1d.dim1sin_E_Igamv_the_BC_deltaf_linear">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_E_Igamv_the_BC_deltaf_linear</span><span class="p">(</span><span class="n">drn</span><span class="p">,</span>
                                         <span class="n">m</span><span class="p">,</span>
                                         <span class="n">eigs</span><span class="p">,</span>
                                         <span class="n">tvals</span><span class="p">,</span>
                                         <span class="n">Igamv</span><span class="p">,</span>
                                         <span class="n">zvals</span><span class="p">,</span>
                                         <span class="n">pseudo_k</span><span class="p">,</span>
                                         <span class="n">top_vs_time</span><span class="p">,</span>
                                         <span class="n">bot_vs_time</span><span class="p">,</span>
                                         <span class="n">top_omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">bot_omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">dT</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                         <span class="n">theta_zero_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">implementation</span><span class="o">=</span><span class="s1">&#39;vectorized&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate E and theta parts and assemble E_Igamv_the matrix that arises</span>
<span class="sd">    from homogenising delta(Z-zd)*u(Z,t) for non_zero top and bottom</span>
<span class="sd">    boundary conditions.</span>

<span class="sd">    When accounting for non-zero boundary conditions we homogenise the</span>
<span class="sd">    governing equation by letting u(Z,t) = v(Z,t) + utop(t)*(1-Z) + ubot(t)*Z</span>
<span class="sd">    and solving for v(Z, t).  This function calculates the time dependent</span>
<span class="sd">    E part, the depth dependent theta part, and then assembles</span>
<span class="sd">    E*inverse(gam*v)*theta which forms part of solution</span>
<span class="sd">    v(Z,t)=phi*v*E*inverse(gam*v)*theta.  The E and theta parts arise</span>
<span class="sd">    by subbing the boundary conditions into into governing equation terms of</span>
<span class="sd">    the form delta(Z-zd)*u(Z,t).</span>

<span class="sd">    The contribution of each `mag_vs_time`-`omega_phase` pairing</span>
<span class="sd">    are superposed.    The result is an array</span>
<span class="sd">    of size (neig, len(tvals)). So each column is the are the column vector</span>
<span class="sd">    E*inverse(gam*v)*theta calculated at each output time.  This will allow</span>
<span class="sd">    us later to do v(Z,t) = phi*v*E_Igamv_the.</span>

<span class="sd">    Uses sin(m*z) in the calculation of theta.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    drn : [0,1]</span>
<span class="sd">        Drainage condition,</span>
<span class="sd">        drn=0 for Pervious top pervious bottom (PTPB).</span>
<span class="sd">        drn=1 for Pervious top impoervious bottom (PTIB).</span>
<span class="sd">    m : ``list`` of ``float``</span>
<span class="sd">        Eigenvalues of BVP, the m in sin(m*Z). Generate with</span>
<span class="sd">        geotecha.speccon.m_from_sin_mx.</span>
<span class="sd">    eigs : 1d numpy.ndarray</span>
<span class="sd">        List of eigenvalues of the spectral matrix i.e. Eigenvalues of the</span>
<span class="sd">        square Igam_psi matrix.</span>
<span class="sd">    tvals : 1d numpy.ndarray`</span>
<span class="sd">        List of time values to evaluate E matrix at.</span>
<span class="sd">    Igamv : ndarray</span>
<span class="sd">        Speccon matrix.  Igamv = inverse of [gam * v])</span>
<span class="sd">    zvals : list of float</span>
<span class="sd">        z values defining each delta function, zd.</span>
<span class="sd">    pseudo_k : list of float</span>
<span class="sd">        Coefficients to multiply each delta function by.</span>
<span class="sd">    top_vs_time, bot_vs_time : list of PolyLine</span>
<span class="sd">        Piecewise linear magnitude vs time for the top and bottom boundary.</span>
<span class="sd">        Use ``None`` if there is no variation.</span>
<span class="sd">    top_omega_phase, bot_omega_phase : list of 2 element tuples, optional</span>
<span class="sd">        (omega, phase) for use in cos(omega * t + phase) * mag_vs_time</span>
<span class="sd">        if omega_phase is None then mag_vs_time will not be multiplied by a</span>
<span class="sd">        cosine.  If any element of omega_phase is None then in that particular</span>
<span class="sd">        loading combo, mag_vs_time will not be multiplied by a cosine.</span>
<span class="sd">    dT : ``float``, optional</span>
<span class="sd">        Time factor multiple for numerical convieniece. Default dT=1.0.</span>
<span class="sd">    theta_zero_indexes : slice/list etc., optional</span>
<span class="sd">        A slice object, list, etc that can be used for numpy fancy indexing.</span>
<span class="sd">        Any specified index of the theta vector will be set to zero.  This is</span>
<span class="sd">        useful when using the spectral method with block matrices and the</span>
<span class="sd">        loading term only refers to a subset of the equations.  When using</span>
<span class="sd">        block matrices m should be the same size as the block matrix.</span>
<span class="sd">        Default theta_zero_indexes=None i.e. no elements of theta will be</span>
<span class="sd">        set to zero.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    E_Igamv_the : ndarray</span>
<span class="sd">        Loading matrix of size (neig, len(tvals)).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Assuming the loads are formulated as the product of separate time and depth</span>
<span class="sd">    dependant functions as well as a cyclic component:</span>

<span class="sd">    .. math:: \\sigma\\left({Z,t}\\right)=</span>
<span class="sd">                \\sigma\\left({Z}\\right)</span>
<span class="sd">                \\sigma\\left({t}\\right)</span>
<span class="sd">                \\cos\\left(\\omega t + \\phi\\right)</span>

<span class="sd">    the solution to the consolidation equation using the spectral method has</span>
<span class="sd">    the form:</span>

<span class="sd">    .. math:: u\\left(Z,t\\right)=</span>
<span class="sd">                \\mathbf{\\phi v E}</span>
<span class="sd">                \\left(\\mathbf{\\Gamma v}\\right)^{-1}</span>
<span class="sd">                \\mathbf{\\theta}</span>


<span class="sd">    When we consider non-zero boundary conditions, additional loading terms are</span>
<span class="sd">    created when we sub in the following into the original governing equation.</span>

<span class="sd">    .. math:: u\\left({Z,t}\\right)=</span>
<span class="sd">                v\\left({Z,t}\\right) +</span>
<span class="sd">                u_{top}\\left({t}\\right)\\left({1-Z}\\right) +</span>
<span class="sd">                u_{bot}\\left({b}\\right)Z</span>

<span class="sd">    Two additional loading terms are created with each substitution, one</span>
<span class="sd">    for the top boundary condition and one for the bottom boundary condition.</span>

<span class="sd">    This function calculates :math:`\\mathbf{E}\\left(\\mathbf{\\Gamma v}\\right)^{-1}\\mathbf{\\theta}`</span>
<span class="sd">    when substitutions are made in terms of the following form:</span>


<span class="sd">    .. math:: k_{\\textrm{pseudo}}</span>
<span class="sd">              \\delta\\left({Z-Z_d}\\right)</span>
<span class="sd">              u\\left({Z,t}\\right)</span>

<span class="sd">    It is assumed that :math:`u_{top}\\left({t}\\right)` and</span>
<span class="sd">    :math:`u_{bot}\\left({t}\\right)` are piecewise linear</span>
<span class="sd">    in time with a cyclic component, and that multiple functions are</span>
<span class="sd">    superposed.</span>


<span class="sd">    For this particular function the :math:`\\mathbf{\\theta}` vector for</span>
<span class="sd">    each load is given by:</span>

<span class="sd">    .. math:: \\mathbf{\\theta}_{i}=</span>
<span class="sd">                \\int_{0}^1{</span>
<span class="sd">                  k_{\\textrm{pseudo}}</span>
<span class="sd">                  \\delta\\left({Z-Z_d}\\right)</span>
<span class="sd">                  {\\sigma\\left(Z\\right)}</span>
<span class="sd">                  f\\left({Z}\\right)</span>
<span class="sd">                  \\phi_i\\,dZ}</span>

<span class="sd">    Where :math:`f\\left({Z}\\right)` is the appropriate z-dependent term</span>
<span class="sd">    corresponding to either :math:`u_{top}` or :math:`u_{bot}` homogenisations.</span>


<span class="sd">    The :math:`\\mathbf{E}` matrix for each load is given by:</span>

<span class="sd">    .. math:: \\mathbf{E}_{i,j}=</span>
<span class="sd">                \\int_{0}^{t_j}{</span>
<span class="sd">                  {\\cos\\left(\\omega\\tau+\\textrm{phase}\\right)}</span>
<span class="sd">                  {\\sigma\\left(\\tau\\right)}</span>
<span class="sd">                  {\\exp\\left({(dT\\left(t-\\tau\\right)\\lambda_i}\\right)}</span>
<span class="sd">                  \\,d\\tau}</span>


<span class="sd">    where</span>

<span class="sd">     - :math:`\\lambda_i` is the `ith` eigenvalue of the problem,</span>
<span class="sd">     - :math:`dT` is a time factor for numerical convienience,</span>
<span class="sd">     - :math:`\\sigma\left(\\tau\\right)` is the piecewise linear time</span>
<span class="sd">       dependant load.</span>


<span class="sd">    Note that this function, unlike many similar functions in this module,</span>
<span class="sd">    has only been formulated for Normalised depths between [0,1]</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">E_Igamv_the</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tvals</span><span class="p">)))</span>
    <span class="n">zvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">zvals</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">drn</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">zdist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">zvals</span><span class="p">)</span>
        <span class="c1">#bot_vs_time=None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">zdist</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">zvals</span>

    <span class="n">zdist</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">zvals</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">drn</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">top_vs_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">top_omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">top_omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">top_vs_time</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">top_vs_t</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">top_vs_time</span><span class="p">,</span> <span class="n">top_omega_phase</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEload_coslinear</span><span class="p">(</span><span class="n">top_vs_t</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEload_linear</span><span class="p">(</span><span class="n">top_vs_t</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">z</span><span class="p">,</span> <span class="n">zd</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">zvals</span><span class="p">,</span> <span class="n">zdist</span><span class="p">,</span> <span class="n">pseudo_k</span><span class="p">):</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">z</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">zd</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">theta_zero_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">theta</span><span class="p">[</span><span class="n">theta_zero_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="c1">#                E_Igamv_the += (E*np.dot(Igamv, theta)).T</span>
                <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">E_Igamv_the</span><span class="p">,</span> <span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Igamv</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">E_Igamv_the</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">bot_vs_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bot_omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bot_omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bot_vs_time</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">bot_vs_t</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bot_vs_time</span><span class="p">,</span> <span class="n">bot_omega_phase</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEload_coslinear</span><span class="p">(</span><span class="n">bot_vs_t</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEload_linear</span><span class="p">(</span><span class="n">bot_vs_t</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">z</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">zvals</span><span class="p">,</span> <span class="n">pseudo_k</span><span class="p">):</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">z</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">z</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">theta_zero_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">theta</span><span class="p">[</span><span class="n">theta_zero_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="c1">#                E_Igamv_the += (E*np.dot(Igamv, theta)).T</span>
                <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">E_Igamv_the</span><span class="p">,</span> <span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Igamv</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">E_Igamv_the</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>

    <span class="c1">#theta is 1d array, Igamv is nieg by neig array, np.dot(Igamv, theta)</span>
    <span class="c1">#and np.dot(theta, Igamv) will give differetn 1d arrays.</span>
    <span class="c1">#Basically np.dot(Igamv, theta) gives us what we want i.e.</span>
    <span class="c1">#theta was treated as a column array.  The alternative</span>
    <span class="c1">#np.dot(theta, Igamv) would have treated theta as a row vector.</span>
    <span class="k">return</span> <span class="n">E_Igamv_the</span></div>


<div class="viewcode-block" id="dim1sin_E_Igamv_the_deltamag_linear"><a class="viewcode-back" href="../../../api/geotecha.speccon.speccon1d.html#geotecha.speccon.speccon1d.dim1sin_E_Igamv_the_deltamag_linear">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_E_Igamv_the_deltamag_linear</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
                                        <span class="n">eigs</span><span class="p">,</span>
                                        <span class="n">tvals</span><span class="p">,</span>
                                        <span class="n">Igamv</span><span class="p">,</span>
                                        <span class="n">zvals</span><span class="p">,</span>
                                        <span class="n">pseudo_k</span><span class="p">,</span>
                                        <span class="n">mag_vs_time</span><span class="p">,</span>
                                        <span class="n">omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">dT</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                        <span class="n">theta_zero_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">implementation</span><span class="o">=</span><span class="s1">&#39;vectorized&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate E and theta parts and assemble E_Igamv_the matrix</span>
<span class="sd">    for loading terms of the form delta(Z-Zd)*mag(t) where mag is</span>
<span class="sd">    piecewise linear in time multiplied by cos(omega * t + phase).</span>


<span class="sd">    Make the E*inverse(gam*v)*theta part of solution</span>
<span class="sd">    u(Z,t)=phi*v*E*inverse(gam*v)*theta for terms of the form</span>
<span class="sd">    k*delta(Z-Zd)*mag(t).</span>
<span class="sd">    The contribution of each `mag_vs_time`-`omega_phase` pairing and each zval</span>
<span class="sd">    are superposed. The result is an array</span>
<span class="sd">    of size (neig, len(tvals)). So each column is the are the column vector</span>
<span class="sd">    E*inverse(gam*v)*theta calculated at each output time.  This will allow</span>
<span class="sd">    us later to do u(Z,t) = phi*v*E_Igamv_the.</span>

<span class="sd">    Uses sin(m*Z) in the calculation of theta.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    drn : [0,1]</span>
<span class="sd">        Drainage condition,</span>
<span class="sd">        drn=0 for Pervious top pervious bottom (PTPB).</span>
<span class="sd">        drn=1 for Pervious top impoervious bottom (PTIB).</span>
<span class="sd">    m : ``list`` of ``float``</span>
<span class="sd">        Eigenvalues of BVP, the m in sin(m*Z). Generate with</span>
<span class="sd">        geotecha.speccon.m_from_sin_mx.</span>
<span class="sd">    eigs : 1d numpy.ndarray</span>
<span class="sd">        List of eigenvalues of the spectral matrix i.e. Eigenvalues of the</span>
<span class="sd">        square Igam_psi matrix.</span>
<span class="sd">    tvals : 1d numpy.ndarray`</span>
<span class="sd">        List of time values to evaluate E matrix at.</span>
<span class="sd">    Igamv : ndarray</span>
<span class="sd">        Speccon matrix.  Igamv = inverse of [gam * v])</span>
<span class="sd">    zvals : list of float</span>
<span class="sd">        z values defining each delta function, zd.</span>
<span class="sd">    pseudo_k : list of float</span>
<span class="sd">        Coefficients to multiply each delta function by.</span>
<span class="sd">    dT : ``float``, optional</span>
<span class="sd">        Time factor multiple for numerical convieniece. Default dT=1.0.</span>
<span class="sd">    theta_zero_indexes : slice/list etc., optional</span>
<span class="sd">        A slice object, list, etc that can be used for numpy fancy indexing.</span>
<span class="sd">        Any specified index of the theta vector will be set to zero.  This is</span>
<span class="sd">        useful when using the spectral method with block matrices and the</span>
<span class="sd">        loading term only refers to a subset of the equations.  When using</span>
<span class="sd">        block matrices m should be the same size as the block matrix.</span>
<span class="sd">        Default theta_zero_indexes=None i.e. no elements of theta will be</span>
<span class="sd">        set to zero.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    E_Igamv_the : ndarray</span>
<span class="sd">        Loading matrix of size (neig, len(tvals)).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Assuming the loads are formulated as the product of separate time and depth</span>
<span class="sd">    dependant functions as well as a cyclic component:</span>

<span class="sd">    .. math:: \\sigma\\left({Z,t}\\right)=</span>
<span class="sd">                \\sigma\\left({Z}\\right)</span>
<span class="sd">                \\sigma\\left({t}\\right)</span>
<span class="sd">                \\cos\\left(\\omega t + \\phi\\right)</span>

<span class="sd">    the solution to the consolidation equation using the spectral method has</span>
<span class="sd">    the form:</span>

<span class="sd">    .. math:: u\\left(Z,t\\right)=</span>
<span class="sd">                \\mathbf{\\phi v E}</span>
<span class="sd">                \\left(\\mathbf{\\Gamma v}\\right)^{-1}</span>
<span class="sd">                \\mathbf{\\theta}</span>

<span class="sd">    This function calculates :math:`\\mathbf{E}\\left(\\mathbf{\\Gamma v}\\right)^{-1}\\mathbf{\\theta}`</span>
<span class="sd">    for terms of the following form:</span>

<span class="sd">    .. math:: k_{\\textrm{pseudo}}</span>
<span class="sd">              \\delta\\left({Z-Z_d}\\right)</span>
<span class="sd">              \\sigma\\left({t}\\right)</span>

<span class="sd">    It is assumed that :math:`\\sigma\\left({t}\\right)` is piecewise linear</span>
<span class="sd">    in time with a cyclic component, and that multiple functions are</span>
<span class="sd">    superposed.</span>


<span class="sd">    For this particular function the :math:`\\mathbf{\\theta}` vector for</span>
<span class="sd">    each load is given by:</span>

<span class="sd">    .. math:: \\mathbf{\\theta}_{i}=</span>
<span class="sd">                \\int_{0}^1{</span>
<span class="sd">                  k_{\\textrm{pseudo}}</span>
<span class="sd">                  \\delta\\left({Z-Z_d}\\right)</span>
<span class="sd">                  \\phi_i\\,dZ}</span>


<span class="sd">    The :math:`\\mathbf{E}` matrix for each load is given by:</span>

<span class="sd">    .. math:: \\mathbf{E}_{i,j}=</span>
<span class="sd">                \\int_{0}^{t_j}{</span>
<span class="sd">                  {\\cos\\left(\\omega\\tau+\\textrm{phase}\\right)}</span>
<span class="sd">                  {\\sigma\\left(\\tau\\right)}</span>
<span class="sd">                  {\\exp\\left({(dT\\left(t-\\tau\\right)\\lambda_i}\\right)}</span>
<span class="sd">                  \\,d\\tau}</span>


<span class="sd">    where</span>

<span class="sd">     - :math:`\\lambda_i` is the `ith` eigenvalue of the problem,</span>
<span class="sd">     - :math:`dT` is a time factor for numerical convienience,</span>
<span class="sd">     - :math:`\\sigma\left(\\tau\\right)` is the piecewise linear time</span>
<span class="sd">       dependant load.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">E_Igamv_the</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tvals</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">mag_vs_time</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">z</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">mag_vs_t</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">zvals</span><span class="p">,</span> <span class="n">pseudo_k</span><span class="p">,</span> <span class="n">mag_vs_time</span><span class="p">,</span> <span class="n">omega_phase</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mag_vs_t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">z</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">theta_zero_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">theta</span><span class="p">[</span><span class="n">theta_zero_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEload_coslinear</span><span class="p">(</span><span class="n">mag_vs_t</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEload_linear</span><span class="p">(</span><span class="n">mag_vs_t</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
        <span class="n">E_Igamv_the</span> <span class="o">+=</span> <span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Igamv</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>


    <span class="k">return</span> <span class="n">E_Igamv_the</span></div>


<div class="viewcode-block" id="dim1sin_E_Igamv_the_aDmagDt_bilinear"><a class="viewcode-back" href="../../../api/geotecha.speccon.speccon1d.html#geotecha.speccon.speccon1d.dim1sin_E_Igamv_the_aDmagDt_bilinear">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_E_Igamv_the_aDmagDt_bilinear</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
                                         <span class="n">eigs</span><span class="p">,</span>
                                         <span class="n">tvals</span><span class="p">,</span>
                                         <span class="n">Igamv</span><span class="p">,</span>
                                         <span class="n">a</span><span class="p">,</span>
                                         <span class="n">mag_vs_depth</span><span class="p">,</span>
                                         <span class="n">mag_vs_time</span><span class="p">,</span>
                                         <span class="n">omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">dT</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                         <span class="n">theta_zero_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">implementation</span><span class="o">=</span><span class="s1">&#39;vectorized&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate E and theta parts and assemble E_Igamv_the matrix</span>
<span class="sd">    for loading terms of the form a(Z) * D[mag(t, Z),t] where mag is</span>
<span class="sd">    piecewise linear in depth and time and multiplied by cos(omega * t + phase).</span>


<span class="sd">    Make the E*inverse(gam*v)*theta part of solution</span>
<span class="sd">    u(Z,t)=phi*v*E*inverse(gam*v)*theta for terms of the form</span>
<span class="sd">    a(Z) * D[mag(t, Z),t].</span>
<span class="sd">    The contribution of each `mag_vs_time`-`omega_phase` pairing and</span>
<span class="sd">    are superposed. The result is an array</span>
<span class="sd">    of size (neig, len(tvals)). So each column is the column vector</span>
<span class="sd">    E*inverse(gam*v)*theta calculated at each output time.  This will allow</span>
<span class="sd">    us later to do u(Z,t) = phi*v*E_Igamv_the.</span>


<span class="sd">    Uses sin(m*z) in the calculation of theta.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    drn : [0,1]</span>
<span class="sd">        Drainage condition,</span>
<span class="sd">        drn=0 for Pervious top pervious bottom (PTPB).</span>
<span class="sd">        drn=1 for Pervious top impoervious bottom (PTIB).</span>
<span class="sd">    m : ``list`` of ``float``</span>
<span class="sd">        Eigenvalues of BVP, the m in sin(m*Z). Generate with</span>
<span class="sd">        geotecha.speccon.m_from_sin_mx.</span>
<span class="sd">    eigs : 1d numpy.ndarray</span>
<span class="sd">        List of eigenvalues of the spectral matrix i.e. Eigenvalues of the</span>
<span class="sd">        square Igam_psi matrix.</span>
<span class="sd">    tvals : 1d numpy.ndarray`</span>
<span class="sd">        List of time values to evaluate E matrix at.</span>
<span class="sd">    Igamv : ndarray</span>
<span class="sd">        Speccon matrix.  Igamv = inverse of [gam * v])</span>
<span class="sd">    a : PolyLine</span>
<span class="sd">        Piewcewise linear function.  e.g. for 1d consolidation surcharge</span>
<span class="sd">        loading term is mv*D[sigma(z, t), t] so `a` would be mv.</span>
<span class="sd">    dT : ``float``, optional</span>
<span class="sd">        Time factor multiple for numerical convieniece. Default dT=1.0.</span>
<span class="sd">    theta_zero_indexes : slice/list etc., optional</span>
<span class="sd">        A slice object, list, etc that can be used for numpy fancy indexing.</span>
<span class="sd">        Any specified index of the theta vector will be set to zero.  This is</span>
<span class="sd">        useful when using the spectral method with block matrices and the</span>
<span class="sd">        loading term only refers to a subset of the equations.  When using</span>
<span class="sd">        block matrices m should be the same size as the block matrix.</span>
<span class="sd">        Default theta_zero_indexes=None i.e. no elements of theta will be</span>
<span class="sd">        set to zero.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    E_Igamv_the : ndarray</span>
<span class="sd">        Loading matrix of size (neig, len(tvals)).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Assuming the loads are formulated as the product of separate time and depth</span>
<span class="sd">    dependant functions as well as a cyclic component:</span>

<span class="sd">    .. math:: \\sigma\\left({Z,t}\\right)=</span>
<span class="sd">                \\sigma\\left({Z}\\right)</span>
<span class="sd">                \\sigma\\left({t}\\right)</span>
<span class="sd">                \\cos\\left(\\omega t + \\phi\\right)</span>

<span class="sd">    the solution to the consolidation equation using the spectral method has</span>
<span class="sd">    the form:</span>

<span class="sd">    .. math:: u\\left(Z,t\\right)=</span>
<span class="sd">                \\mathbf{\\phi v E}</span>
<span class="sd">                \\left(\\mathbf{\\Gamma v}\\right)^{-1}</span>
<span class="sd">                \\mathbf{\\theta}</span>


<span class="sd">    This function calculates :math:`\\mathbf{E}\\left(\\mathbf{\\Gamma v}\\right)^{-1}\\mathbf{\\theta}`</span>
<span class="sd">    for terms of the following form:</span>


<span class="sd">    .. math:: a\\left({Z}\\right)\\frac{\\partial \\sigma}{\\partial t}</span>

<span class="sd">    It is assumed that :math:`\\sigma\\left({t}\\right)` is piecewise linear</span>
<span class="sd">    in time with a cyclic component, and that multiple functions are</span>
<span class="sd">    superposed.  Also :math:`a\\left(Z\\right)`</span>
<span class="sd">    is a piecewise linear function with respect to :math:`Z`.</span>


<span class="sd">    For this particular function the :math:`\\mathbf{\\theta}` vector for</span>
<span class="sd">    each load is given by:</span>

<span class="sd">    .. math:: \\mathbf{\\theta}_{i}=</span>
<span class="sd">                \\int_{0}^1{</span>
<span class="sd">                  {a\\left(Z\\right)}</span>
<span class="sd">                  {\\sigma\\left(Z\\right)}</span>
<span class="sd">                  \\phi_i\\,dZ}</span>


<span class="sd">    The :math:`\\mathbf{E}` matrix for each load is given by:</span>

<span class="sd">    .. math:: \\mathbf{E}_{i,j}=</span>
<span class="sd">                \\int_{0}^{t_j}{</span>
<span class="sd">                  \\frac{d{</span>
<span class="sd">                    {\\cos\\left(\\omega\\tau+\\textrm{phase}\\right)}</span>
<span class="sd">                    \\sigma\\left(\\tau\\right)}}</span>
<span class="sd">                    {d\\tau}</span>
<span class="sd">                  {\\exp\\left({(dT\\left(t-\\tau\\right)\\lambda_i}\\right)}</span>
<span class="sd">                  \\,d\\tau}</span>


<span class="sd">    where</span>

<span class="sd">     - :math:`\\lambda_i` is the `ith` eigenvalue of the problem,</span>
<span class="sd">     - :math:`dT` is a time factor for numerical convienience,</span>
<span class="sd">     - :math:`\\sigma\left(\\tau\\right)` is the piecewise linear time</span>
<span class="sd">       dependant load.</span>


<span class="sd">    Note that the listed equations above are in terms of normalised depth Z,</span>
<span class="sd">    with depth integrations between [0, 1].  However, IF YOU KNOW WHAT YOU</span>
<span class="sd">    ARE DOING the integrations can be done using non-normalised depths.</span>
<span class="sd">    The first z value in the piecewise definition a(z) must still be 0</span>
<span class="sd">    however the end point for integration will be the final z value in the</span>
<span class="sd">    definition of a(z).  If you are doing this then your `m` values will</span>
<span class="sd">    include the normalising Factor. e.g. m = [pi/2/H, 3*pi/2/H] and a(z) is</span>
<span class="sd">    defined in two layers [0, z1], [z1, zend] as opposed to</span>
<span class="sd">    m = [pi/2, 3*pi/2] and a(Z) is two layers [0, z1/H], [z1/H, zend/H].</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">E_Igamv_the</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tvals</span><span class="p">)))</span>


    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="n">mag_vs_depth</span><span class="p">,</span> <span class="n">mag_vs_time</span><span class="p">]])</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">mag_vs_time</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">mag_vs_t</span><span class="p">,</span> <span class="n">mag_vs_z</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mag_vs_time</span><span class="p">,</span> <span class="n">mag_vs_depth</span><span class="p">,</span> <span class="n">omega_phase</span><span class="p">):</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">mag_vs_z</span> <span class="o">=</span> <span class="n">pwise</span><span class="o">.</span><span class="n">polyline_make_x_common</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mag_vs_z</span><span class="p">)</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pdim1sin_ab_linear</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">mag_vs_z</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">theta_zero_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">theta</span><span class="p">[</span><span class="n">theta_zero_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEDload_coslinear</span><span class="p">(</span><span class="n">mag_vs_t</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEDload_linear</span><span class="p">(</span><span class="n">mag_vs_t</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>


            <span class="c1">#theta is 1d array, Igamv is nieg by neig array, np.dot(Igamv, theta)</span>
            <span class="c1">#and np.dot(theta, Igamv) will give differetn 1d arrays.</span>
            <span class="c1">#Basically np.dot(Igamv, theta) gives us what we want i.e.</span>
            <span class="c1">#theta was treated as a column array.  The alternative</span>
            <span class="c1">#np.dot(theta, Igamv) would have treated theta as a row vector.</span>
            <span class="n">E_Igamv_the</span> <span class="o">+=</span> <span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Igamv</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">E_Igamv_the</span></div>


<div class="viewcode-block" id="dim1sin_E_Igamv_the_abmag_bilinear"><a class="viewcode-back" href="../../../api/geotecha.speccon.speccon1d.html#geotecha.speccon.speccon1d.dim1sin_E_Igamv_the_abmag_bilinear">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_E_Igamv_the_abmag_bilinear</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
                                       <span class="n">eigs</span><span class="p">,</span>
                                       <span class="n">tvals</span><span class="p">,</span>
                                       <span class="n">Igamv</span><span class="p">,</span>
                                       <span class="n">a</span><span class="p">,</span>
                                       <span class="n">b</span><span class="p">,</span>
                                       <span class="n">mag_vs_depth</span><span class="p">,</span>
                                       <span class="n">mag_vs_time</span><span class="p">,</span>
                                       <span class="n">omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                       <span class="n">dT</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                       <span class="n">theta_zero_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                       <span class="n">implementation</span><span class="o">=</span><span class="s1">&#39;vectorized&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate E and theta parts and assemble E_Igamv_the matrix</span>
<span class="sd">    for loading terms of the form a(Z)*b(Z)*mag(t, Z) where mag is</span>
<span class="sd">    piecewise linear in depth and time and multiplied by cos(omega * t + phase).</span>


<span class="sd">    Make the E*inverse(gam*v)*theta part of solution u=phi*v*E*inverse(gam*v)*theta.</span>
<span class="sd">    The contribution of each `mag_vs_time`-`mag_vs_depth`-`omega_phase` pair are superposed.</span>
<span class="sd">    The result is an array</span>
<span class="sd">    of size (neig, len(tvals)). So the columns are the column array</span>
<span class="sd">    E*inverse(gam*v)*theta calculated at each output time.  This will allow</span>
<span class="sd">    us later to do u = phi*v*E_Igamv_the</span>

<span class="sd">    Uses sin(m*z) in the calculation of theta.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : ``list`` of ``float``</span>
<span class="sd">        eigenvlaues of BVP. generate with geoteca.speccon.m_from_sin_mx</span>
<span class="sd">    eigs : 1d numpy.ndarray</span>
<span class="sd">        list of eigenvalues</span>
<span class="sd">    tvals : 1d numpy.ndarray`</span>
<span class="sd">        list of time values to calculate integral at</span>
<span class="sd">    Igamv : ndarray</span>
<span class="sd">        speccon matrix</span>
<span class="sd">    a : PolyLine</span>
<span class="sd">        Piewcewise linear function.  e.g. for 1d consolidation vacuum term is</span>
<span class="sd">        kh*et*w(z,t) so a would be `kh`, `b` would be `et`</span>
<span class="sd">    b : PolyLine</span>
<span class="sd">        Piewcewise linear function.  e.g. for 1d consolidation vacuum term is</span>
<span class="sd">        kh*et*w(z,t) so a would be `kh`, `b` would be `et`</span>
<span class="sd">    mag_vs_depth : list of PolyLine</span>
<span class="sd">        Piecewise linear magnitude  vs depth.</span>
<span class="sd">    mag_vs_time : list of PolyLine</span>
<span class="sd">        Piecewise linear magnitude vs time</span>
<span class="sd">    omega_phase : list of 2 element tuples, optional</span>
<span class="sd">        (omega, phase) for use in cos(omega * t + phase) * mag_vs_time</span>
<span class="sd">        if omega_phase is None then mag_vs_time will not be multiplied by a</span>
<span class="sd">        cosine.  If any element of omega_phase is None then in that particular</span>
<span class="sd">        loading combo, mag_vs_time will not be multiplied by a cosine.</span>
<span class="sd">    dT : ``float``, optional</span>
<span class="sd">        time factor multiple (default = 1.0)</span>
<span class="sd">    theta_zero_indexes : slice/list etc., optional=None</span>
<span class="sd">        a slice object, list, etc that can be used for numpy fancy indexing.</span>
<span class="sd">        Any specified index of the theta vector will be set to zero.  This is</span>
<span class="sd">        useful when using the spectral method with block matrices and the</span>
<span class="sd">        loading term only refers to a subset of the equations.  When using</span>
<span class="sd">        block matrices m should be the same size as the block matrix.</span>
<span class="sd">        default=None i.e. no elements of theta will be set to zero.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    E_Igamv_the: ndarray</span>
<span class="sd">        loading matrix</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Assuming the loads are formulated as the product of separate time and depth</span>
<span class="sd">    dependant functions as well as a cyclic component:</span>

<span class="sd">    .. math:: \\sigma\\left({Z,t}\\right)=\\sigma\\left({Z}\\right)\\sigma\\left({t}\\right)\\cos\\left(\\omega t + \\phi\\right)</span>

<span class="sd">    the solution to the consolidation equation using the spectral method has</span>
<span class="sd">    the form:</span>

<span class="sd">    .. math:: u\\left(Z,t\\right)=\\mathbf{\\Phi v E}\\left(\\mathbf{\\Gamma v}\\right)^{-1}\\mathbf{\\theta}</span>

<span class="sd">    In this instance :math:`\\sigma\\left({Z}\\right)`</span>
<span class="sd">    and :math:`\\sigma\\left({t}\\right)` are piecewise linear in depth and</span>
<span class="sd">    time (hence the &#39;bilinear&#39; in the function name) there is also a cyclic</span>
<span class="sd">    component.</span>

<span class="sd">    `dim1sin_E_Igamv_the_abmag_bilinear` will calculate</span>
<span class="sd">    :math:`\\mathbf{E}\\left(\\mathbf{\\Gamma v}\\right)^{-1}\\mathbf{\\theta}`</span>
<span class="sd">    for terms with the form:</span>

<span class="sd">    .. math:: a\\left({z}\\right)b\\left({z}\\right)\\frac{\\partial\\sigma\\left({Z,t}\\right)}{\\partial t}</span>

<span class="sd">    where :math:`a\\left(z\\right)`, :math:`b\\left(z\\right)` are</span>
<span class="sd">    piecewise linear functions w.r.t. :math:`z`.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">E_Igamv_the</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tvals</span><span class="p">)))</span>


    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="n">mag_vs_depth</span><span class="p">,</span> <span class="n">mag_vs_time</span><span class="p">]])</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">mag_vs_time</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">mag_vs_t</span><span class="p">,</span> <span class="n">mag_vs_z</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mag_vs_time</span><span class="p">,</span> <span class="n">mag_vs_depth</span><span class="p">,</span> <span class="n">omega_phase</span><span class="p">):</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">,</span> <span class="n">mag_vs_z</span> <span class="o">=</span> <span class="n">pwise</span><span class="o">.</span><span class="n">polyline_make_x_common</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">mag_vs_z</span><span class="p">)</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pdim1sin_abc_linear</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">mag_vs_z</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">theta_zero_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">theta</span><span class="p">[</span><span class="n">theta_zero_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEload_coslinear</span><span class="p">(</span><span class="n">mag_vs_t</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pEload_linear</span><span class="p">(</span><span class="n">mag_vs_t</span><span class="p">,</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>

            <span class="c1">#theta is 1d array, Igamv is nieg by neig array, np.dot(Igamv, theta)</span>
            <span class="c1">#and np.dot(theta, Igamv) will give differetn 1d arrays.</span>
            <span class="c1">#Basically np.dot(Igamv, theta) gives us what we want i.e.</span>
            <span class="c1">#theta was treated as a column array.  The alternative</span>
            <span class="c1">#np.dot(theta, Igamv) would have treated theta as a row vector.</span>
<span class="c1">#            E_Igamv_the += (E*np.dot(Igamv, theta)).T</span>
            <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">E_Igamv_the</span><span class="p">,</span> <span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Igamv</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">E_Igamv_the</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">E_Igamv_the</span></div>


<div class="viewcode-block" id="dim1sin_foft_Ipsiw_the_BC_D_aDf_linear"><a class="viewcode-back" href="../../../api/geotecha.speccon.speccon1d.html#geotecha.speccon.speccon1d.dim1sin_foft_Ipsiw_the_BC_D_aDf_linear">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_foft_Ipsiw_the_BC_D_aDf_linear</span><span class="p">(</span><span class="n">drn</span><span class="p">,</span>
                                           <span class="n">m</span><span class="p">,</span>
                                           <span class="n">eigs</span><span class="p">,</span>
                                           <span class="n">tvals</span><span class="p">,</span>
                                           <span class="n">Ipsiw</span><span class="p">,</span>
                                           <span class="n">a</span><span class="p">,</span>
                                           <span class="n">top_vs_time</span><span class="p">,</span>
                                           <span class="n">bot_vs_time</span><span class="p">,</span>
                                           <span class="n">top_omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                           <span class="n">bot_omega_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                           <span class="n">theta_zero_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the f(t) and theta parts and assemble the foft_Ipsiw_the</span>
<span class="sd">    matrix that arises from homgenising D[a(Z)*D[u(Z, t),Z],Z] terms with</span>
<span class="sd">    non_zero top and bottom boundary conditions when modelling</span>
<span class="sd">    drains/wells/columns with finite permeability.</span>

<span class="sd">    When accounting for non-zero boundary conditions we homogenise the</span>
<span class="sd">    governing equation by letting u(Z,t) = v(Z,t) + utop(t)*(1-Z) + ubot(t)*Z</span>
<span class="sd">    and solving for v(Z, t).  For some problems the homogenisation process</span>
<span class="sd">    produces an additional term that has t be added to the usual solution of</span>
<span class="sd">    v(Z,t)=phi*v*E*inverse(gam*v)*theta</span>
<span class="sd">    i.e. v(Z,t)=phi*v*E*inverse(gam*v)*theta + f(t)*Ipsiw*theta</span>
<span class="sd">    This function calculates the f(t) and theta parts of the second term and</span>
<span class="sd">    then assembles the foft_Ipsiw_the matrix. These parts arise</span>
<span class="sd">    by subbing the boundary conditions into into governing equation terms of</span>
<span class="sd">    the form D[a(Z)*D[u(Z, t),Z],Z].</span>


<span class="sd">    Uses sin(m*Z) in the calculation of theta.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    drn : [0,1]</span>
<span class="sd">        Drainage condition,</span>
<span class="sd">        drn=0 for Pervious top pervious bottom (PTPB).</span>
<span class="sd">        drn=1 for Pervious top impoervious bottom (PTIB).</span>
<span class="sd">    m : ``list`` of ``float``</span>
<span class="sd">        Eigenvalues of BVP, the m in sin(m*Z). Generate with</span>
<span class="sd">        geotecha.speccon.m_from_sin_mx.</span>
<span class="sd">    eigs : 1d numpy.ndarray</span>
<span class="sd">        List of eigenvalues of the spectral matrix i.e. Eigenvalues of the</span>
<span class="sd">        square Igam_psi matrix.</span>
<span class="sd">    tvals : 1d numpy.ndarray`</span>
<span class="sd">        List of time values to evaluate E matrix at.</span>
<span class="sd">    Ipsiw : ndarray, square matrix</span>
<span class="sd">        Speccon matrix.  Ipsiw was originally</span>
<span class="sd">        formulated/denoted for vertical peremability term in the well</span>
<span class="sd">        resistance flow equation for vertical drain consolidatoin with</span>
<span class="sd">        well resistance.  It is different, but still a square matrix, for</span>
<span class="sd">        the stone column consolidation problem.  As long as you know what you</span>
<span class="sd">        are doing Ipsiw can be any appropriate square matrix.</span>
<span class="sd">    a : PolyLine</span>
<span class="sd">        Piewcewise linear function.  e.g. for 1d consolidation surcharge</span>
<span class="sd">        radial draiange term is D[kv(z)*D[u(Z,t), Z],Z] so `a` would be kv.</span>
<span class="sd">        be et.</span>
<span class="sd">    top_vs_time, bot_vs_time : list of PolyLine</span>
<span class="sd">        Piecewise linear magnitude vs time for the top and bottom boundary.</span>
<span class="sd">        Use ``None`` if there is no variation.</span>
<span class="sd">    top_omega_phase, bot_omega_phase : list of 2 element tuples, optional</span>
<span class="sd">        (omega, phase) for use in cos(omega * t + phase) * mag_vs_time</span>
<span class="sd">        if omega_phase is None then mag_vs_time will not be multiplied by a</span>
<span class="sd">        cosine.  If any element of omega_phase is None then in that particular</span>
<span class="sd">        loading combo, mag_vs_time will not be multiplied by a cosine.</span>
<span class="sd">    dT : ``float``, optional</span>
<span class="sd">        Time factor multiple for numerical convieniece. Default dT=1.0.</span>
<span class="sd">    theta_zero_indexes : slice/list etc., optional</span>
<span class="sd">        A slice object, list, etc that can be used for numpy fancy indexing.</span>
<span class="sd">        Any specified index of the theta vector will be set to zero.  This is</span>
<span class="sd">        useful when using the spectral method with block matrices and the</span>
<span class="sd">        loading term only refers to a subset of the equations.  When using</span>
<span class="sd">        block matrices m should be the same size as the block matrix.</span>
<span class="sd">        Default theta_zero_indexes=None i.e. no elements of theta will be</span>
<span class="sd">        set to zero.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    foft_Ipsiw_the: ndarray</span>
<span class="sd">        Additional homgenising term of size (neig, len(t)).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Assuming the loads are formulated as the product of separate time and depth</span>
<span class="sd">    dependant functions as well as a cyclic component:</span>

<span class="sd">    .. math:: \\sigma\\left({Z,t}\\right)=</span>
<span class="sd">                \\sigma\\left({Z}\\right)</span>
<span class="sd">                \\sigma\\left({t}\\right)</span>
<span class="sd">                \\cos\\left(\\omega t + \\phi\\right)</span>

<span class="sd">    the solution to consolidation equation using the spectral method has a</span>
<span class="sd">    similar form to the following:</span>

<span class="sd">    .. math:: u\\left(Z,t\\right)=</span>
<span class="sd">                \\mathbf{\\phi} \\mathbf{v} \\mathbf{E}</span>
<span class="sd">                \\left(\\mathbf{\\Gamma v}\\right)^{-1}</span>
<span class="sd">                \\mathbf{\\theta}</span>

<span class="sd">    When we consider non-zero boundary conditions, additional loading terms are</span>
<span class="sd">    created when we sub in the following into the original governing equation.</span>

<span class="sd">    .. math:: u\\left({Z,t}\\right)=</span>
<span class="sd">                v\\left({Z,t}\\right) +</span>
<span class="sd">                u_{top}\\left({t}\\right)\\left({1-Z}\\right) +</span>
<span class="sd">                u_{bot}\\left({b}\\right)Z</span>

<span class="sd">    As well as loading terms the process may produce an extra term to be</span>
<span class="sd">    added to the final solution of the following form:</span>

<span class="sd">    .. math::   \\mathbf{\\phi}</span>
<span class="sd">                \\sigma\\left({t}\\right)</span>
<span class="sd">                \\mathbf{\\psi}_{w}^{1}</span>
<span class="sd">                \\mathbf{\\theta}_w</span>

<span class="sd">    There are actually two of these terms one</span>
<span class="sd">    for the top boundary condition and one for the bottom boundary condition.</span>

<span class="sd">    This function calculates :math:`\\sigma\\left({t}\\right)\\mathbf{\\psi}_{w}^{-1}\\mathbf{\\theta}_w`</span>

<span class="sd">    when substitutions are made in terms of the following form:</span>

<span class="sd">    .. math:: \\frac{\\partial}{\\partial Z}</span>
<span class="sd">                \\left(</span>
<span class="sd">                  {a\\left({Z}\\right)</span>
<span class="sd">                  \\frac{\\partial u\\left({Z,t}\\right)}{\\partial Z}}</span>
<span class="sd">                \\right)</span>


<span class="sd">    It is assumed that :math:`u_{top}\\left({t}\\right)` and</span>
<span class="sd">    :math:`u_{bot}\\left({t}\\right)` are piecewise linear</span>
<span class="sd">    in time with a cyclic component, and that multiple functions are</span>
<span class="sd">    superposed.  Also :math:`a\\left(Z\\right)`</span>
<span class="sd">    is a piecewise linear function with respect to :math:`Z`</span>


<span class="sd">    For this particular function the :math:`\\mathbf{\\theta}` vector for</span>
<span class="sd">    each load is given by:</span>

<span class="sd">    .. math:: \\mathbf{\\theta}_{i}=</span>
<span class="sd">                \\int_{0}^1{</span>
<span class="sd">                  \\frac{\\partial}{\\partial Z}</span>
<span class="sd">                  \\left(</span>
<span class="sd">                    {a\\left({Z}\\right)</span>
<span class="sd">                    \\frac{\\partial \\sigma\\left({Z}\\right)}{\\partial Z}}</span>
<span class="sd">                  \\right)</span>
<span class="sd">                  f\\left({Z}\\right)</span>
<span class="sd">                  \\phi_i\\,dZ}</span>

<span class="sd">    Where :math:`f\\left({Z}\\right)` is the appropriate z-dependent term</span>
<span class="sd">    corresponding to either :math:`u_{top}` or :math:`u_{bot}` homogenisations.</span>


<span class="sd">    The time dependent function evaluated at each time produces a matrix</span>
<span class="sd">    that we will call :math:`\\mathbf{E}` (not to be confused with other E</span>
<span class="sd">    matrices) which is given by:</span>

<span class="sd">    .. math:: \\mathbf{E}_{j}=</span>
<span class="sd">                 {\\sigma\\left(t_j\\right)}</span>
<span class="sd">                 {\\cos\\left(\\omega t_j+\\textrm{phase}\\right)}</span>


<span class="sd">    Note that the listed equations above are in terms of normalised depth Z,</span>
<span class="sd">    with depth integrations between [0, 1].  However, IF YOU KNOW WHAT YOU</span>
<span class="sd">    ARE DOING the integrations can be done using non-normalised depths.</span>
<span class="sd">    The first z value in the piecewise definition a(z) must still be 0</span>
<span class="sd">    however the end point for integration will be the final z value in the</span>
<span class="sd">    definition of a(z).  If you are doing this then your `m` values will</span>
<span class="sd">    include the normalising Factor. e.g. m = [pi/2/H, 3*pi/2/H] and a(z) is</span>
<span class="sd">    defined in two layers [0, z1], [z1, zend] as opposed to</span>
<span class="sd">    m = [pi/2, 3*pi/2] and a(Z) is two layers [0, z1/H], [z1/H, zend/H].</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">foft_Ipsiw_the</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tvals</span><span class="p">)))</span>


    <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">drn</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">zdist</span> <span class="o">=</span> <span class="n">PolyLine</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">))</span>
            <span class="c1">#bot_vs_time=None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zdist</span> <span class="o">=</span> <span class="n">PolyLine</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">top_vs_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">top_omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">top_omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">top_vs_time</span><span class="p">)</span>

            <span class="n">theta</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pdim1sin_D_aDb_linear</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">zdist</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">theta_zero_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">theta</span><span class="p">[</span><span class="n">theta_zero_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">top_vs_t</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">top_vs_time</span><span class="p">,</span> <span class="n">top_omega_phase</span><span class="p">):</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">pwise</span><span class="o">.</span><span class="n">pinterp_x_y</span><span class="p">(</span><span class="n">top_vs_t</span><span class="p">,</span> <span class="n">tvals</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
                    <span class="n">E</span><span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span> <span class="o">*</span> <span class="n">tvals</span> <span class="o">+</span> <span class="n">phase</span><span class="p">)</span>
                <span class="n">foft_Ipsiw_the</span> <span class="o">+=</span> <span class="n">E</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ipsiw</span><span class="p">,</span> <span class="n">theta</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">bot_vs_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bot_omega_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bot_omega_phase</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bot_vs_time</span><span class="p">)</span>

            <span class="n">theta</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">pdim1sin_D_aDb_linear</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">PolyLine</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">x2</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">theta_zero_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">theta</span><span class="p">[</span><span class="n">theta_zero_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">bot_vs_t</span><span class="p">,</span> <span class="n">om_ph</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bot_vs_time</span><span class="p">,</span> <span class="n">bot_omega_phase</span><span class="p">):</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">pwise</span><span class="o">.</span><span class="n">pinterp_x_y</span><span class="p">(</span><span class="n">bot_vs_t</span><span class="p">,</span> <span class="n">tvals</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">om_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">om_ph</span>
                    <span class="n">E</span><span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span> <span class="o">*</span> <span class="n">tvals</span> <span class="o">+</span> <span class="n">phase</span><span class="p">)</span>
                <span class="n">foft_Ipsiw_the</span> <span class="o">+=</span> <span class="n">E</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ipsiw</span><span class="p">,</span> <span class="n">theta</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>

    <span class="c1">#theta is 1d array, Igamv is nieg by neig array, np.dot(Igamv, theta)</span>
    <span class="c1">#and np.dot(theta, Igamv) will give differetn 1d arrays.</span>
    <span class="c1">#Basically np.dot(Igamv, theta) gives us what we want i.e.</span>
    <span class="c1">#theta was treated as a column array.  The alternative</span>
    <span class="c1">#np.dot(theta, Igamv) would have treated theta as a row vector.</span>
    <span class="k">return</span> <span class="n">foft_Ipsiw_the</span></div>


<div class="viewcode-block" id="dim1sin_E_Igamv_the_mvpl"><a class="viewcode-back" href="../../../api/geotecha.speccon.speccon1d.html#geotecha.speccon.speccon1d.dim1sin_E_Igamv_the_mvpl">[docs]</a><span class="k">def</span> <span class="nf">dim1sin_E_Igamv_the_mvpl</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
                            <span class="n">eigs</span><span class="p">,</span>
                            <span class="n">tvals</span><span class="p">,</span>
                            <span class="n">Igamv</span><span class="p">,</span>
                            <span class="n">moving_loads</span><span class="p">,</span>
<span class="c1">#                            pseudo_k,</span>
<span class="c1">#                            mag_vs_time,</span>
<span class="c1">#                            omega_phase=None,</span>
                            <span class="n">dT</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                            <span class="n">theta_zero_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">implementation</span><span class="o">=</span><span class="s1">&#39;vectorized&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate E and theta parts and assemble E_Igamv_the matrix</span>
<span class="sd">    for loading terms of the form a(Z) * delta(Z-Zd)*mag(t) where mag is</span>
<span class="sd">    piecewise linear in time multiplied by cos(omega * t + phase).</span>


<span class="sd">    Make the E*inverse(gam*v)*theta part of solution</span>
<span class="sd">    u(Z,t)=phi*v*E*inverse(gam*v)*theta for terms of the form</span>
<span class="sd">    a(Z) * delta(Z-Zd)*mag(t).</span>
<span class="sd">    The contribution of each `mag_vs_time`-`omega_phase` pairing and each zval</span>
<span class="sd">    are superposed. The result is an array</span>
<span class="sd">    of size (neig, len(tvals)). So each column is the are the column vector</span>
<span class="sd">    E*inverse(gam*v)*theta calculated at each output time.  This will allow</span>
<span class="sd">    us later to do u(Z,t) = phi*v*E_Igamv_the.</span>

<span class="sd">    Uses sin(m*Z) in the calculation of theta.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : ``list`` of ``float``</span>
<span class="sd">        Eigenvalues of BVP, the m in sin(m*Z). Generate with</span>
<span class="sd">        geotecha.speccon.m_from_sin_mx.</span>
<span class="sd">    eigs : 1d numpy.ndarray</span>
<span class="sd">        List of eigenvalues of the spectral matrix i.e. Eigenvalues of the</span>
<span class="sd">        square Igam_psi matrix.</span>
<span class="sd">    tvals : 1d numpy.ndarray`</span>
<span class="sd">        List of time values to evaluate E matrix at.</span>
<span class="sd">    Igamv : ndarray</span>
<span class="sd">        Speccon matrix.  Igamv = inverse of [gam * v])</span>
<span class="sd">    moving_loads : list of MovingPointLoads objects</span>
<span class="sd">        List of loads to apply .</span>
<span class="sd">    dT : ``float``, optional</span>
<span class="sd">        Time factor multiple for numerical convieniece. Default dT=1.0.</span>
<span class="sd">    theta_zero_indexes : slice/list etc., optional</span>
<span class="sd">        A slice object, list, etc that can be used for numpy fancy indexing.</span>
<span class="sd">        Any specified index of the theta vector will be set to zero.  This is</span>
<span class="sd">        useful when using the spectral method with block matrices and the</span>
<span class="sd">        loading term only refers to a subset of the equations.  When using</span>
<span class="sd">        block matrices m should be the same size as the block matrix.</span>
<span class="sd">        Default theta_zero_indexes=None i.e. no elements of theta will be</span>
<span class="sd">        set to zero.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    E_Igamv_the : ndarray, dtype=complex</span>
<span class="sd">        Loading matrix of size (neig, len(tvals)).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    returns a complex array!!!</span>


<span class="sd">    Assuming the loads are formulated as the product of separate time and depth</span>
<span class="sd">    dependant functions as well as a cyclic component:</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">E_the</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">tvals</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">eigs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="c1">#axes are (t,eig,theta), they will be transposed at the end of the function.</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">theta_zero_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">avoid</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">))[</span><span class="n">theta_zero_indexes</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">avoid</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">mvpl</span> <span class="ow">in</span> <span class="n">moving_loads</span><span class="p">:</span>
        <span class="n">plines</span><span class="p">,</span> <span class="n">omega_phases</span> <span class="o">=</span> <span class="n">mvpl</span><span class="o">.</span><span class="n">convert_to_specbeam</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">mag_vs_t</span><span class="p">,</span> <span class="n">omega_phase</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">plines</span><span class="p">,</span> <span class="n">omega_phases</span><span class="p">):</span>
            <span class="n">omega</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">omega_phase</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">avoid</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">E_the</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">integ</span><span class="o">.</span><span class="n">pEload_sinlinear</span><span class="p">(</span><span class="n">mag_vs_t</span><span class="p">,</span>
                                         <span class="n">omega</span><span class="o">*</span><span class="n">mi</span><span class="p">,</span> <span class="n">phase</span><span class="o">*</span><span class="n">mi</span><span class="p">,</span>
                                         <span class="n">eigs</span><span class="p">,</span>
                                         <span class="n">tvals</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span>
                                         <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">))</span>


<span class="c1">#    if not theta_zero_indexes is None:</span>
<span class="c1">#         E_the[:, :, theta_zero_indexes] = 0.0</span>

    <span class="n">E_the</span> <span class="o">*=</span> <span class="n">Igamv</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

    <span class="n">E_Igamv_the</span> <span class="o">=</span> <span class="n">E_the</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>





<span class="c1">#    if omega_phase is None:</span>
<span class="c1">#            omega_phase = [None] * len(mag_vs_time)</span>
<span class="c1">#</span>
<span class="c1">#    for z, k, mag_vs_t, om_ph in zip(zvals, pseudo_k, mag_vs_time, omega_phase):</span>
<span class="c1">#        if mag_vs_t is None:</span>
<span class="c1">#            continue</span>
<span class="c1">#        theta = k * np.sin(z * m)</span>
<span class="c1">#        if not theta_zero_indexes is None:</span>
<span class="c1">#            theta[theta_zero_indexes] = 0.0</span>
<span class="c1">#        if not om_ph is None:</span>
<span class="c1">#            omega, phase = om_ph</span>
<span class="c1">#            E = integ.pEload_coslinear(mag_vs_t, omega, phase, eigs, tvals, dT, implementation=implementation)</span>
<span class="c1">#        else:</span>
<span class="c1">#            E = integ.pEload_linear(mag_vs_t, eigs, tvals, dT, implementation=implementation)</span>
<span class="c1">#        E_Igamv_the += (E*np.dot(Igamv, theta)).T</span>


    <span class="k">return</span> <span class="n">E_Igamv_the</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">nose</span>
    <span class="n">nose</span><span class="o">.</span><span class="n">runmodule</span><span class="p">(</span><span class="n">argv</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;nose&#39;</span><span class="p">,</span> <span class="s1">&#39;--verbosity=3&#39;</span><span class="p">,</span> <span class="s1">&#39;--with-doctest&#39;</span><span class="p">])</span>
<span class="c1">#    nose.runmodule(argv=[&#39;nose&#39;, &#39;--verbosity=3&#39;])</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2014, Rohan Walker.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>