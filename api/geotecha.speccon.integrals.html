
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>integrals &#8212; geotecha 0.2.1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="integrals_generate_code" href="geotecha.speccon.integrals_generate_code.html" />
    <link rel="prev" title="speccon" href="geotecha.speccon.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../index.html"><img src="../_static/logo.png" border="0" alt="py4sci"/></a>
</div>



      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">integrals</a><ul>
<li><a class="reference internal" href="#function-summary">Function summary</a></li>
<li><a class="reference internal" href="#module-geotecha.speccon.integrals">Module listing</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="geotecha.html">geotecha</a><ul>
  <li><a href="geotecha.speccon.html">speccon</a><ul>
      <li>Previous: <a href="geotecha.speccon.html" title="previous chapter">speccon</a></li>
      <li>Next: <a href="geotecha.speccon.integrals_generate_code.html" title="next chapter">integrals_generate_code</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/api/geotecha.speccon.integrals.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="integrals">
<h1>integrals<a class="headerlink" href="#integrals" title="Permalink to this headline">¶</a></h1>
<div class="section" id="function-summary">
<h2>Function summary<a class="headerlink" href="#function-summary" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#geotecha.speccon.integrals.EDload_coslinear" title="geotecha.speccon.integrals.EDload_coslinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EDload_coslinear</span></code></a>(loadtim,&nbsp;loadmag,&nbsp;omega,&nbsp;…)</td>
<td>Integration of D[cos(omega*tau+phase)*load(tau), tau] * exp(dT * eig * (t-tau)) between [0, t], where load(tau) is piecewise linear.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#geotecha.speccon.integrals.EDload_linear" title="geotecha.speccon.integrals.EDload_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EDload_linear</span></code></a>(loadtim,&nbsp;loadmag,&nbsp;eigs,&nbsp;tvals)</td>
<td>Integration of D[load(tau), tau] * exp(dT * eig * (t-tau)) between [0, t], where load(tau) is piecewise linear.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#geotecha.speccon.integrals.Eload_coslinear" title="geotecha.speccon.integrals.Eload_coslinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Eload_coslinear</span></code></a>(loadtim,&nbsp;loadmag,&nbsp;omega,&nbsp;…)</td>
<td>Integration of cos(omega*tau+phase)*load(tau) * exp(dT * eig * (t-tau)) between [0, t], where load(tau) is piecewise linear.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#geotecha.speccon.integrals.Eload_linear" title="geotecha.speccon.integrals.Eload_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Eload_linear</span></code></a>(loadtim,&nbsp;loadmag,&nbsp;eigs,&nbsp;tvals)</td>
<td>Integration of load(tau) * exp(dT * eig * (t-tau)) between [0, t], where load(tau) is piecewise linear.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#geotecha.speccon.integrals.Eload_sinlinear" title="geotecha.speccon.integrals.Eload_sinlinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Eload_sinlinear</span></code></a>(loadtim,&nbsp;loadmag,&nbsp;omega,&nbsp;…)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#geotecha.speccon.integrals.dim1sin" title="geotecha.speccon.integrals.dim1sin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim1sin</span></code></a>(m,&nbsp;z)</td>
<td>sin(m*z) for each combination of m and z</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#geotecha.speccon.integrals.dim1sin_DD_abDDf_linear" title="geotecha.speccon.integrals.dim1sin_DD_abDDf_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim1sin_DD_abDDf_linear</span></code></a>(m,&nbsp;at,&nbsp;ab,&nbsp;bt,&nbsp;bb,&nbsp;…)</td>
<td>Integration of sin(mi * z) * D[a(z) * b(z) D[sin(mj * z),z,2],z,2] between ztop and zbot where a(z) &amp; b(z) is piecewise linear functions of z.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#geotecha.speccon.integrals.dim1sin_D_aDb_linear" title="geotecha.speccon.integrals.dim1sin_D_aDb_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim1sin_D_aDb_linear</span></code></a>(m,&nbsp;at,&nbsp;ab,&nbsp;bt,&nbsp;bb,&nbsp;zt,&nbsp;zb)</td>
<td>Integrations of <cite>sin(mi * z) * D[a(z) * D[b(z), z], z]</cite> between ztop and zbot where a(z) is a piecewise linear function of z, and b(z) is a linear function of z.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#geotecha.speccon.integrals.dim1sin_D_aDf_linear" title="geotecha.speccon.integrals.dim1sin_D_aDf_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim1sin_D_aDf_linear</span></code></a>(m,&nbsp;at,&nbsp;ab,&nbsp;zt,&nbsp;zb[,&nbsp;…])</td>
<td>Integration of sin(mi * z) * D[a(z) * D[sin(mj * z),z],z] between ztop and zbot where a(z) is piecewise linear functions of z.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#geotecha.speccon.integrals.dim1sin_a_linear_between" title="geotecha.speccon.integrals.dim1sin_a_linear_between"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim1sin_a_linear_between</span></code></a>(m,&nbsp;at,&nbsp;ab,&nbsp;zt,&nbsp;zb,&nbsp;z)</td>
<td>Integrations of <cite>sin(mi * z) * a(z)</cite> between [z1, z2] where a(z) is a piecewise linear functions of z.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#geotecha.speccon.integrals.dim1sin_ab_linear" title="geotecha.speccon.integrals.dim1sin_ab_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim1sin_ab_linear</span></code></a>(m,&nbsp;at,&nbsp;ab,&nbsp;bt,&nbsp;bb,&nbsp;zt,&nbsp;zb)</td>
<td>Integration of sin(mi * z) * a(z) * b(z) between ztop and zbot where a(z) and b(z) are piecewise linear functions of z.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#geotecha.speccon.integrals.dim1sin_abc_linear" title="geotecha.speccon.integrals.dim1sin_abc_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim1sin_abc_linear</span></code></a>(m,&nbsp;at,&nbsp;ab,&nbsp;bt,&nbsp;bb,&nbsp;ct,&nbsp;…)</td>
<td>Integrations of sin(mi * z) * a(z) * b(z) * c(z) between ztop and zbot where a(z), b(z), c(z) are piecewise linear functions of z.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#geotecha.speccon.integrals.dim1sin_abf_linear" title="geotecha.speccon.integrals.dim1sin_abf_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim1sin_abf_linear</span></code></a>(m,&nbsp;at,&nbsp;ab,&nbsp;bt,&nbsp;bb,&nbsp;zt,&nbsp;zb)</td>
<td>Integration of sin(mi * z) * a(z) * a(z) * sin(mj * z) between ztop and zbot where a(z) is piecewise linear.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#geotecha.speccon.integrals.dim1sin_af_linear" title="geotecha.speccon.integrals.dim1sin_af_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim1sin_af_linear</span></code></a>(m,&nbsp;at,&nbsp;ab,&nbsp;zt,&nbsp;zb[,&nbsp;…])</td>
<td>Integration of sin(mi * z) * a(z) * sin(mj * z) between ztop and zbot where a(z) is piecewise linear.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#geotecha.speccon.integrals.dim1sin_avg_between" title="geotecha.speccon.integrals.dim1sin_avg_between"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim1sin_avg_between</span></code></a>(m,&nbsp;z)</td>
<td>Average of sin(m * z) between z1 and z2</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#geotecha.speccon.integrals.m_from_sin_mx" title="geotecha.speccon.integrals.m_from_sin_mx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">m_from_sin_mx</span></code></a>(i[,&nbsp;boundary])</td>
<td>Sine series eigenvalue of boundary value problem on [0, 1]</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#geotecha.speccon.integrals.pEDload_coslinear" title="geotecha.speccon.integrals.pEDload_coslinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pEDload_coslinear</span></code></a>(a,&nbsp;omega,&nbsp;phase,&nbsp;eigs,&nbsp;tvals)</td>
<td>Integration of D[cos(omega*tau+phase)*load(tau), tau] * exp(dT * eig * (t-tau)) between [0, t], where load(tau) is piecewise linear.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#geotecha.speccon.integrals.pEDload_linear" title="geotecha.speccon.integrals.pEDload_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pEDload_linear</span></code></a>(a,&nbsp;eigs,&nbsp;tvals[,&nbsp;dT])</td>
<td>Integration of D[load(tau), tau] * exp(dT * eig * (t-tau)) between [0, t], where load(tau) is piecewise linear.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#geotecha.speccon.integrals.pEload_coslinear" title="geotecha.speccon.integrals.pEload_coslinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pEload_coslinear</span></code></a>(a,&nbsp;omega,&nbsp;phase,&nbsp;eigs,&nbsp;tvals)</td>
<td>Integration of cos(omega*tau+phase)*load(tau) * exp(dT * eig * (t-tau)) between [0, t], where load(tau) is piecewise linear.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#geotecha.speccon.integrals.pEload_linear" title="geotecha.speccon.integrals.pEload_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pEload_linear</span></code></a>(a,&nbsp;eigs,&nbsp;tvals[,&nbsp;dT])</td>
<td>Integration of load(tau) * exp(dT * eig * (t-tau)) between [0, t], where load(tau) is piecewise linear.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#geotecha.speccon.integrals.pEload_sinlinear" title="geotecha.speccon.integrals.pEload_sinlinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pEload_sinlinear</span></code></a>(a,&nbsp;omega,&nbsp;phase,&nbsp;eigs,&nbsp;tvals)</td>
<td>Integration of sin(omega*tau+phase)*load(tau) * exp(dT * eig * (t-tau)) between [0, t], where load(tau) is piecewise linear.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#geotecha.speccon.integrals.pdim1sin_DD_abDDf_linear" title="geotecha.speccon.integrals.pdim1sin_DD_abDDf_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdim1sin_DD_abDDf_linear</span></code></a>(m,&nbsp;a,&nbsp;b,&nbsp;**kwargs)</td>
<td>Integration of sin(mi * z) * D[a(z) * b(z) D[sin(mj * z),z,2],z,2] between ztop and zbot where a(z) &amp; b(z) is piecewise linear functions of z.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#geotecha.speccon.integrals.pdim1sin_D_aDb_linear" title="geotecha.speccon.integrals.pdim1sin_D_aDb_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdim1sin_D_aDb_linear</span></code></a>(m,&nbsp;a,&nbsp;b,&nbsp;**kwargs)</td>
<td>Integrations of <cite>sin(mi * z) * D[a(z) * D[b(z), z], z]</cite> between ztop and zbot where a(z) is a piecewise linear function of z, and b(z) is a linear function of z.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#geotecha.speccon.integrals.pdim1sin_D_aDf_linear" title="geotecha.speccon.integrals.pdim1sin_D_aDf_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdim1sin_D_aDf_linear</span></code></a>(m,&nbsp;a,&nbsp;**kwargs)</td>
<td>Integration of sin(mi * z) * D[a(z) * D[sin(mj * z),z],z] between ztop and zbot where a(z) is piecewise linear functions of z.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#geotecha.speccon.integrals.pdim1sin_a_linear_between" title="geotecha.speccon.integrals.pdim1sin_a_linear_between"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdim1sin_a_linear_between</span></code></a>(m,&nbsp;a,&nbsp;z,&nbsp;**kwargs)</td>
<td>Integrations of <cite>sin(mi * z) * a(z)</cite> between [z1, z2] where a(z) is a piecewise linear functions of z.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#geotecha.speccon.integrals.pdim1sin_ab_linear" title="geotecha.speccon.integrals.pdim1sin_ab_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdim1sin_ab_linear</span></code></a>(m,&nbsp;a,&nbsp;b,&nbsp;**kwargs)</td>
<td>Integration of sin(mi * z) * a(z) * b(z) between ztop and zbot where a(z) and b(z) are piecewise linear functions of z.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#geotecha.speccon.integrals.pdim1sin_abc_linear" title="geotecha.speccon.integrals.pdim1sin_abc_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdim1sin_abc_linear</span></code></a>(m,&nbsp;a,&nbsp;b,&nbsp;c,&nbsp;**kwargs)</td>
<td>Integrations of sin(mi * z) * a(z) * b(z) * c(z) between ztop and zbot where a(z), b(z), c(z) are piecewise linear functions of z.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#geotecha.speccon.integrals.pdim1sin_abf_linear" title="geotecha.speccon.integrals.pdim1sin_abf_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdim1sin_abf_linear</span></code></a>(m,&nbsp;a,&nbsp;b,&nbsp;**kwargs)</td>
<td>Integration of sin(mi * z) * a(z) * a(z) * sin(mj * z) between ztop and zbot where a(z) is piecewise linear.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#geotecha.speccon.integrals.pdim1sin_af_linear" title="geotecha.speccon.integrals.pdim1sin_af_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdim1sin_af_linear</span></code></a>(m,&nbsp;a,&nbsp;**kwargs)</td>
<td>Integration of sin(mi * z) * a(z) * sin(mj * z)     between ztop and zbot where a(z) is piecewise linear.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-geotecha.speccon.integrals">
<span id="module-listing"></span><h2>Module listing<a class="headerlink" href="#module-geotecha.speccon.integrals" title="Permalink to this headline">¶</a></h2>
<p>Integrals and eigenvalues for consolidation using spectral methods.</p>
<p>Most of the functions have been generated using
geotecha.speccon.integrals_generate_code functions using sympy.</p>
<dl class="function">
<dt id="geotecha.speccon.integrals.EDload_coslinear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">EDload_coslinear</code><span class="sig-paren">(</span><em>loadtim</em>, <em>loadmag</em>, <em>omega</em>, <em>phase</em>, <em>eigs</em>, <em>tvals</em>, <em>dT=1.0</em>, <em>implementation='vectorized'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#EDload_coslinear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.EDload_coslinear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integration of D[cos(omega*tau+phase)*load(tau), tau] * exp(dT * eig * (t-tau)) between [0, t], where
load(tau) is piecewise linear.</p>
<p>Performs integrations involving a piecewise linear load.  A 2d array of
dimensions A[len(tvals), len(eigs)]
is produced where the ‘i’th row of A contains the diagonal elements of the
spectral ‘E’ matrix calculated for the time value tvals[i]. i.e. rows of
this matrix will be assembled into the diagonal matrix ‘E’ elsewhere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>loadtim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray</span></dt>
<dd><p class="first last">List of times describing load application.</p>
</dd>
<dt><strong>loadmag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray</span></dt>
<dd><p class="first last">List of load magnitudes.</p>
</dd>
<dt><strong>omega, phase</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Parameters that describe a cyclic load cos(omega * t + phase).</p>
</dd>
<dt><strong>eigs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray</span></dt>
<dd><p class="first last">List of eigenvalues.</p>
</dd>
<dt><strong>tvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray`</span></dt>
<dd><p class="first last">List of time values to calculate integral at.</p>
</dd>
<dt><strong>dT</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">float</span></code>, optional</span></dt>
<dd><p class="first last">Time factor multiple (Default dT=1.0).</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A 2d array of dimesnions A[len(tvals), len(eigs)].
The ‘i’th row of A is the diagonal elements of the spectral ‘E’ matrix
calculated for the time tvals[i].</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.pEDload_coslinear" title="geotecha.speccon.integrals.pEDload_coslinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pEDload_coslinear</span></code></a></dt>
<dd>Same function with PolyLine inputs.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.speccon.ext_integrals.edload_coslinear</span></code></dt>
<dd>Equivalent fortran function.</dd>
<dt><a class="reference internal" href="geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.EDload_coslinear_implementations" title="geotecha.speccon.integrals_generate_code.EDload_coslinear_implementations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.speccon.integrals_generate_code.EDload_coslinear_implementations</span></code></a></dt>
<dd>Generation of code for this function.</dd>
<dt><a class="reference internal" href="#geotecha.speccon.integrals.EDload_linear" title="geotecha.speccon.integrals.EDload_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EDload_linear</span></code></a></dt>
<dd>Similar function with no cosine term.</dd>
<dt><a class="reference internal" href="#geotecha.speccon.integrals.Eload_coslinear" title="geotecha.speccon.integrals.Eload_coslinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Eload_coslinear</span></code></a></dt>
<dd>Similar function but the combined loading function is not differentiated with respect to time.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Assuming the load are formulated as the product of separate time and depth
dependant functions:</p>
<div class="math notranslate nohighlight">
\[\sigma\left({Z,t}\right)=\sigma\left({Z}\right)\sigma\left({t}\right)\]</div>
<p>the solution to the consolidation equation using the spectral method has
the form:</p>
<div class="math notranslate nohighlight">
\[u\left(Z,t\right)=\mathbf{\Phi v E}\left(\mathbf{\Gamma v}\right)^{-1}\mathbf{\theta}\]</div>
<p>The matrix <span class="math notranslate nohighlight">\(E\)</span> is a time dependent diagonal matrix due to time
dependant loadings.  The version of <span class="math notranslate nohighlight">\(E\)</span> calculated here in
<cite>EDload_coslinear</cite> is from loading terms in the governing equation that are NOT
differentiated wrt <span class="math notranslate nohighlight">\(t\)</span>.
The diagonal elements of <span class="math notranslate nohighlight">\(E\)</span> are given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{E}_{i,i}=\int_{0}^t{\frac{d{{\cos\left(\omega\tau+\textrm{phase}\right)}\sigma\left(\tau\right)}}{d\tau}{\exp\left({(dT\left(t-\tau\right)\lambda_i}\right)}\,d\tau}\]</div>
<p>where</p>
<blockquote>
<div><span class="math notranslate nohighlight">\(\lambda_i\)</span> is the <cite>ith</cite> eigenvalue of the problem,
<span class="math notranslate nohighlight">\(dT\)</span> is a time factor for numerical convienience,
<span class="math notranslate nohighlight">\(\sigma\left(\tau\right)\)</span> is the time dependant portion of the loading function.</div></blockquote>
<p>When the time dependant loading term <span class="math notranslate nohighlight">\(\sigma\left(\tau\right)\)</span> is
piecewise in time. The contribution of each load segment is found by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{E}_{i,i}=\int_{t_s}^{t_f}{\frac{d{{\cos\left(\omega\tau+\textrm{phase}\right)}\sigma\left(\tau\right)}}{d\tau}\exp\left({dT\left(t-\tau\right)*\lambda_i}\right)\,d\tau}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[t_s = \min\left(t,t_{increment\:start}\right)\]</div>
<div class="math notranslate nohighlight">
\[t_f = \min\left(t,t_{increment\:end}\right)\]</div>
<p>(note that this function,`EDload_coslinear`, rather than use <span class="math notranslate nohighlight">\(t_s\)</span> and
<span class="math notranslate nohighlight">\(t_f\)</span>,
explicitly finds increments that the current time falls in, falls after,
and falls before and treates each case on it’s own.)</p>
<p>Each <span class="math notranslate nohighlight">\(t\)</span> value of interest requires a separate diagonal matrix
<span class="math notranslate nohighlight">\(E\)</span>.  To use space more efficiently and to facilitate numpy
broadcasting when using the results of the function, the diagonal elements
of <span class="math notranslate nohighlight">\(E\)</span> for each time value <cite>t</cite> value are stored in the rows of
array <span class="math notranslate nohighlight">\(A\)</span> returned by <cite>EDload_coslinear</cite>.  Thus:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{A}=\left(\begin{matrix}E_{0,0}(t_0)&amp;E_{1,1}(t_0)&amp; \cdots &amp; E_{neig-1,neig-1}(t_0)\\ E_{0,0}(t_1)&amp;E_{1,1}(t_1)&amp; \cdots &amp; E_{neig-1,neig-1}(t_1)\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots \\ E_{0,0}(t_m)&amp;E_{1,1}(t_m)&amp; \cdots &amp; E_{neig-1,neig-1}(t_m)\end{matrix}\right)\end{split}\]</div>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.EDload_linear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">EDload_linear</code><span class="sig-paren">(</span><em>loadtim</em>, <em>loadmag</em>, <em>eigs</em>, <em>tvals</em>, <em>dT=1.0</em>, <em>implementation='vectorized'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#EDload_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.EDload_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integration of D[load(tau), tau] * exp(dT * eig * (t-tau)) between
[0, t], where load(tau) is piecewise linear.</p>
<p>Performs integrations involving a piecewise linear load.  A 2d array of
dimensions A[len(tvals), len(eigs)]
is produced where the ‘i’th row of A contains the diagonal elements of the
spectral ‘E’ matrix calculated for the time value tvals[i]. i.e. rows of
this matrix will be assembled into the diagonal matrix ‘E’ elsewhere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>loadtim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray</span></dt>
<dd><p class="first last">List of times describing load application.</p>
</dd>
<dt><strong>loadmag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray</span></dt>
<dd><p class="first last">List of load magnitudes.</p>
</dd>
<dt><strong>eigs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray</span></dt>
<dd><p class="first last">List of eigenvalues.</p>
</dd>
<dt><strong>tvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray`</span></dt>
<dd><p class="first last">List of time values to calculate integral at.</p>
</dd>
<dt><strong>dT</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">float</span></code>, optional</span></dt>
<dd><p class="first last">Time factor multiple (Default dT=1.0).</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A 2d array of dimesnions A[len(tvals), len(eigs)].
The ‘i’th row of A is the diagonal elements of the spectral ‘E’ matrix
calculated for the time tvals[i].</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.pEDload_linear" title="geotecha.speccon.integrals.pEDload_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pEDload_linear</span></code></a></dt>
<dd>Same function with PolyLine inputs.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.speccon.ext_integrals.edload_linear</span></code></dt>
<dd>Equivalent fortran function.</dd>
<dt><a class="reference internal" href="geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.EDload_linear_implementations" title="geotecha.speccon.integrals_generate_code.EDload_linear_implementations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.speccon.integrals_generate_code.EDload_linear_implementations</span></code></a></dt>
<dd>Generation of code for this function.</dd>
<dt><a class="reference internal" href="#geotecha.speccon.integrals.EDload_coslinear" title="geotecha.speccon.integrals.EDload_coslinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EDload_coslinear</span></code></a></dt>
<dd>Similar function with additional cosine term.</dd>
<dt><a class="reference internal" href="#geotecha.speccon.integrals.Eload_linear" title="geotecha.speccon.integrals.Eload_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Eload_linear</span></code></a></dt>
<dd>Similar function but the time dependent loading function is not differentiated with repect to time.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Assuming the load are formulated as the product of separate time and depth
dependant functions:</p>
<div class="math notranslate nohighlight">
\[\sigma\left({Z,t}\right)=\sigma\left({Z}\right)\sigma\left({t}\right)\]</div>
<p>the solution to the consolidation equation using the spectral method has
the form:</p>
<div class="math notranslate nohighlight">
\[u\left(Z,t\right)=\mathbf{\Phi v E}\left(\mathbf{\Gamma v}\right)^{-1}\mathbf{\theta}\]</div>
<p>The matrix <span class="math notranslate nohighlight">\(E\)</span> is a time dependent diagonal matrix due to time
dependant loadings.  The version of <span class="math notranslate nohighlight">\(E\)</span> calculated here in
<cite>EDload_linear</cite> is from loading terms in the governing equation that are NOT
differentiated wrt <span class="math notranslate nohighlight">\(t\)</span>.
The diagonal elements of <span class="math notranslate nohighlight">\(E\)</span> are given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{E}_{i,i}=\int_{0}^t{\frac{d{\sigma\left(\tau\right)}}{d\tau}{\exp\left({(dT\left(t-\tau\right)\lambda_i}\right)}\,d\tau}\]</div>
<p>where</p>
<blockquote>
<div><span class="math notranslate nohighlight">\(\lambda_i\)</span> is the <cite>ith</cite> eigenvalue of the problem,
<span class="math notranslate nohighlight">\(dT\)</span> is a time factor for numerical convienience,
<span class="math notranslate nohighlight">\(\sigma\left(\tau\right)\)</span> is the time dependant portion of the loading function.</div></blockquote>
<p>When the time dependant loading term <span class="math notranslate nohighlight">\(\sigma\left(\tau\right)\)</span> is
piecewise in time. The contribution of each load segment is found by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{E}_{i,i}=\int_{t_s}^{t_f}{\frac{d{\sigma\left(\tau\right)}}{d\tau}\exp\left({dT\left(t-\tau\right)*\lambda_i}\right)\,d\tau}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[t_s = \min\left(t,t_{increment\:start}\right)\]</div>
<div class="math notranslate nohighlight">
\[t_f = \min\left(t,t_{increment\:end}\right)\]</div>
<p>(note that this function,`EDload_linear`, rather than use <span class="math notranslate nohighlight">\(t_s\)</span> and
<span class="math notranslate nohighlight">\(t_f\)</span>,
explicitly finds increments that the current time falls in, falls after,
and falls before and treates each case on it’s own.)</p>
<p>Each <span class="math notranslate nohighlight">\(t\)</span> value of interest requires a separate diagonal matrix
<span class="math notranslate nohighlight">\(E\)</span>.  To use space more efficiently and to facilitate numpy
broadcasting when using the results of the function, the diagonal elements
of <span class="math notranslate nohighlight">\(E\)</span> for each time value <cite>t</cite> value are stored in the rows of
array <span class="math notranslate nohighlight">\(A\)</span> returned by <cite>EDload_linear</cite>.  Thus:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{A}=\left(\begin{matrix}E_{0,0}(t_0)&amp;E_{1,1}(t_0)&amp; \cdots &amp; E_{neig-1,neig-1}(t_0)\\ E_{0,0}(t_1)&amp;E_{1,1}(t_1)&amp; \cdots &amp; E_{neig-1,neig-1}(t_1)\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots \\ E_{0,0}(t_m)&amp;E_{1,1}(t_m)&amp; \cdots &amp; E_{neig-1,neig-1}(t_m)\end{matrix}\right)\end{split}\]</div>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.Eload_coslinear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">Eload_coslinear</code><span class="sig-paren">(</span><em>loadtim</em>, <em>loadmag</em>, <em>omega</em>, <em>phase</em>, <em>eigs</em>, <em>tvals</em>, <em>dT=1.0</em>, <em>implementation='vectorized'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#Eload_coslinear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.Eload_coslinear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integration of cos(omega*tau+phase)*load(tau) * exp(dT * eig * (t-tau)) between [0, t], where
load(tau) is piecewise linear.</p>
<p>Performs integrations involving a piecewise linear load.  A 2d array of
dimensions A[len(tvals), len(eigs)]
is produced where the ‘i’th row of A contains the diagonal elements of the
spectral ‘E’ matrix calculated for the time value tvals[i]. i.e. rows of
this matrix will be assembled into the diagonal matrix ‘E’ elsewhere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>loadtim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray</span></dt>
<dd><p class="first last">List of times describing load application.</p>
</dd>
<dt><strong>loadmag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray</span></dt>
<dd><p class="first last">List of load magnitudes.</p>
</dd>
<dt><strong>omega, phase</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Parameters that describe a cyclic load cos(omega * t + phase).</p>
</dd>
<dt><strong>eigs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray</span></dt>
<dd><p class="first last">List of eigenvalues.</p>
</dd>
<dt><strong>tvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray`</span></dt>
<dd><p class="first last">List of time values to calculate integral at.</p>
</dd>
<dt><strong>dT</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">float</span></code>, optional</span></dt>
<dd><p class="first last">Time factor multiple (Default dT=1.0).</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A 2d array of dimesnions A[len(tvals), len(eigs)].
The ‘i’th row of A is the diagonal elements of the spectral ‘E’ matrix
calculated for the time tvals[i].</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.pEload_coslinear" title="geotecha.speccon.integrals.pEload_coslinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pEload_coslinear</span></code></a></dt>
<dd>Same function with PolyLine inputs.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.speccon.ext_integrals.eload_coslinear</span></code></dt>
<dd>Equivalent fortran function.</dd>
<dt><a class="reference internal" href="geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.Eload_coslinear_implementations" title="geotecha.speccon.integrals_generate_code.Eload_coslinear_implementations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.speccon.integrals_generate_code.Eload_coslinear_implementations</span></code></a></dt>
<dd>Generation of code for this function.</dd>
<dt><a class="reference internal" href="#geotecha.speccon.integrals.Eload_linear" title="geotecha.speccon.integrals.Eload_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Eload_linear</span></code></a></dt>
<dd>Similar function with no cosine term.</dd>
<dt><a class="reference internal" href="#geotecha.speccon.integrals.EDload_coslinear" title="geotecha.speccon.integrals.EDload_coslinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EDload_coslinear</span></code></a></dt>
<dd>Similar function but the combined loading function is differentiated with respect to time.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Assuming the load are formulated as the product of separate time and depth
dependant functions:</p>
<div class="math notranslate nohighlight">
\[\sigma\left({Z,t}\right)=\sigma\left({Z}\right)\sigma\left({t}\right)\]</div>
<p>the solution to the consolidation equation using the spectral method has
the form:</p>
<div class="math notranslate nohighlight">
\[u\left(Z,t\right)=\mathbf{\Phi v E}\left(\mathbf{\Gamma v}\right)^{-1}\mathbf{\theta}\]</div>
<p>The matrix <span class="math notranslate nohighlight">\(E\)</span> is a time dependent diagonal matrix due to time
dependant loadings.  The version of <span class="math notranslate nohighlight">\(E\)</span> calculated here in
<cite>Eload_coslinear</cite> is from loading terms in the governing equation that are NOT
differentiated wrt <span class="math notranslate nohighlight">\(t\)</span>.
The diagonal elements of <span class="math notranslate nohighlight">\(E\)</span> are given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{E}_{i,i}=\int_{0}^t{{\cos\left(\omega\tau+\textrm{phase}\right)}{\sigma\left(\tau\right)}{\exp\left({(dT\left(t-\tau\right)\lambda_i}\right)}\,d\tau}\]</div>
<p>where</p>
<blockquote>
<div><span class="math notranslate nohighlight">\(\lambda_i\)</span> is the <cite>ith</cite> eigenvalue of the problem,
<span class="math notranslate nohighlight">\(dT\)</span> is a time factor for numerical convienience,
<span class="math notranslate nohighlight">\(\sigma\left(\tau\right)\)</span> is the time dependant portion of the loading function.</div></blockquote>
<p>When the time dependant loading term <span class="math notranslate nohighlight">\(\sigma\left(\tau\right)\)</span> is
piecewise in time. The contribution of each load segment is found by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{E}_{i,i}=\int_{t_s}^{t_f}{{\cos\left(\omega\tau+\textrm{phase}\right)}{\sigma\left(\tau\right)}\exp\left({dT\left(t-\tau\right)*\lambda_i}\right)\,d\tau}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[t_s = \min\left(t,t_{increment\:start}\right)\]</div>
<div class="math notranslate nohighlight">
\[t_f = \min\left(t,t_{increment\:end}\right)\]</div>
<p>(note that this function,`Eload_coslinear`, rather than use <span class="math notranslate nohighlight">\(t_s\)</span> and
<span class="math notranslate nohighlight">\(t_f\)</span>,
explicitly finds increments that the current time falls in, falls after,
and falls before and treates each case on it’s own.)</p>
<p>Each <span class="math notranslate nohighlight">\(t\)</span> value of interest requires a separate diagonal matrix
<span class="math notranslate nohighlight">\(E\)</span>.  To use space more efficiently and to facilitate numpy
broadcasting when using the results of the function, the diagonal elements
of <span class="math notranslate nohighlight">\(E\)</span> for each time value <cite>t</cite> value are stored in the rows of
array <span class="math notranslate nohighlight">\(A\)</span> returned by <cite>Eload_coslinear</cite>.  Thus:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{A}=\left(\begin{matrix}E_{0,0}(t_0)&amp;E_{1,1}(t_0)&amp; \cdots &amp; E_{neig-1,neig-1}(t_0)\\ E_{0,0}(t_1)&amp;E_{1,1}(t_1)&amp; \cdots &amp; E_{neig-1,neig-1}(t_1)\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots \\ E_{0,0}(t_m)&amp;E_{1,1}(t_m)&amp; \cdots &amp; E_{neig-1,neig-1}(t_m)\end{matrix}\right)\end{split}\]</div>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.Eload_linear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">Eload_linear</code><span class="sig-paren">(</span><em>loadtim</em>, <em>loadmag</em>, <em>eigs</em>, <em>tvals</em>, <em>dT=1.0</em>, <em>implementation='vectorized'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#Eload_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.Eload_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integration of load(tau) * exp(dT * eig * (t-tau)) between [0, t], where
load(tau) is piecewise linear.</p>
<p>Performs integrations involving a piecewise linear load.  A 2d array of
dimensions A[len(tvals), len(eigs)]
is produced where the ‘i’th row of A contains the diagonal elements of the
spectral ‘E’ matrix calculated for the time value tvals[i]. i.e. rows of
this matrix will be assembled into the diagonal matrix ‘E’ elsewhere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>loadtim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray</span></dt>
<dd><p class="first last">List of times describing load application.</p>
</dd>
<dt><strong>loadmag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray</span></dt>
<dd><p class="first last">List of load magnitudes.</p>
</dd>
<dt><strong>eigs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray</span></dt>
<dd><p class="first last">List of eigenvalues.</p>
</dd>
<dt><strong>tvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray`</span></dt>
<dd><p class="first last">List of time values to calculate integral at.</p>
</dd>
<dt><strong>dT</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">float</span></code>, optional</span></dt>
<dd><p class="first last">Time factor multiple (Default dT=1.0).</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A 2d array of dimesnions A[len(tvals), len(eigs)] (note dtype=complex.
The ‘i’th row of A is the diagonal elements of the spectral ‘E’ matrix
calculated for the time tvals[i].</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.pEload_linear" title="geotecha.speccon.integrals.pEload_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pEload_linear</span></code></a></dt>
<dd>Same function with PolyLine inputs.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.speccon.ext_integrals.eload_linear</span></code></dt>
<dd>Equivalent fortran function.</dd>
<dt><a class="reference internal" href="geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.Eload_linear_implementations" title="geotecha.speccon.integrals_generate_code.Eload_linear_implementations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.speccon.integrals_generate_code.Eload_linear_implementations</span></code></a></dt>
<dd>Generation of code for this function.</dd>
<dt><a class="reference internal" href="#geotecha.speccon.integrals.Eload_coslinear" title="geotecha.speccon.integrals.Eload_coslinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Eload_coslinear</span></code></a></dt>
<dd>Similar function with additional cosine term.</dd>
<dt><a class="reference internal" href="#geotecha.speccon.integrals.EDload_linear" title="geotecha.speccon.integrals.EDload_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EDload_linear</span></code></a></dt>
<dd>Similar function but the time dependent loading function is differentiated with respect to time.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Assuming the load are formulated as the product of separate time and depth
dependant functions:</p>
<div class="math notranslate nohighlight">
\[\sigma\left({Z,t}\right)=\sigma\left({Z}\right)\sigma\left({t}\right)\]</div>
<p>the solution to the consolidation equation using the spectral method has
the form:</p>
<div class="math notranslate nohighlight">
\[u\left(Z,t\right)=\mathbf{\Phi v E}\left(\mathbf{\Gamma v}\right)^{-1}\mathbf{\theta}\]</div>
<p>The matrix <span class="math notranslate nohighlight">\(E\)</span> is a time dependent diagonal matrix due to time
dependant loadings.  The version of <span class="math notranslate nohighlight">\(E\)</span> calculated here in
<cite>Eload_linear</cite> is from loading terms in the governing equation that are NOT
differentiated wrt <span class="math notranslate nohighlight">\(t\)</span>.
The diagonal elements of <span class="math notranslate nohighlight">\(E\)</span> are given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{E}_{i,i}=\int_{0}^t{{\sigma\left(\tau\right)}{\exp\left({(dT\left(t-\tau\right)\lambda_i}\right)}\,d\tau}\]</div>
<p>where</p>
<blockquote>
<div><span class="math notranslate nohighlight">\(\lambda_i\)</span> is the <cite>ith</cite> eigenvalue of the problem,
<span class="math notranslate nohighlight">\(dT\)</span> is a time factor for numerical convienience,
<span class="math notranslate nohighlight">\(\sigma\left(\tau\right)\)</span> is the time dependant portion of the loading function.</div></blockquote>
<p>When the time dependant loading term <span class="math notranslate nohighlight">\(\sigma\left(\tau\right)\)</span> is
piecewise in time. The contribution of each load segment is found by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{E}_{i,i}=\int_{t_s}^{t_f}{{\sigma\left(\tau\right)}\exp\left({dT\left(t-\tau\right)*\lambda_i}\right)\,d\tau}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[t_s = \min\left(t,t_{increment\:start}\right)\]</div>
<div class="math notranslate nohighlight">
\[t_f = \min\left(t,t_{increment\:end}\right)\]</div>
<p>(note that this function,`Eload_linear`, rather than use <span class="math notranslate nohighlight">\(t_s\)</span> and
<span class="math notranslate nohighlight">\(t_f\)</span>,
explicitly finds increments that the current time falls in, falls after,
and falls before and treates each case on it’s own.)</p>
<p>Each <span class="math notranslate nohighlight">\(t\)</span> value of interest requires a separate diagonal matrix
<span class="math notranslate nohighlight">\(E\)</span>.  To use space more efficiently and to facilitate numpy
broadcasting when using the results of the function, the diagonal elements
of <span class="math notranslate nohighlight">\(E\)</span> for each time value <cite>t</cite> value are stored in the rows of
array <span class="math notranslate nohighlight">\(A\)</span> returned by <cite>Eload_linear</cite>.  Thus:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{A}=\left(\begin{matrix}E_{0,0}(t_0)&amp;E_{1,1}(t_0)&amp; \cdots &amp; E_{neig-1,neig-1}(t_0)\\ E_{0,0}(t_1)&amp;E_{1,1}(t_1)&amp; \cdots &amp; E_{neig-1,neig-1}(t_1)\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots \\ E_{0,0}(t_m)&amp;E_{1,1}(t_m)&amp; \cdots &amp; E_{neig-1,neig-1}(t_m)\end{matrix}\right)\end{split}\]</div>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.Eload_sinlinear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">Eload_sinlinear</code><span class="sig-paren">(</span><em>loadtim</em>, <em>loadmag</em>, <em>omega</em>, <em>phase</em>, <em>eigs</em>, <em>tvals</em>, <em>dT=1.0</em>, <em>implementation='vectorized'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#Eload_sinlinear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.Eload_sinlinear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.dim1sin">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">dim1sin</code><span class="sig-paren">(</span><em>m</em>, <em>z</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#dim1sin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.dim1sin" title="Permalink to this definition">¶</a></dt>
<dd><p>sin(m*z) for each combination of m and z</p>
<p>Calculates array A[len(z), len(m)]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Eigenvlaues of BVP. generate with geoteca.speccon.m_from_sin_mx</p>
</dd>
<dt><strong>z</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Normalised depth or z-coordinate should be between 0 and 1.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A 1d array size A[len(z), len(m)].</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.m_from_sin_mx" title="geotecha.speccon.integrals.m_from_sin_mx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">m_from_sin_mx</span></code></a></dt>
<dd>used to generate ‘m’ input parameter</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i,j}=\sin\left({m_j, z_i}\right)\]</div>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.dim1sin_DD_abDDf_linear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">dim1sin_DD_abDDf_linear</code><span class="sig-paren">(</span><em>m</em>, <em>at</em>, <em>ab</em>, <em>bt</em>, <em>bb</em>, <em>zt</em>, <em>zb</em>, <em>implementation='vectorized'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#dim1sin_DD_abDDf_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.dim1sin_DD_abDDf_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integration of sin(mi * z) * D[a(z) * b(z) D[sin(mj * z),z,2],z,2]
between ztop and zbot where a(z) &amp; b(z) is piecewise linear functions of z.</p>
<p>Calulation of integrals is performed at each element of a square symmetric
matrix (size depends on size of <cite>m</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">eigenvlaues of BVP. generate with geoteca.speccon.m_from_sin_mx</p>
</dd>
<dt><strong>at</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Property at top of each layer.</p>
</dd>
<dt><strong>ab</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Property at bottom of each layer.</p>
</dd>
<dt><strong>bt</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">2nd property at top of each layer.</p>
</dd>
<dt><strong>bb</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">2nd property at bottom of each layer.</p>
</dd>
<dt><strong>zt</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Normalised depth or z-coordinate at top of each layer. <cite>zt[0]</cite> = 0</p>
</dd>
<dt><strong>zb</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Normalised depth or z-coordinate at bottom of each layer. <cite>zt[-1]</cite> = 1</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A square symmetric matrix, size determined by size of <cite>m</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.m_from_sin_mx" title="geotecha.speccon.integrals.m_from_sin_mx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">m_from_sin_mx</span></code></a></dt>
<dd>Used to generate ‘m’ input parameter.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.integrals_generate_code.dim1sin_DD_abDDf_linear_implementations</span></code></dt>
<dd>Generation of code for this function.</dd>
<dt><a class="reference internal" href="#geotecha.speccon.integrals.pdim1sin_DD_abDDf_linear" title="geotecha.speccon.integrals.pdim1sin_DD_abDDf_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdim1sin_DD_abDDf_linear</span></code></a></dt>
<dd>Same function with PolyLine inputs.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.speccon.ext_integrals.dim1sin_dd_abddf_linear</span></code></dt>
<dd>Equivalent fortran function.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The <cite>dim1sin_DD_abDDf_linear</cite> matrix, <span class="math notranslate nohighlight">\(A\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i,j}=\int_{0}^1{\frac{d^2}{dz^2}\left({a\left(z\right)}{b\left(z\right)}\frac{d^2\phi_j}{dz^2}\right)\phi_i\,dz}\]</div>
<p>where the basis function <span class="math notranslate nohighlight">\(\phi_i\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\phi_i\left(z\right)=\sin\left({m_i}z\right)\]</div>
<p>and <span class="math notranslate nohighlight">\(a\left(z\right)\)</span> and <span class="math notranslate nohighlight">\(b\left(z\right)\)</span> are piecewise
linear functions with respect to <span class="math notranslate nohighlight">\(z\)</span>, that within a layer is defined by:</p>
<div class="math notranslate nohighlight">
\[a\left(z\right) = a_t+\frac{a_b-a_t}{z_b-z_t}\left(z-z_t\right)\]</div>
<p>with <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> subscripts representing ‘top’ and ‘bottom’ of
each layer respectively.</p>
<p>To make the above integration simpler we integate by parts to get:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i,j}= \left.{\frac{d}{dz}\left({a\left(z\right)}{b\left(z\right)}\frac{d^2\phi_j}{dz^2}\right)\phi_i}\right|_{z=0}^{z=1}
     - \left.{{a\left(z\right)}{b\left(z\right)}\frac{d^2\phi_j}{dz^2}\frac{d\phi_i}{dz}}\right|_{z=0}^{z=1}
+\int_{0}^1{{a\left(z\right)}{b\left(z\right)}\frac{d^2\phi_j}{dz^2}\frac{d^2\phi_i}{dz^2}\,dz}\]</div>
<p>In this case the sine basis functions means the end point terms in the above
equation are zero, leaving us with</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i,j}= \int_{0}^1{{a\left(z\right)}{b\left(z\right)}\frac{d^2\phi_j}{dz^2}\frac{d^2\phi_i}{dz^2}\,dz}\]</div>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.dim1sin_D_aDb_linear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">dim1sin_D_aDb_linear</code><span class="sig-paren">(</span><em>m</em>, <em>at</em>, <em>ab</em>, <em>bt</em>, <em>bb</em>, <em>zt</em>, <em>zb</em>, <em>implementation='vectorized'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#dim1sin_D_aDb_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.dim1sin_D_aDb_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrations of <cite>sin(mi * z) * D[a(z) * D[b(z), z], z]</cite>
between ztop and zbot where a(z) is a piecewise linear function of z,
and b(z) is a linear function of z.</p>
<p>Calulation of integrals is performed at each element of a 1d array
(size depends on size of <cite>m</cite>).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The functions produced are set up to accept the b(z) input as
piecewise linear, i.e. zt, zb, bt, bb etc. It is up to the user to
ensure that the bt and bb are such that they define a continuous
linear function. eg. to define b(z)=z+1 then use
zt=[0,0.4], zb=[0.4, 1], bt=[1,1.4], bb=[1.4,2].</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">eigenvlaues of BVP. generate with geoteca.speccon.m_from_sin_mx</p>
</dd>
<dt><strong>at</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Property at top of each layer.</p>
</dd>
<dt><strong>ab</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Property at bottom of each layer.</p>
</dd>
<dt><strong>bt</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">2nd property at top of each layer.</p>
</dd>
<dt><strong>bb</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">2nd property at bottom of each layer.</p>
</dd>
<dt><strong>zt</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Normalised depth or z-coordinate at top of each layer. <cite>zt[0]</cite> = 0</p>
</dd>
<dt><strong>zb</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Normalised depth or z-coordinate at bottom of each layer. <cite>zt[-1]</cite> = 1</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A 1d array size determined by size of <cite>m</cite>. Treat as column
vector</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.m_from_sin_mx" title="geotecha.speccon.integrals.m_from_sin_mx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">m_from_sin_mx</span></code></a></dt>
<dd>Used to generate ‘m’ input parameter.</dd>
<dt><a class="reference internal" href="geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.dim1sin_D_aDb_linear_implementations" title="geotecha.speccon.integrals_generate_code.dim1sin_D_aDb_linear_implementations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.speccon.integrals_generate_code.dim1sin_D_aDb_linear_implementations</span></code></a></dt>
<dd>Generation of code for this function.</dd>
<dt><a class="reference internal" href="#geotecha.speccon.integrals.pdim1sin_D_aDb_linear" title="geotecha.speccon.integrals.pdim1sin_D_aDb_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdim1sin_D_aDb_linear</span></code></a></dt>
<dd>Same function with PolyLine inputs.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.speccon.ext_integrals.dim1sin_D_aDb_linear</span></code></dt>
<dd>Equivalent fortran function.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The <cite>dim1sin_D_aDb_linear</cite> which should be treated as a column vector,
<span class="math notranslate nohighlight">\(A\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i}=\int_{0}^1{\frac{d}{dz}\left({a\left(z\right)}\frac{d}{dz}{b\left(z\right)}\right)\phi_i\,dz}\]</div>
<p>where the basis function <span class="math notranslate nohighlight">\(\phi_i\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\phi_i\left(z\right)=\sin\left({m_i}z\right)\]</div>
<p>and <span class="math notranslate nohighlight">\(a\left(z\right)\)</span> is a piecewise
linear functions with respect to <span class="math notranslate nohighlight">\(z\)</span>, that within a layer is defined by:</p>
<div class="math notranslate nohighlight">
\[a\left(z\right) = a_t+\frac{a_b-a_t}{z_b-z_t}\left(z-z_t\right)\]</div>
<p>with <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> subscripts representing ‘top’ and ‘bottom’ of
each layer respectively.</p>
<p><span class="math notranslate nohighlight">\(b\left(z\right)\)</span> is a linear function of <span class="math notranslate nohighlight">\(z\)</span> defined by</p>
<div class="math notranslate nohighlight">
\[b\left(z\right) = b_t+\left({b_b-b_t}\right)z\]</div>
<p>with <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> subscripts now representing ‘top’ and
‘bottom’ of the profile respectively.</p>
<p>Using the product rule for differentiation the above integral can be split
into:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i}=\int_{0}^1{\frac{da\left(z\right)}{dz}\frac{db\left(z\right)}{dz}\phi_i\,dz} +
\int_{0}^1{a\left(z\right)\frac{d^2b\left(z\right)}{dz^2}\phi_i\,dz}\]</div>
<p>The right hand term is zero because <span class="math notranslate nohighlight">\(b\left(z\right)\)</span> is a
continuous linear function so it’s second derivative is zero.  The
first derivative of <span class="math notranslate nohighlight">\(b\left(z\right)\)</span> is a constant so the
left term can be integrated by parts to give:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i}=\frac{db\left(z\right)}{dz}\left(
\left.\phi_i{a\left(z\right)}\right|_{z=0}^{z=1} -
-\int_{0}^1{{a\left(z\right)}\frac{d\phi_i}{dz}\,dz}
\right)\]</div>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.dim1sin_D_aDf_linear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">dim1sin_D_aDf_linear</code><span class="sig-paren">(</span><em>m</em>, <em>at</em>, <em>ab</em>, <em>zt</em>, <em>zb</em>, <em>implementation='vectorized'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#dim1sin_D_aDf_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.dim1sin_D_aDf_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integration of sin(mi * z) * D[a(z) * D[sin(mj * z),z],z]
between ztop and zbot where a(z) is piecewise linear functions of z.</p>
<p>Calulation of integrals is performed at each element of a square symmetric
matrix (size depends on size of <cite>m</cite>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">eigenvlaues of BVP. generate with geoteca.speccon.m_from_sin_mx</p>
</dd>
<dt><strong>at</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Property at top of each layer.</p>
</dd>
<dt><strong>ab</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Property at bottom of each layer.</p>
</dd>
<dt><strong>zt</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Normalised depth or z-coordinate at top of each layer. <cite>zt[0]</cite> = 0</p>
</dd>
<dt><strong>zb</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Normalised depth or z-coordinate at bottom of each layer. <cite>zt[-1]</cite> = 1</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A square symmetric matrix, size determined by size of <cite>m</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.m_from_sin_mx" title="geotecha.speccon.integrals.m_from_sin_mx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">m_from_sin_mx</span></code></a></dt>
<dd>Used to generate ‘m’ input parameter.</dd>
<dt><a class="reference internal" href="geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.dim1sin_D_aDf_linear_implementations" title="geotecha.speccon.integrals_generate_code.dim1sin_D_aDf_linear_implementations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.speccon.integrals_generate_code.dim1sin_D_aDf_linear_implementations</span></code></a></dt>
<dd>Generation of code for this function.</dd>
<dt><a class="reference internal" href="#geotecha.speccon.integrals.pdim1sin_D_aDf_linear" title="geotecha.speccon.integrals.pdim1sin_D_aDf_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdim1sin_D_aDf_linear</span></code></a></dt>
<dd>Same function with PolyLine inputs.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.speccon.ext_integrals.dim1sin_D_aDf_linear</span></code></dt>
<dd>Equivalent fortran function.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The <cite>dim1sin_D_aDf_linear</cite> matrix, <span class="math notranslate nohighlight">\(A\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i,j}=\int_{0}^1{\frac{d}{dz}\left({a\left(z\right)}\frac{d\phi_j}{dz}\right)\phi_i\,dz}\]</div>
<p>where the basis function <span class="math notranslate nohighlight">\(\phi_i\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\phi_i\left(z\right)=\sin\left({m_i}z\right)\]</div>
<p>and <span class="math notranslate nohighlight">\(a\left(z\right)\)</span> is a piecewise
linear functions with respect to <span class="math notranslate nohighlight">\(z\)</span>, that within a layer is defined by:</p>
<div class="math notranslate nohighlight">
\[a\left(z\right) = a_t+\frac{a_b-a_t}{z_b-z_t}\left(z-z_t\right)\]</div>
<p>with <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> subscripts representing ‘top’ and ‘bottom’ of
each layer respectively.</p>
<p>To make the above integration simpler we integate by parts to get:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i,j}= \left.\phi_i{a\left(z\right)}\frac{d\phi_j}{dz}\right|_{z=0}^{z=1} -\int_{0}^1{{a\left(z\right)}\frac{d\phi_j}{dz}\frac{d\phi_i}{dz}\,dz}\]</div>
<p>In this case the sine basis functions means the left term in the above
equation is zero, leaving us with</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i,j}= -\int_{0}^1{{a\left(z\right)}\frac{d\phi_j}{dz}\frac{d\phi_i}{dz}\,dz}\]</div>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.dim1sin_a_linear_between">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">dim1sin_a_linear_between</code><span class="sig-paren">(</span><em>m</em>, <em>at</em>, <em>ab</em>, <em>zt</em>, <em>zb</em>, <em>z</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#dim1sin_a_linear_between"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.dim1sin_a_linear_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrations of <cite>sin(mi * z) * a(z)</cite>
between [z1, z2] where a(z) is a piecewise linear functions of z.</p>
<p>Calculates array A[len(z), len(m)].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Eigenvlaues of BVP. generate with geoteca.speccon.m_from_sin_mx</p>
</dd>
<dt><strong>at</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Property at top of each layer.</p>
</dd>
<dt><strong>ab</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Property at bottom of each layer.</p>
</dd>
<dt><strong>zt</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Normalised depth or z-coordinate at top of each layer. <cite>zt[0]</cite> = 0</p>
</dd>
<dt><strong>zb</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Normalised depth or z-coordinate at bottom of each layer. <cite>zt[-1]</cite> = 1</p>
</dd>
<dt><strong>z</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">list</span></code> of float``</span></dt>
<dd><p class="first last">Normalised depth or z-coordinate pair should be two values
between 0 and 1.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A 2d array size of size [len(z), len(m)].</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.m_from_sin_mx" title="geotecha.speccon.integrals.m_from_sin_mx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">m_from_sin_mx</span></code></a></dt>
<dd>Used to generate ‘m’ input parameter.</dd>
<dt><a class="reference internal" href="geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.dim1sin_a_linear_between" title="geotecha.speccon.integrals_generate_code.dim1sin_a_linear_between"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.speccon.integrals_generate_code.dim1sin_a_linear_between</span></code></a></dt>
<dd>Generation of code for this function.</dd>
<dt><a class="reference internal" href="#geotecha.speccon.integrals.pdim1sin_a_linear_between" title="geotecha.speccon.integrals.pdim1sin_a_linear_between"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdim1sin_a_linear_between</span></code></a></dt>
<dd>Same function with PolyLine inputs.</dd>
<dt><a class="reference internal" href="geotecha.piecewise.piecewise_linear_1d.html#geotecha.piecewise.piecewise_linear_1d.segments_between_xi_and_xj" title="geotecha.piecewise.piecewise_linear_1d.segments_between_xi_and_xj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.piecewise.piecewise_linear_1d.segments_between_xi_and_xj</span></code></a></dt>
<dd>Used in the function.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The <cite>dim1sin_a_linear_between</cite>, <span class="math notranslate nohighlight">\(A\)</span>, is given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i,j}=
\int_{z_1}^{z_2}{{a\left(z\right)}\phi_j\,dz}\]</div>
<p>where the basis function <span class="math notranslate nohighlight">\(\phi_j\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\phi_j\left(z\right)=\sin\left({m_j}z\right)\]</div>
<p>and <span class="math notranslate nohighlight">\(a\left(z\right)\)</span> is a piecewise
linear functions with respect to <span class="math notranslate nohighlight">\(z\)</span>, that within a layer are defined by:</p>
<div class="math notranslate nohighlight">
\[a\left(z\right) = a_t+\frac{a_b-a_t}{z_b-z_t}\left(z-z_t\right)\]</div>
<p>with <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> subscripts representing ‘top’ and ‘bottom’ of
each layer respectively.</p>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.dim1sin_ab_linear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">dim1sin_ab_linear</code><span class="sig-paren">(</span><em>m</em>, <em>at</em>, <em>ab</em>, <em>bt</em>, <em>bb</em>, <em>zt</em>, <em>zb</em>, <em>implementation='vectorized'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#dim1sin_ab_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.dim1sin_ab_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integration of sin(mi * z) * a(z) * b(z)
between ztop and zbot where a(z) and b(z) are piecewise linear functions of z.</p>
<p>Calulation of integrals is performed at each element of a 1d array
(size depends on size of <cite>m</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">eigenvlaues of BVP. generate with geoteca.speccon.m_from_sin_mx</p>
</dd>
<dt><strong>at</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Property at top of each layer.</p>
</dd>
<dt><strong>ab</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Property at bottom of each layer.</p>
</dd>
<dt><strong>bt</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">2nd property at top of each layer.</p>
</dd>
<dt><strong>bb</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">2nd property at bottom of each layer.</p>
</dd>
<dt><strong>zt</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Normalised depth or z-coordinate at top of each layer. <cite>zt[0]</cite> = 0</p>
</dd>
<dt><strong>zb</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Normalised depth or z-coordinate at bottom of each layer. <cite>zt[-1]</cite> = 1</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A 1d array size determined by size of <cite>m</cite>. Treat as column
vector</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.m_from_sin_mx" title="geotecha.speccon.integrals.m_from_sin_mx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">m_from_sin_mx</span></code></a></dt>
<dd>Used to generate ‘m’ input parameter.</dd>
<dt><a class="reference internal" href="geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.dim1sin_ab_linear_implementations" title="geotecha.speccon.integrals_generate_code.dim1sin_ab_linear_implementations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.speccon.integrals_generate_code.dim1sin_ab_linear_implementations</span></code></a></dt>
<dd>Generation of code for this function.</dd>
<dt><a class="reference internal" href="#geotecha.speccon.integrals.pdim1sin_ab_linear" title="geotecha.speccon.integrals.pdim1sin_ab_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdim1sin_ab_linear</span></code></a></dt>
<dd>Same function with PolyLine inputs.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.speccon.ext_integrals.dim1sin_ab_linear</span></code></dt>
<dd>Equivalent fortran function.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The <cite>dim1sin_ab_linear</cite> which should be treated as a column vector,
<span class="math notranslate nohighlight">\(A\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i}=\int_{0}^1{{a\left(z\right)}{b\left(z\right)}\phi_i\,dz}\]</div>
<p>where the basis function <span class="math notranslate nohighlight">\(\phi_i\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\phi_i\left(z\right)=\sin\left({m_i}z\right)\]</div>
<p>and <span class="math notranslate nohighlight">\(a\left(z\right)\)</span> and <span class="math notranslate nohighlight">\(b\left(z\right)\)</span> are piecewise
linear functions with respect to <span class="math notranslate nohighlight">\(z\)</span>, that within a layer are defined by:</p>
<div class="math notranslate nohighlight">
\[a\left(z\right) = a_t+\frac{a_b-a_t}{z_b-z_t}\left(z-z_t\right)\]</div>
<p>with <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> subscripts representing ‘top’ and ‘bottom’ of
each layer respectively.</p>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.dim1sin_abc_linear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">dim1sin_abc_linear</code><span class="sig-paren">(</span><em>m</em>, <em>at</em>, <em>ab</em>, <em>bt</em>, <em>bb</em>, <em>ct</em>, <em>cb</em>, <em>zt</em>, <em>zb</em>, <em>implementation='vectorized'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#dim1sin_abc_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.dim1sin_abc_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrations of sin(mi * z) * a(z) * b(z) * c(z)
between ztop and zbot where a(z), b(z), c(z) are piecewise linear functions of z.</p>
<p>Calulation of integrals is performed at each element of a 1d array
(size depends on size of <cite>m</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">eigenvlaues of BVP. generate with geoteca.speccon.m_from_sin_mx</p>
</dd>
<dt><strong>at</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Property at top of each layer.</p>
</dd>
<dt><strong>ab</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Property at bottom of each layer.</p>
</dd>
<dt><strong>bt</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">2nd property at top of each layer.</p>
</dd>
<dt><strong>bb</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">2nd property at bottom of each layer.</p>
</dd>
<dt><strong>ct</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">3rd property at top of each layer.</p>
</dd>
<dt><strong>cb</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">3rd property at bottom of each layer.</p>
</dd>
<dt><strong>zt</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Normalised depth or z-coordinate at top of each layer. <cite>zt[0]</cite> = 0</p>
</dd>
<dt><strong>zb</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Normalised depth or z-coordinate at bottom of each layer. <cite>zt[-1]</cite> = 1</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A 1d array size determined by size of <cite>m</cite>. Treat as column
vector.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.m_from_sin_mx" title="geotecha.speccon.integrals.m_from_sin_mx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">m_from_sin_mx</span></code></a></dt>
<dd>Used to generate ‘m’ input parameter.</dd>
<dt><a class="reference internal" href="geotecha.speccon.integrals_generate_code.html#geotecha.speccon.integrals_generate_code.dim1sin_abc_linear_implementations" title="geotecha.speccon.integrals_generate_code.dim1sin_abc_linear_implementations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.speccon.integrals_generate_code.dim1sin_abc_linear_implementations</span></code></a></dt>
<dd>Generation of code for this function.</dd>
<dt><a class="reference internal" href="#geotecha.speccon.integrals.pdim1sin_abc_linear" title="geotecha.speccon.integrals.pdim1sin_abc_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdim1sin_abc_linear</span></code></a></dt>
<dd>Same function with PolyLine inputs.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.speccon.ext_integrals.dim1sin_abc_linear</span></code></dt>
<dd>Equivalent fortran function.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The <cite>dim1sin_abc_linear</cite> which should be treated as a column vector,
<span class="math notranslate nohighlight">\(A\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i}=\int_{0}^1{{a\left(z\right)}{b\left(z\right)}{c\left(z\right)}\phi_i\,dz}\]</div>
<p>where the basis function <span class="math notranslate nohighlight">\(\phi_i\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\phi_i\left(z\right)=\sin\left({m_i}z\right)\]</div>
<p>and <span class="math notranslate nohighlight">\(a\left(z\right)\)</span>, <span class="math notranslate nohighlight">\(b\left(z\right)\)</span>, and
<span class="math notranslate nohighlight">\(c\left(z\right)\)</span> are piecewise linear functions
with respect to <span class="math notranslate nohighlight">\(z\)</span>, that within a layer are defined by:</p>
<div class="math notranslate nohighlight">
\[a\left(z\right) = a_t+\frac{a_b-a_t}{z_b-z_t}\left(z-z_t\right)\]</div>
<p>with <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> subscripts representing ‘top’ and ‘bottom’ of
each layer respectively.</p>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.dim1sin_abf_linear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">dim1sin_abf_linear</code><span class="sig-paren">(</span><em>m</em>, <em>at</em>, <em>ab</em>, <em>bt</em>, <em>bb</em>, <em>zt</em>, <em>zb</em>, <em>implementation='vectorized'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#dim1sin_abf_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.dim1sin_abf_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integration of sin(mi * z) * a(z) * a(z) * sin(mj * z)
between ztop and zbot where a(z) is piecewise linear.</p>
<p>Calulation of integrals is performed at each element of a square symmetric
matrix (size depends on size of <cite>m</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">eigenvlaues of BVP. generate with geoteca.speccon.m_from_sin_mx</p>
</dd>
<dt><strong>at</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Property at top of each layer.</p>
</dd>
<dt><strong>ab</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Property at bottom of each layer.</p>
</dd>
<dt><strong>bt</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">2nd property at top of each layer.</p>
</dd>
<dt><strong>bb</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">2nd property at bottom of each layer.</p>
</dd>
<dt><strong>zt</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Normalised depth or z-coordinate at top of each layer. <cite>zt[0]</cite> = 0</p>
</dd>
<dt><strong>zb</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Normalised depth or z-coordinate at bottom of each layer. <cite>zt[-1]</cite> = 1</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A square symmetric matrix, size determined by size of <cite>m</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.m_from_sin_mx" title="geotecha.speccon.integrals.m_from_sin_mx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">m_from_sin_mx</span></code></a></dt>
<dd>Used to generate ‘m’ input parameter.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.integrals_generate_code.dim1sin_abf_linear</span></code></dt>
<dd>Generation of code for this function.</dd>
<dt><a class="reference internal" href="#geotecha.speccon.integrals.pdim1sin_abf_linear" title="geotecha.speccon.integrals.pdim1sin_abf_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdim1sin_abf_linear</span></code></a></dt>
<dd>Same function with PolyLine inputs.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.speccon.ext_integrals.dim1sin_abf_linear</span></code></dt>
<dd>Equivalent fortran function.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The <cite>dim1sin_abf_linear</cite> matrix, <span class="math notranslate nohighlight">\(A\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i,j}=\int_{0}^1{{a\left(z\right)}{b\left(z\right)}\phi_i\phi_j\,dz}\]</div>
<p>where the basis function <span class="math notranslate nohighlight">\(\phi_i\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\phi_i\left(z\right)=\sin\left({m_i}z\right)\]</div>
<p>and <span class="math notranslate nohighlight">\(a\left(z\right)\)</span> and <span class="math notranslate nohighlight">\(b\left(z\right)\)</span> are piecewise
linear functions with respect to <span class="math notranslate nohighlight">\(z\)</span>, that within a layer are defined by:</p>
<div class="math notranslate nohighlight">
\[a\left(z\right) = a_t+\frac{a_b-a_t}{z_b-z_t}\left(z-z_t\right)\]</div>
<p>with <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> subscripts representing ‘top’ and ‘bottom’ of
each layer respectively.</p>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.dim1sin_af_linear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">dim1sin_af_linear</code><span class="sig-paren">(</span><em>m</em>, <em>at</em>, <em>ab</em>, <em>zt</em>, <em>zb</em>, <em>implementation='vectorized'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#dim1sin_af_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.dim1sin_af_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integration of sin(mi * z) * a(z) * sin(mj * z)
between ztop and zbot where a(z) is piecewise linear.</p>
<p>Calculation of integrals is performed at each element of a square symmetric
matrix (size depends on size of <cite>m</cite>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">eigenvlaues of BVP. generate with geoteca.speccon.m_from_sin_mx</p>
</dd>
<dt><strong>at</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Property at top of each layer.</p>
</dd>
<dt><strong>ab</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Property at bottom of each layer.</p>
</dd>
<dt><strong>zt</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Normalised depth or z-coordinate at top of each layer. <cite>zt[0]</cite> = 0</p>
</dd>
<dt><strong>zb</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Normalised depth or z-coordinate at bottom of each layer. <cite>zt[-1]</cite> = 1</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A square symmetric matrix, size determined by size of <cite>m</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.m_from_sin_mx" title="geotecha.speccon.integrals.m_from_sin_mx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">m_from_sin_mx</span></code></a></dt>
<dd>Used to generate ‘m’ input parameter.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.integrals_generate_code.dim1sin_af_linear</span></code></dt>
<dd>Generation of code for this function.</dd>
<dt><a class="reference internal" href="#geotecha.speccon.integrals.pdim1sin_af_linear" title="geotecha.speccon.integrals.pdim1sin_af_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdim1sin_af_linear</span></code></a></dt>
<dd>Same function with PolyLine inputs.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">geotecha.speccon.ext_integrals.dim1sin_af_linear</span></code></dt>
<dd>Equivalent fortran function.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The <cite>dim1sin_af_linear</cite> matrix, <span class="math notranslate nohighlight">\(A\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i,j}=\int_{0}^1{{a\left(z\right)}\phi_i\phi_j\,dz}\]</div>
<p>where the basis function <span class="math notranslate nohighlight">\(\phi_i\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\phi_i\left(z\right)=\sin\left({m_i}z\right)\]</div>
<p>and <span class="math notranslate nohighlight">\(a\left(z\right)\)</span> is a piecewise linear function
with respect to <span class="math notranslate nohighlight">\(z\)</span>, that within a layer are defined by:</p>
<div class="math notranslate nohighlight">
\[a\left(z\right) = a_t+\frac{a_b-a_t}{z_b-z_t}\left(z-z_t\right)\]</div>
<p>with <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> subscripts representing ‘top’ and ‘bottom’ of
each layer respectively.</p>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.dim1sin_avg_between">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">dim1sin_avg_between</code><span class="sig-paren">(</span><em>m</em>, <em>z</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#dim1sin_avg_between"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.dim1sin_avg_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Average of sin(m * z) between z1 and z2</p>
<p>Integrate(sin(m*z), (z, z1, z2))/(z2-z1) for each combination of m
and [z1,z2].</p>
<p>Calculates array A[len(z), len(m)].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Eigenvlaues of BVP. generate with geoteca.speccon.m_from_sin_mx</p>
</dd>
<dt><strong>z</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">list</span></code> of float``</span></dt>
<dd><p class="first last">Normalised depth or z-coordinate pair should be two values
between 0 and 1..</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A 1d array size A[len(z), len(m)]</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.m_from_sin_mx" title="geotecha.speccon.integrals.m_from_sin_mx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">m_from_sin_mx</span></code></a></dt>
<dd>used to generate ‘m’ input parameter</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i,j}=\frac{1}{z_{2i}-z_{1i}}\int_{z_{1i}}^{z_{2i}}{\sin\left({m_j, z}\right)\,dz}\]</div>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.m_from_sin_mx">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">m_from_sin_mx</code><span class="sig-paren">(</span><em>i</em>, <em>boundary=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#m_from_sin_mx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.m_from_sin_mx" title="Permalink to this definition">¶</a></dt>
<dd><p>Sine series eigenvalue of boundary value problem on [0, 1]</p>
<dl class="docutils">
<dt><cite>i</cite> th eigenvalue, M,  of f(x) = sin(M*x) that satisfies:</dt>
<dd>f(0) = 0, f(1) = 0; for <cite>boundary</cite> = 0 i.e. PTPB
f(0) = 0; f’(1) = 0; for <cite>boundary</cite> = 1 i.e. PTIB</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">int</span></code></span></dt>
<dd><p class="first last">Eigenvalue number in series to return.</p>
</dd>
<dt><strong>boundary</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{0, 1}, optional</span></dt>
<dd><p class="first last">Boundary condition.
For ‘Pervious Top Pervious Bottom (PTPB)’, boundary = 0.
For ‘Pervious Top Impervious Bottom (PTIB)’, boundary = 1.
Default boundary=0.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">The <cite>i</cite> th eigenvalue</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.pEDload_coslinear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">pEDload_coslinear</code><span class="sig-paren">(</span><em>a</em>, <em>omega</em>, <em>phase</em>, <em>eigs</em>, <em>tvals</em>, <em>dT=1.0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#pEDload_coslinear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.pEDload_coslinear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integration of D[cos(omega*tau+phase)*load(tau), tau] * exp(dT * eig * (t-tau)) between [0, t], where
load(tau) is piecewise linear.</p>
<p>Wrapper for EDload_coslinear to allow PolyLine inputs.</p>
<p>Performs integrations involving a piecewise linear load.  A 2d array of
dimensions A[len(tvals), len(eigs)]
is produced where the ‘i’th row of A contains the diagonal elements of the
spectral ‘E’ matrix calculated for the time value tvals[i]. i.e. rows of
this matrix will be assembled into the diagonal matrix ‘E’ elsewhere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PolyLine</span></dt>
<dd><p class="first last">PolyLine object representing piecewise linear load vs time.
List of load magnitudes.</p>
</dd>
<dt><strong>omega, phase</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Parameters that describe a cyclic load cos(omega * t + phase).</p>
</dd>
<dt><strong>eigs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray</span></dt>
<dd><p class="first last">List of eigenvalues.</p>
</dd>
<dt><strong>tvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray`</span></dt>
<dd><p class="first last">List of time values to calculate integral at.</p>
</dd>
<dt><strong>dT</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">float</span></code>, optional</span></dt>
<dd><p class="first last">Time factor multiple (Default dT=1.0).</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A 2d array of dimesnions A[len(tvals), len(eigs)].
The ‘i’th row of A is the diagonal elements of the spectral ‘E’ matrix
calculated for the time tvals[i].</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.pEDload_coslinear" title="geotecha.speccon.integrals.pEDload_coslinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pEDload_coslinear</span></code></a></dt>
<dd>Same function with PolyLine inputs.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Assuming the load are formulated as the product of separate time and depth
dependant functions:</p>
<div class="math notranslate nohighlight">
\[\sigma\left({Z,t}\right)=\sigma\left({Z}\right)\sigma\left({t}\right)\]</div>
<p>the solution to the consolidation equation using the spectral method has
the form:</p>
<div class="math notranslate nohighlight">
\[u\left(Z,t\right)=\mathbf{\Phi v E}\left(\mathbf{\Gamma v}\right)^{-1}\mathbf{\theta}\]</div>
<p>The matrix <span class="math notranslate nohighlight">\(E\)</span> is a time dependent diagonal matrix due to time
dependant loadings.  The version of <span class="math notranslate nohighlight">\(E\)</span> calculated here in
<cite>EDload_coslinear</cite> is from loading terms in the governing equation that are NOT
differentiated wrt <span class="math notranslate nohighlight">\(t\)</span>.
The diagonal elements of <span class="math notranslate nohighlight">\(E\)</span> are given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{E}_{i,i}=\int_{0}^t{\frac{d{{\cos\left(\omega\tau+\textrm{phase}\right)}\sigma\left(\tau\right)}}{d\tau}{\exp\left({(dT\left(t-\tau\right)\lambda_i}\right)}\,d\tau}\]</div>
<p>where</p>
<blockquote>
<div><span class="math notranslate nohighlight">\(\lambda_i\)</span> is the <cite>ith</cite> eigenvalue of the problem,
<span class="math notranslate nohighlight">\(dT\)</span> is a time factor for numerical convienience,
<span class="math notranslate nohighlight">\(\sigma\left(\tau\right)\)</span> is the time dependant portion of the loading function.</div></blockquote>
<p>When the time dependant loading term <span class="math notranslate nohighlight">\(\sigma\left(\tau\right)\)</span> is
piecewise in time. The contribution of each load segment is found by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{E}_{i,i}=\int_{t_s}^{t_f}{\frac{d{{\cos\left(\omega\tau+\textrm{phase}\right)}\sigma\left(\tau\right)}}{d\tau}\exp\left({dT\left(t-\tau\right)*\lambda_i}\right)\,d\tau}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[t_s = \min\left(t,t_{increment\:start}\right)\]</div>
<div class="math notranslate nohighlight">
\[t_f = \min\left(t,t_{increment\:end}\right)\]</div>
<p>(note that this function,`EDload_coslinear`, rather than use <span class="math notranslate nohighlight">\(t_s\)</span> and
<span class="math notranslate nohighlight">\(t_f\)</span>,
explicitly finds increments that the current time falls in, falls after,
and falls before and treates each case on it’s own.)</p>
<p>Each <span class="math notranslate nohighlight">\(t\)</span> value of interest requires a separate diagonal matrix
<span class="math notranslate nohighlight">\(E\)</span>.  To use space more efficiently and to facilitate numpy
broadcasting when using the results of the function, the diagonal elements
of <span class="math notranslate nohighlight">\(E\)</span> for each time value <cite>t</cite> value are stored in the rows of
array <span class="math notranslate nohighlight">\(A\)</span> returned by <cite>EDload_coslinear</cite>.  Thus:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{A}=\left(\begin{matrix}E_{0,0}(t_0)&amp;E_{1,1}(t_0)&amp; \cdots &amp; E_{neig-1,neig-1}(t_0)\\ E_{0,0}(t_1)&amp;E_{1,1}(t_1)&amp; \cdots &amp; E_{neig-1,neig-1}(t_1)\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots \\ E_{0,0}(t_m)&amp;E_{1,1}(t_m)&amp; \cdots &amp; E_{neig-1,neig-1}(t_m)\end{matrix}\right)\end{split}\]</div>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.pEDload_linear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">pEDload_linear</code><span class="sig-paren">(</span><em>a</em>, <em>eigs</em>, <em>tvals</em>, <em>dT=1.0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#pEDload_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.pEDload_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integration of D[load(tau), tau] * exp(dT * eig * (t-tau)) between
[0, t], where load(tau) is piecewise linear.</p>
<p>Wrapper for EDload_linear to allow PolyLine inputs.</p>
<p>Performs integrations involving a piecewise linear load.  A 2d array of
dimensions A[len(tvals), len(eigs)]
is produced where the ‘i’th row of A contains the diagonal elements of the
spectral ‘E’ matrix calculated for the time value tvals[i]. i.e. rows of
this matrix will be assembled into the diagonal matrix ‘E’ elsewhere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PolyLine</span></dt>
<dd><p class="first last">PolyLine object representing piecewise linear load vs time.</p>
</dd>
<dt><strong>eigs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray</span></dt>
<dd><p class="first last">List of eigenvalues.</p>
</dd>
<dt><strong>tvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray`</span></dt>
<dd><p class="first last">List of time values to calculate integral at.</p>
</dd>
<dt><strong>dT</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">float</span></code>, optional</span></dt>
<dd><p class="first last">Time factor multiple (Default dT=1.0).</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A 2d array of dimesnions A[len(tvals), len(eigs)].
The ‘i’th row of A is the diagonal elements of the spectral ‘E’ matrix
calculated for the time tvals[i].</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.EDload_linear" title="geotecha.speccon.integrals.EDload_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EDload_linear</span></code></a></dt>
<dd>Wrapped function.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Assuming the load are formulated as the product of separate time and depth
dependant functions:</p>
<div class="math notranslate nohighlight">
\[\sigma\left({Z,t}\right)=\sigma\left({Z}\right)\sigma\left({t}\right)\]</div>
<p>the solution to the consolidation equation using the spectral method has
the form:</p>
<div class="math notranslate nohighlight">
\[u\left(Z,t\right)=\mathbf{\Phi v E}\left(\mathbf{\Gamma v}\right)^{-1}\mathbf{\theta}\]</div>
<p>The matrix <span class="math notranslate nohighlight">\(E\)</span> is a time dependent diagonal matrix due to time
dependant loadings.  The version of <span class="math notranslate nohighlight">\(E\)</span> calculated here in
<cite>EDload_linear</cite> is from loading terms in the governing equation that are NOT
differentiated wrt <span class="math notranslate nohighlight">\(t\)</span>.
The diagonal elements of <span class="math notranslate nohighlight">\(E\)</span> are given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{E}_{i,i}=\int_{0}^t{\frac{d{\sigma\left(\tau\right)}}{d\tau}{\exp\left({(dT\left(t-\tau\right)\lambda_i}\right)}\,d\tau}\]</div>
<p>where</p>
<blockquote>
<div><span class="math notranslate nohighlight">\(\lambda_i\)</span> is the <cite>ith</cite> eigenvalue of the problem,
<span class="math notranslate nohighlight">\(dT\)</span> is a time factor for numerical convienience,
<span class="math notranslate nohighlight">\(\sigma\left(\tau\right)\)</span> is the time dependant portion of the loading function.</div></blockquote>
<p>When the time dependant loading term <span class="math notranslate nohighlight">\(\sigma\left(\tau\right)\)</span> is
piecewise in time. The contribution of each load segment is found by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{E}_{i,i}=\int_{t_s}^{t_f}{{\sigma\left(\tau\right)}\exp\left({dT\left(t-\tau\right)*\lambda_i}\right)\,d\tau}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[t_s = \min\left(t,t_{increment\:start}\right)\]</div>
<div class="math notranslate nohighlight">
\[t_f = \min\left(t,t_{increment\:end}\right)\]</div>
<p>(note that this function,`EDload_linear`, rather than use <span class="math notranslate nohighlight">\(t_s\)</span> and
<span class="math notranslate nohighlight">\(t_f\)</span>,
explicitly finds increments that the current time falls in, falls after,
and falls before and treates each case on it’s own.)</p>
<p>Each <span class="math notranslate nohighlight">\(t\)</span> value of interest requires a separate diagonal matrix
<span class="math notranslate nohighlight">\(E\)</span>.  To use space more efficiently and to facilitate numpy
broadcasting when using the results of the function, the diagonal elements
of <span class="math notranslate nohighlight">\(E\)</span> for each time value <cite>t</cite> value are stored in the rows of
array <span class="math notranslate nohighlight">\(A\)</span> returned by <cite>EDload_linear</cite>.  Thus:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{A}=\left(\begin{matrix}E_{0,0}(t_0)&amp;E_{1,1}(t_0)&amp; \cdots &amp; E_{neig-1,neig-1}(t_0)\\ E_{0,0}(t_1)&amp;E_{1,1}(t_1)&amp; \cdots &amp; E_{neig-1,neig-1}(t_1)\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots \\ E_{0,0}(t_m)&amp;E_{1,1}(t_m)&amp; \cdots &amp; E_{neig-1,neig-1}(t_m)\end{matrix}\right)\end{split}\]</div>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.pEload_coslinear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">pEload_coslinear</code><span class="sig-paren">(</span><em>a</em>, <em>omega</em>, <em>phase</em>, <em>eigs</em>, <em>tvals</em>, <em>dT=1.0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#pEload_coslinear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.pEload_coslinear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integration of cos(omega*tau+phase)*load(tau) * exp(dT * eig * (t-tau)) between [0, t], where
load(tau) is piecewise linear.</p>
<p>Wrapper for Eload_coslinear to allow PolyLine inputs.</p>
<p>Performs integrations involving a piecewise linear load.  A 2d array of
dimensions A[len(tvals), len(eigs)]
is produced where the ‘i’th row of A contains the diagonal elements of the
spectral ‘E’ matrix calculated for the time value tvals[i]. i.e. rows of
this matrix will be assembled into the diagonal matrix ‘E’ elsewhere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PolyLine</span></dt>
<dd><p class="first last">PolyLine object representing piecewise linear load vs time.</p>
</dd>
<dt><strong>omega, phase</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Parameters that describe a cyclic load cos(omega * t + phase).</p>
</dd>
<dt><strong>eigs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray</span></dt>
<dd><p class="first last">List of eigenvalues.</p>
</dd>
<dt><strong>tvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray`</span></dt>
<dd><p class="first last">List of time values to calculate integral at.</p>
</dd>
<dt><strong>dT</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">float</span></code>, optional</span></dt>
<dd><p class="first last">Time factor multiple (Default dT=1.0).</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A 2d array of dimesnions A[len(tvals), len(eigs)].
The ‘i’th row of A is the diagonal elements of the spectral ‘E’ matrix
calculated for the time tvals[i].</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.Eload_coslinear" title="geotecha.speccon.integrals.Eload_coslinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Eload_coslinear</span></code></a></dt>
<dd>Wrapped function.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Assuming the load are formulated as the product of separate time and depth
dependant functions:</p>
<div class="math notranslate nohighlight">
\[\sigma\left({Z,t}\right)=\sigma\left({Z}\right)\sigma\left({t}\right)\]</div>
<p>the solution to the consolidation equation using the spectral method has
the form:</p>
<div class="math notranslate nohighlight">
\[u\left(Z,t\right)=\mathbf{\Phi v E}\left(\mathbf{\Gamma v}\right)^{-1}\mathbf{\theta}\]</div>
<p>The matrix <span class="math notranslate nohighlight">\(E\)</span> is a time dependent diagonal matrix due to time
dependant loadings.  The version of <span class="math notranslate nohighlight">\(E\)</span> calculated here in
<cite>Eload_coslinear</cite> is from loading terms in the governing equation that are NOT
differentiated wrt <span class="math notranslate nohighlight">\(t\)</span>.
The diagonal elements of <span class="math notranslate nohighlight">\(E\)</span> are given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{E}_{i,i}=\int_{0}^t{{\cos\left(\omega\tau+\textrm{phase}\right)}{\sigma\left(\tau\right)}{\exp\left({(dT\left(t-\tau\right)\lambda_i}\right)}\,d\tau}\]</div>
<p>where</p>
<blockquote>
<div><span class="math notranslate nohighlight">\(\lambda_i\)</span> is the <cite>ith</cite> eigenvalue of the problem,
<span class="math notranslate nohighlight">\(dT\)</span> is a time factor for numerical convienience,
<span class="math notranslate nohighlight">\(\sigma\left(\tau\right)\)</span> is the time dependant portion of the loading function.</div></blockquote>
<p>When the time dependant loading term <span class="math notranslate nohighlight">\(\sigma\left(\tau\right)\)</span> is
piecewise in time. The contribution of each load segment is found by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{E}_{i,i}=\int_{t_s}^{t_f}{{\cos\left(\omega\tau+\textrm{phase}\right)}{\sigma\left(\tau\right)}\exp\left({dT\left(t-\tau\right)*\lambda_i}\right)\,d\tau}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[t_s = \min\left(t,t_{increment\:start}\right)\]</div>
<div class="math notranslate nohighlight">
\[t_f = \min\left(t,t_{increment\:end}\right)\]</div>
<p>(note that this function,`Eload_coslinear`, rather than use <span class="math notranslate nohighlight">\(t_s\)</span> and
<span class="math notranslate nohighlight">\(t_f\)</span>,
explicitly finds increments that the current time falls in, falls after,
and falls before and treates each case on it’s own.)</p>
<p>Each <span class="math notranslate nohighlight">\(t\)</span> value of interest requires a separate diagonal matrix
<span class="math notranslate nohighlight">\(E\)</span>.  To use space more efficiently and to facilitate numpy
broadcasting when using the results of the function, the diagonal elements
of <span class="math notranslate nohighlight">\(E\)</span> for each time value <cite>t</cite> value are stored in the rows of
array <span class="math notranslate nohighlight">\(A\)</span> returned by <cite>Eload_coslinear</cite>.  Thus:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{A}=\left(\begin{matrix}E_{0,0}(t_0)&amp;E_{1,1}(t_0)&amp; \cdots &amp; E_{neig-1,neig-1}(t_0)\\ E_{0,0}(t_1)&amp;E_{1,1}(t_1)&amp; \cdots &amp; E_{neig-1,neig-1}(t_1)\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots \\ E_{0,0}(t_m)&amp;E_{1,1}(t_m)&amp; \cdots &amp; E_{neig-1,neig-1}(t_m)\end{matrix}\right)\end{split}\]</div>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.pEload_linear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">pEload_linear</code><span class="sig-paren">(</span><em>a</em>, <em>eigs</em>, <em>tvals</em>, <em>dT=1.0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#pEload_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.pEload_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integration of load(tau) * exp(dT * eig * (t-tau)) between [0, t], where
load(tau) is piecewise linear.</p>
<p>Wrapper for Eload_linear to allow PolyLine inputs.</p>
<p>Performs integrations involving a piecewise linear load.  A 2d array of
dimensions A[len(tvals), len(eigs)]
is produced where the ‘i’th row of A contains the diagonal elements of the
spectral ‘E’ matrix calculated for the time value tvals[i]. i.e. rows of
this matrix will be assembled into the diagonal matrix ‘E’ elsewhere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PolyLine</span></dt>
<dd><p class="first last">PolyLine object representing piecewise linear load vs time.</p>
</dd>
<dt><strong>eigs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray</span></dt>
<dd><p class="first last">List of eigenvalues.</p>
</dd>
<dt><strong>tvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray`</span></dt>
<dd><p class="first last">List of time values to calculate integral at.</p>
</dd>
<dt><strong>dT</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">float</span></code>, optional</span></dt>
<dd><p class="first last">Time factor multiple (Default dT=1.0).</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A 2d array of dimesnions A[len(tvals), len(eigs)].
The ‘i’th row of A is the diagonal elements of the spectral ‘E’ matrix
calculated for the time tvals[i].</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.Eload_linear" title="geotecha.speccon.integrals.Eload_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Eload_linear</span></code></a></dt>
<dd>Wrapped function, see for equations and other related functions.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Assuming the load are formulated as the product of separate time and depth
dependant functions:</p>
<div class="math notranslate nohighlight">
\[\sigma\left({Z,t}\right)=\sigma\left({Z}\right)\sigma\left({t}\right)\]</div>
<p>the solution to the consolidation equation using the spectral method has
the form:</p>
<div class="math notranslate nohighlight">
\[u\left(Z,t\right)=\mathbf{\Phi v E}\left(\mathbf{\Gamma v}\right)^{-1}\mathbf{\theta}\]</div>
<p>The matrix <span class="math notranslate nohighlight">\(E\)</span> is a time dependent diagonal matrix due to time
dependant loadings.  The version of <span class="math notranslate nohighlight">\(E\)</span> calculated here in
<cite>Eload_linear</cite> is from loading terms in the governing equation that are NOT
differentiated wrt <span class="math notranslate nohighlight">\(t\)</span>.
The diagonal elements of <span class="math notranslate nohighlight">\(E\)</span> are given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{E}_{i,i}=\int_{0}^t{{\sigma\left(\tau\right)}{\exp\left({(dT\left(t-\tau\right)\lambda_i}\right)}\,d\tau}\]</div>
<p>where</p>
<blockquote>
<div><span class="math notranslate nohighlight">\(\lambda_i\)</span> is the <cite>ith</cite> eigenvalue of the problem,
<span class="math notranslate nohighlight">\(dT\)</span> is a time factor for numerical convienience,
<span class="math notranslate nohighlight">\(\sigma\left(\tau\right)\)</span> is the time dependant portion of the loading function.</div></blockquote>
<p>When the time dependant loading term <span class="math notranslate nohighlight">\(\sigma\left(\tau\right)\)</span> is
piecewise in time. The contribution of each load segment is found by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{E}_{i,i}=\int_{t_s}^{t_f}{{\sigma\left(\tau\right)}\exp\left({dT\left(t-\tau\right)*\lambda_i}\right)\,d\tau}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[t_s = \min\left(t,t_{increment\:start}\right)\]</div>
<div class="math notranslate nohighlight">
\[t_f = \min\left(t,t_{increment\:end}\right)\]</div>
<p>(note that this function,`Eload_linear`, rather than use <span class="math notranslate nohighlight">\(t_s\)</span> and
<span class="math notranslate nohighlight">\(t_f\)</span>,
explicitly finds increments that the current time falls in, falls after,
and falls before and treates each case on it’s own.)</p>
<p>Each <span class="math notranslate nohighlight">\(t\)</span> value of interest requires a separate diagonal matrix
<span class="math notranslate nohighlight">\(E\)</span>.  To use space more efficiently and to facilitate numpy
broadcasting when using the results of the function, the diagonal elements
of <span class="math notranslate nohighlight">\(E\)</span> for each time value <cite>t</cite> value are stored in the rows of
array <span class="math notranslate nohighlight">\(A\)</span> returned by <cite>Eload_linear</cite>.  Thus:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{A}=\left(\begin{matrix}E_{0,0}(t_0)&amp;E_{1,1}(t_0)&amp; \cdots &amp; E_{neig-1,neig-1}(t_0)\\ E_{0,0}(t_1)&amp;E_{1,1}(t_1)&amp; \cdots &amp; E_{neig-1,neig-1}(t_1)\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots \\ E_{0,0}(t_m)&amp;E_{1,1}(t_m)&amp; \cdots &amp; E_{neig-1,neig-1}(t_m)\end{matrix}\right)\end{split}\]</div>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.pEload_sinlinear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">pEload_sinlinear</code><span class="sig-paren">(</span><em>a</em>, <em>omega</em>, <em>phase</em>, <em>eigs</em>, <em>tvals</em>, <em>dT=1.0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#pEload_sinlinear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.pEload_sinlinear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integration of sin(omega*tau+phase)*load(tau) * exp(dT * eig * (t-tau)) between [0, t], where
load(tau) is piecewise linear.</p>
<p>Wrapper for Eload_sinlinear to allow PolyLine inputs.</p>
<p>Performs integrations involving a piecewise linear load.  A 2d array of
dimensions A[len(tvals), len(eigs)]
is produced where the ‘i’th row of A contains the diagonal elements of the
spectral ‘E’ matrix calculated for the time value tvals[i]. i.e. rows of
this matrix will be assembled into the diagonal matrix ‘E’ elsewhere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PolyLine</span></dt>
<dd><p class="first last">PolyLine object representing piecewise linear load vs time.</p>
</dd>
<dt><strong>omega, phase</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Parameters that describe a cyclic load sin(omega * t + phase).</p>
</dd>
<dt><strong>eigs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray</span></dt>
<dd><p class="first last">List of eigenvalues.</p>
</dd>
<dt><strong>tvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d numpy.ndarray`</span></dt>
<dd><p class="first last">List of time values to calculate integral at.</p>
</dd>
<dt><strong>dT</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">float</span></code>, optional</span></dt>
<dd><p class="first last">Time factor multiple (Default dT=1.0).</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A 2d array of dimesnions A[len(tvals), len(eigs)].
The ‘i’th row of A is the diagonal elements of the spectral ‘E’ matrix
calculated for the time tvals[i].</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.Eload_sinlinear" title="geotecha.speccon.integrals.Eload_sinlinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Eload_sinlinear</span></code></a></dt>
<dd>Wrapped function.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Assuming the load are formulated as the product of separate time and depth
dependant functions:</p>
<div class="math notranslate nohighlight">
\[\sigma\left({Z,t}\right)=\sigma\left({Z}\right)\sigma\left({t}\right)\]</div>
<p>the solution to the consolidation equation using the spectral method has
the form:</p>
<div class="math notranslate nohighlight">
\[u\left(Z,t\right)=\mathbf{\Phi v E}\left(\mathbf{\Gamma v}\right)^{-1}\mathbf{\theta}\]</div>
<p>The matrix <span class="math notranslate nohighlight">\(E\)</span> is a time dependent diagonal matrix due to time
dependant loadings.  The version of <span class="math notranslate nohighlight">\(E\)</span> calculated here in
<cite>Eload_sinlinear</cite> is from loading terms in the governing equation that are NOT
differentiated wrt <span class="math notranslate nohighlight">\(t\)</span>.
The diagonal elements of <span class="math notranslate nohighlight">\(E\)</span> are given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{E}_{i,i}=\int_{0}^t{{\sin\left(\omega\tau+\textrm{phase}\right)}{\sigma\left(\tau\right)}{\exp\left({(dT\left(t-\tau\right)\lambda_i}\right)}\,d\tau}\]</div>
<p>where</p>
<blockquote>
<div><span class="math notranslate nohighlight">\(\lambda_i\)</span> is the <cite>ith</cite> eigenvalue of the problem,
<span class="math notranslate nohighlight">\(dT\)</span> is a time factor for numerical convienience,
<span class="math notranslate nohighlight">\(\sigma\left(\tau\right)\)</span> is the time dependant portion of the loading function.</div></blockquote>
<p>When the time dependant loading term <span class="math notranslate nohighlight">\(\sigma\left(\tau\right)\)</span> is
piecewise in time. The contribution of each load segment is found by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{E}_{i,i}=\int_{t_s}^{t_f}{{\sin\left(\omega\tau+\textrm{phase}\right)}{\sigma\left(\tau\right)}\exp\left({dT\left(t-\tau\right)*\lambda_i}\right)\,d\tau}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[t_s = \min\left(t,t_{increment\:start}\right)\]</div>
<div class="math notranslate nohighlight">
\[t_f = \min\left(t,t_{increment\:end}\right)\]</div>
<p>(note that this function,`Eload_sinlinear`, rather than use <span class="math notranslate nohighlight">\(t_s\)</span> and
<span class="math notranslate nohighlight">\(t_f\)</span>,
explicitly finds increments that the current time falls in, falls after,
and falls before and treates each case on it’s own.)</p>
<p>Each <span class="math notranslate nohighlight">\(t\)</span> value of interest requires a separate diagonal matrix
<span class="math notranslate nohighlight">\(E\)</span>.  To use space more efficiently and to facilitate numpy
broadcasting when using the results of the function, the diagonal elements
of <span class="math notranslate nohighlight">\(E\)</span> for each time value <cite>t</cite> value are stored in the rows of
array <span class="math notranslate nohighlight">\(A\)</span> returned by <cite>Eload_sinlinear</cite>.  Thus:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{A}=\left(\begin{matrix}E_{0,0}(t_0)&amp;E_{1,1}(t_0)&amp; \cdots &amp; E_{neig-1,neig-1}(t_0)\\ E_{0,0}(t_1)&amp;E_{1,1}(t_1)&amp; \cdots &amp; E_{neig-1,neig-1}(t_1)\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots \\ E_{0,0}(t_m)&amp;E_{1,1}(t_m)&amp; \cdots &amp; E_{neig-1,neig-1}(t_m)\end{matrix}\right)\end{split}\]</div>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.pdim1sin_DD_abDDf_linear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">pdim1sin_DD_abDDf_linear</code><span class="sig-paren">(</span><em>m</em>, <em>a</em>, <em>b</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#pdim1sin_DD_abDDf_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.pdim1sin_DD_abDDf_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integration of sin(mi * z) * D[a(z) * b(z) D[sin(mj * z),z,2],z,2]
between ztop and zbot where a(z) &amp; b(z) is piecewise linear functions of z.</p>
<p>Wrapper for dim1sin_DD_abDDf_linear to allow PolyLine inputs.</p>
<p>Calulation of integrals is performed at each element of a square symmetric
matrix (size depends on size of <cite>m</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">eigenvlaues of BVP. generate with geoteca.speccon.m_from_sin_mx</p>
</dd>
<dt><strong>a, b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PolyLine object</span></dt>
<dd><p class="first last">PolyLine defining piecewise linear relationship.</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A square symmetric matrix, size determined by size of <cite>m</cite>.</p>
</dd>
<dt><strong>See Also</strong></dt>
<dd></dd>
<dt><strong>——-</strong></dt>
<dd></dd>
<dt><strong>dim1sin_DD_abDDf_linear</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Wrapped function.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The <cite>dim1sin_DD_abDDf_linear</cite> matrix, <span class="math notranslate nohighlight">\(A\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i,j}=\int_{0}^1{\frac{d^2}{dz^2}\left({a\left(z\right)}{b\left(z\right)}\frac{d^2\phi_j}{dz^2}\right)\phi_i\,dz}\]</div>
<p>where the basis function <span class="math notranslate nohighlight">\(\phi_i\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\phi_i\left(z\right)=\sin\left({m_i}z\right)\]</div>
<p>and <span class="math notranslate nohighlight">\(a\left(z\right)\)</span> and <span class="math notranslate nohighlight">\(b\left(z\right)\)</span> are piecewise
linear functions with respect to <span class="math notranslate nohighlight">\(z\)</span>, that within a layer is defined by:</p>
<div class="math notranslate nohighlight">
\[a\left(z\right) = a_t+\frac{a_b-a_t}{z_b-z_t}\left(z-z_t\right)\]</div>
<p>with <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> subscripts representing ‘top’ and ‘bottom’ of
each layer respectively.</p>
<p>To make the above integration simpler we integate by parts to get:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i,j}= \left.{\frac{d}{dz}\left({a\left(z\right)}{b\left(z\right)}\frac{d^2\phi_j}{dz^2}\right)\phi_i}\right|_{z=0}^{z=1}
     - \left.{{a\left(z\right)}{b\left(z\right)}\frac{d^2\phi_j}{dz^2}\frac{d\phi_i}{dz}}\right|_{z=0}^{z=1}
+\int_{0}^1{{a\left(z\right)}{b\left(z\right)}\frac{d^2\phi_j}{dz^2}\frac{d^2\phi_i}{dz^2}\,dz}\]</div>
<p>In this case the sine basis functions means the end point terms in the above
equation are zero, leaving us with</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i,j}= \int_{0}^1{{a\left(z\right)}{b\left(z\right)}\frac{d^2\phi_j}{dz^2}\frac{d^2\phi_i}{dz^2}\,dz}\]</div>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.pdim1sin_D_aDb_linear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">pdim1sin_D_aDb_linear</code><span class="sig-paren">(</span><em>m</em>, <em>a</em>, <em>b</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#pdim1sin_D_aDb_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.pdim1sin_D_aDb_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrations of <cite>sin(mi * z) * D[a(z) * D[b(z), z], z]</cite>
between ztop and zbot where a(z) is a piecewise linear function of z,
and b(z) is a linear function of z.</p>
<p>Wrapper for dim1sin_D_aDb_linear to allow PolyLine inputs.</p>
<p>Calulation of integrals is performed at each element of a 1d array
(size depends on size of <cite>m</cite>).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The functions produced are set up to accept the b(z) input as
piecewise linear, i.e. b.x1, b.x2, b.y1, b.y2 etc. It is up to the user to
ensure that the b.x1 and b.x2 are such that they define a continuous
linear function. eg. to define b(z)=z+1 then use
b.x1=[0,0.4], b.x2=[0.4, 1], b.y1=[1,1.4], b.y2=[1.4,2].</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">eigenvlaues of BVP. generate with geoteca.speccon.m_from_sin_mx</p>
</dd>
<dt><strong>a, b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PolyLine object</span></dt>
<dd><p class="first last">PolyLine defining piecewise linear relationship.</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A 1d array size determined by size of <cite>m</cite>. Treat as column
vector.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.dim1sin_D_aDb_linear" title="geotecha.speccon.integrals.dim1sin_D_aDb_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim1sin_D_aDb_linear</span></code></a></dt>
<dd>Wrapped function.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The <cite>dim1sin_D_aDb_linear</cite> which should be treated as a column vector,
<span class="math notranslate nohighlight">\(A\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i}=\int_{0}^1{\frac{d}{dz}\left({a\left(z\right)}\frac{d}{dz}{b\left(z\right)}\right)\phi_i\,dz}\]</div>
<p>where the basis function <span class="math notranslate nohighlight">\(\phi_i\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\phi_i\left(z\right)=\sin\left({m_i}z\right)\]</div>
<p>and <span class="math notranslate nohighlight">\(a\left(z\right)\)</span> is a piecewise
linear functions with respect to <span class="math notranslate nohighlight">\(z\)</span>, that within a layer is defined by:</p>
<div class="math notranslate nohighlight">
\[a\left(z\right) = a_t+\frac{a_b-a_t}{z_b-z_t}\left(z-z_t\right)\]</div>
<p>with <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> subscripts representing ‘top’ and ‘bottom’ of
each layer respectively.</p>
<p><span class="math notranslate nohighlight">\(b\left(z\right)\)</span> is a linear function of <span class="math notranslate nohighlight">\(z\)</span> defined by</p>
<div class="math notranslate nohighlight">
\[b\left(z\right) = b_t+\left({b_b-b_t}\right)z\]</div>
<p>with <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> subscripts now representing ‘top’ and
‘bottom’ of the profile respectively.</p>
<p>Using the product rule for differentiation the above integral can be split
into:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i}=\int_{0}^1{\frac{da\left(z\right)}{dz}\frac{db\left(z\right)}{dz}\phi_i\,dz} +
\int_{0}^1{a\left(z\right)\frac{d^2b\left(z\right)}{dz^2}\phi_i\,dz}\]</div>
<p>The right hand term is zero because <span class="math notranslate nohighlight">\(b\left(z\right)\)</span> is a
continuous linear function so it’s second derivative is zero.  The
first derivative of <span class="math notranslate nohighlight">\(b\left(z\right)\)</span> is a constant so the
left term can be integrated by parts to give:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i}=\frac{db\left(z\right)}{dz}\left(
\left.\phi_i{a\left(z\right)}\right|_{z=0}^{z=1} -
-\int_{0}^1{{a\left(z\right)}\frac{d\phi_i}{dz}\,dz}
\right)\]</div>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.pdim1sin_D_aDf_linear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">pdim1sin_D_aDf_linear</code><span class="sig-paren">(</span><em>m</em>, <em>a</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#pdim1sin_D_aDf_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.pdim1sin_D_aDf_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integration of sin(mi * z) * D[a(z) * D[sin(mj * z),z],z]
between ztop and zbot where a(z) is piecewise linear functions of z.</p>
<p>Wrapper for dim1sin_D_aDf_linear to allow PolyLine inputs.</p>
<p>Calulation of integrals is performed at each element of a square symmetric
matrix (size depends on size of <cite>m</cite>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">eigenvlaues of BVP. generate with geoteca.speccon.m_from_sin_mx</p>
</dd>
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PolyLine object</span></dt>
<dd><p class="first last">PolyLine defining piecewise linear relationship.</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A square symmetric matrix, size determined by size of <cite>m</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.dim1sin_D_aDf_linear" title="geotecha.speccon.integrals.dim1sin_D_aDf_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim1sin_D_aDf_linear</span></code></a></dt>
<dd>Wrapped function.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The <cite>dim1sin_D_aDf_linear</cite> matrix, <span class="math notranslate nohighlight">\(A\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i,j}=\int_{0}^1{\frac{d}{dz}\left({a\left(z\right)}\frac{d\phi_j}{dz}\right)\phi_i\,dz}\]</div>
<p>where the basis function <span class="math notranslate nohighlight">\(\phi_i\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\phi_i\left(z\right)=\sin\left({m_i}z\right)\]</div>
<p>and <span class="math notranslate nohighlight">\(a\left(z\right)\)</span> is a piecewise
linear functions with respect to <span class="math notranslate nohighlight">\(z\)</span>, that within a layer is defined by:</p>
<div class="math notranslate nohighlight">
\[a\left(z\right) = a_t+\frac{a_b-a_t}{z_b-z_t}\left(z-z_t\right)\]</div>
<p>with <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> subscripts representing ‘top’ and ‘bottom’ of
each layer respectively.</p>
<p>To make the above integration simpler we integate by parts to get:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i,j}= \left.\phi_i{a\left(z\right)}\frac{d\phi_j}{dz}\right|_{z=0}^{z=1} -\int_{0}^1{{a\left(z\right)}\frac{d\phi_j}{dz}\frac{d\phi_i}{dz}\,dz}\]</div>
<p>In this case the sine basis functions means the left term in the above
equation is zero, leaving us with</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i,j}= -\int_{0}^1{{a\left(z\right)}\frac{d\phi_j}{dz}\frac{d\phi_i}{dz}\,dz}\]</div>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.pdim1sin_a_linear_between">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">pdim1sin_a_linear_between</code><span class="sig-paren">(</span><em>m</em>, <em>a</em>, <em>z</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#pdim1sin_a_linear_between"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.pdim1sin_a_linear_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrations of <cite>sin(mi * z) * a(z)</cite>
between [z1, z2] where a(z) is a piecewise linear functions of z.</p>
<p>Wrapper for dim1sin_a_linear_between to allow PolyLine inputs.</p>
<p>Calculates array A[len(z), len(m)].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">Eigenvlaues of BVP. generate with geoteca.speccon.m_from_sin_mx</p>
</dd>
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PolyLine object</span></dt>
<dd><p class="first last">PolyLine defining piecewise linear relationship.</p>
</dd>
<dt><strong>z</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">list</span></code> of float``</span></dt>
<dd><p class="first last">Normalised depth or z-coordinate pair should be two values
between 0 and 1.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A 2d array size of size [len(z), len(m)].</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.dim1sin_a_linear_between" title="geotecha.speccon.integrals.dim1sin_a_linear_between"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim1sin_a_linear_between</span></code></a></dt>
<dd>Wrapped function.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The <cite>dim1sin_a_linear_between</cite>, <span class="math notranslate nohighlight">\(A\)</span>, is given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i,j}=
\int_{z_1}^{z_2}{{a\left(z\right)}\phi_j\,dz}\]</div>
<p>where the basis function <span class="math notranslate nohighlight">\(\phi_j\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\phi_j\left(z\right)=\sin\left({m_j}z\right)\]</div>
<p>and <span class="math notranslate nohighlight">\(a\left(z\right)\)</span> is a piecewise
linear functions with respect to <span class="math notranslate nohighlight">\(z\)</span>, that within a layer are defined by:</p>
<div class="math notranslate nohighlight">
\[a\left(z\right) = a_t+\frac{a_b-a_t}{z_b-z_t}\left(z-z_t\right)\]</div>
<p>with <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> subscripts representing ‘top’ and ‘bottom’ of
each layer respectively.</p>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.pdim1sin_ab_linear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">pdim1sin_ab_linear</code><span class="sig-paren">(</span><em>m</em>, <em>a</em>, <em>b</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#pdim1sin_ab_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.pdim1sin_ab_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integration of sin(mi * z) * a(z) * b(z)
between ztop and zbot where a(z) and b(z) are piecewise linear functions of z.</p>
<p>Wrapper for dim1sin_ab_linear to allow PolyLine inputs.</p>
<p>Calulation of integrals is performed at each element of a 1d array
(size depends on size of <cite>m</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">eigenvlaues of BVP. generate with geoteca.speccon.m_from_sin_mx</p>
</dd>
<dt><strong>a, b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PolyLine object</span></dt>
<dd><p class="first last">PolyLine defining piecewise linear relationship.</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A 1d array size determined by size of <cite>m</cite>. Treat as column
vector.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.dim1sin_ab_linear" title="geotecha.speccon.integrals.dim1sin_ab_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim1sin_ab_linear</span></code></a></dt>
<dd>Wrapped function.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The <cite>dim1sin_ab_linear</cite> which should be treated as a column vector,
<span class="math notranslate nohighlight">\(A\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i}=\int_{0}^1{{a\left(z\right)}{b\left(z\right)}\phi_i\,dz}\]</div>
<p>where the basis function <span class="math notranslate nohighlight">\(\phi_i\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\phi_i\left(z\right)=\sin\left({m_i}z\right)\]</div>
<p>and <span class="math notranslate nohighlight">\(a\left(z\right)\)</span> and <span class="math notranslate nohighlight">\(b\left(z\right)\)</span> are piecewise
linear functions with respect to <span class="math notranslate nohighlight">\(z\)</span>, that within a layer are defined by:</p>
<div class="math notranslate nohighlight">
\[a\left(z\right) = a_t+\frac{a_b-a_t}{z_b-z_t}\left(z-z_t\right)\]</div>
<p>with <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> subscripts representing ‘top’ and ‘bottom’ of
each layer respectively.</p>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.pdim1sin_abc_linear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">pdim1sin_abc_linear</code><span class="sig-paren">(</span><em>m</em>, <em>a</em>, <em>b</em>, <em>c</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#pdim1sin_abc_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.pdim1sin_abc_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrations of sin(mi * z) * a(z) * b(z) * c(z)
between ztop and zbot where a(z), b(z), c(z) are piecewise linear functions of z.</p>
<p>Wrapper for dim1sin_abc_linear to allow PolyLine inputs.</p>
<p>Calulation of integrals is performed at each element of a 1d array
(size depends on size of <cite>m</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">eigenvlaues of BVP. generate with geoteca.speccon.m_from_sin_mx</p>
</dd>
<dt><strong>a, b, c</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PolyLine object</span></dt>
<dd><p class="first last">PolyLine defining piecewise linear relationship.</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A 1d array size determined by size of <cite>m</cite>. Treat as column
vector.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.dim1sin_abc_linear" title="geotecha.speccon.integrals.dim1sin_abc_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim1sin_abc_linear</span></code></a></dt>
<dd>Wrapped function.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The <cite>dim1sin_abc_linear</cite> which should be treated as a column vector,
<span class="math notranslate nohighlight">\(A\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i}=\int_{0}^1{{a\left(z\right)}{b\left(z\right)}{c\left(z\right)}\phi_i\,dz}\]</div>
<p>where the basis function <span class="math notranslate nohighlight">\(\phi_i\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\phi_i\left(z\right)=\sin\left({m_i}z\right)\]</div>
<p>and <span class="math notranslate nohighlight">\(a\left(z\right)\)</span>, <span class="math notranslate nohighlight">\(b\left(z\right)\)</span>, and
<span class="math notranslate nohighlight">\(c\left(z\right)\)</span> are piecewise linear functions
with respect to <span class="math notranslate nohighlight">\(z\)</span>, that within a layer are defined by:</p>
<div class="math notranslate nohighlight">
\[a\left(z\right) = a_t+\frac{a_b-a_t}{z_b-z_t}\left(z-z_t\right)\]</div>
<p>with <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> subscripts representing ‘top’ and ‘bottom’ of
each layer respectively.</p>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.pdim1sin_abf_linear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">pdim1sin_abf_linear</code><span class="sig-paren">(</span><em>m</em>, <em>a</em>, <em>b</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#pdim1sin_abf_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.pdim1sin_abf_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Integration of sin(mi * z) * a(z) * a(z) * sin(mj * z)
between ztop and zbot where a(z) is piecewise linear.</p>
<p>Wrapper for dim1sin_abf_linear to allow PolyLine inputs.</p>
<p>Calulation of integrals is performed at each element of a square symmetric
matrix (size depends on size of <cite>m</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><p class="first last">eigenvlaues of BVP. generate with geoteca.speccon.m_from_sin_mx</p>
</dd>
<dt><strong>a, b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PolyLine object</span></dt>
<dd><p class="first last">PolyLine defining piecewise linear relationship.</p>
</dd>
<dt><strong>implementation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A square symmetric matrix, size determined by size of <cite>m</cite>.</p>
</dd>
<dt><strong>See Also</strong></dt>
<dd></dd>
<dt><strong>——-</strong></dt>
<dd></dd>
<dt><strong>dim1sin_abf_linear</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Wrapped function.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The <cite>dim1sin_abf_linear</cite> matrix, <span class="math notranslate nohighlight">\(A\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{i,j}=\int_{0}^1{{a\left(z\right)}{b\left(z\right)}\phi_i\phi_j\,dz}\]</div>
<p>where the basis function <span class="math notranslate nohighlight">\(\phi_i\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\phi_i\left(z\right)=\sin\left({m_i}z\right)\]</div>
<p>and <span class="math notranslate nohighlight">\(a\left(z\right)\)</span> and <span class="math notranslate nohighlight">\(b\left(z\right)\)</span> are piecewise
linear functions with respect to <span class="math notranslate nohighlight">\(z\)</span>, that within a layer are defined by:</p>
<div class="math notranslate nohighlight">
\[a\left(z\right) = a_t+\frac{a_b-a_t}{z_b-z_t}\left(z-z_t\right)\]</div>
<p>with <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> subscripts representing ‘top’ and ‘bottom’ of
each layer respectively.</p>
</dd></dl>

<dl class="function">
<dt id="geotecha.speccon.integrals.pdim1sin_af_linear">
<code class="descclassname">geotecha.speccon.integrals.</code><code class="descname">pdim1sin_af_linear</code><span class="sig-paren">(</span><em>m</em>, <em>a</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geotecha/speccon/integrals.html#pdim1sin_af_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#geotecha.speccon.integrals.pdim1sin_af_linear" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Integration of sin(mi * z) * a(z) * sin(mj * z)</dt>
<dd><p class="first">between ztop and zbot where a(z) is piecewise linear.</p>
<p>Wrapper for dim1sin_af_linear with PolyLine input.</p>
<p class="last">Calculation of integrals is performed at each element of a square symmetric
matrix (size depends on size of <cite>m</cite>)</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></span></dt>
<dd><blockquote class="first">
<div><p>Eeigenvlaues of BVP. Generate with geoteca.speccon.m_from_sin_mx.</p>
</div></blockquote>
<dl class="last docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">PolyLine object</span></dt>
<dd><p class="first last">PolyLine defining piecewise linear relationship.</p>
</dd>
<dt>implementation <span class="classifier-delimiter">:</span> <span class="classifier">[‘vectorized’, ‘scalar’, ‘fortran’], optional</span></dt>
<dd><p class="first last">Functional implementation: ‘scalar’ = python loops (slow),
‘fortran’ = fortran code (fastest), ‘vectorized’ = numpy(fast).
Default implementation=’vectorized’.  If fortran extention module
cannot be imported then ‘vectorized’ version will be used.
If anything other than ‘fortran’ or ‘scalar’ is used then
default vectorized version will be used.</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">A square symmetric matrix, size determined by size of <cite>m</cite></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#geotecha.speccon.integrals.m_from_sin_mx" title="geotecha.speccon.integrals.m_from_sin_mx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">m_from_sin_mx</span></code></a></dt>
<dd>Used to generate ‘m’ input parameter.</dd>
<dt><a class="reference internal" href="#geotecha.speccon.integrals.dim1sin_af_linear" title="geotecha.speccon.integrals.dim1sin_af_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim1sin_af_linear</span></code></a></dt>
<dd>Wrapped function. inputs.</dd>
</dl>
</div>
<p>s</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2014, Rohan Walker.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/api/geotecha.speccon.integrals.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>